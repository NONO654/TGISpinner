!MTRX!AD! program emxSpinnerAccess.tcl "3DEXPERIENCE R2015x(24.0.0.0)"
emxSpinnerAccess.tcl 0 "" "#####################################################################*10.80
#
# @progdoc      emxSpinnerAccess.tcl vM10.80 (Build 8.3.31)
#
# @Description: This is schema spinner that adds or modifies schema
#               policy and/or rule access.  Invoked from program
#               'emxSpinnerAgent.tcl' but may be run separately.
#
# @Parameters:  None
#
# @Usage:       Run this program for an MQL command window w/data files in directories:
#               . (current dir)         emxSpinnerAgent.tcl, emxSpinnerAccess.tcl programs
#               ./Business/Policy       Policy access data files from Bus Doc Generator program
#               ./Business/Rule         Rule access data files from Bus Doc Generator program        
#
# @progdoc      Copyright (c) MatrixOne Inc., June 26, 2002
#
# @Originator:  Greg Inglis
#
#########################################################################
#
# @Modifications: Venkatesh Harikrishan 04/03/2006 - Fix for Incident 317721
#
#########################################################################
tcl;

eval {
   if {[info host] == \"mostermant43\" } {
      source \"c:/Program Files/TclPro1.3/win32-ix86/bin/prodebug.tcl\"
      set cmd \"debugger_eval\"
      set xxx [debugger_init]
   } else {
      set cmd \"eval\"
   }
}
$cmd {

#************************************************************************
# Procedure:   pfile_write
#
# Description: Procedure to write a variable to file.
#
# Parameters:  The filename to write to,
#              The data variable.
#
# Returns:     Nothing
#************************************************************************

proc pfile_write { filename data } {
  return  [catch {
    set fileid [open $filename \"a+\"]
    puts $fileid $data
    close $fileid
  }]
}
#End pfile_write


#************************************************************************
# Procedure:   pfile_read
#
# Description: Procedure to read a file.
#
# Parameters:  The filename to read from.
#
# Returns:     The file data
#************************************************************************

proc pfile_read { filename } {
  global sPolicyRule aPolicyRule
  set data \"\"
  # IR Fix 317721
  set sSpinnerDir [mql get env SPINNERPATH]
  set sFile \"$sSpinnerDir/Business/$aPolicyRule($sPolicyRule)/$filename\"
  #set sFile \"./Business/$aPolicyRule($sPolicyRule)/$filename\"

  if { [file readable $sFile] } {
    set fd [open $sFile r]
    set data [read $fd]
    close $fd
  } else { # IR Fix 317721
  	puts \"File Not Found\"
  }
  return $data
}
#End file_read


################################################################################
# Replace_Space
#   Replace space characters by underscore
#   
#   Parameters :
#       string
#   Return :
#       string 
#
proc Replace_Space { string } {
    regsub -all -- \" \" $string \"_\" string
    return $string
}


proc pProcessMqlCmd { sAction sType sName sMql } {

    global sMsg_Log iAccessError bScan sLogFileError bSpinnerAgent
    append sMsg_Log \"# ACTION: $sAction $sType $sName\\n\"

    if {$bScan} {
        append sMsg_Log \"$sMql\\n\"
        puts -nonewline \":\"
        set sMsg \"\"
    } else {
    	mql start transaction update
        if { [ catch { eval $sMql } sMsg ] != 0 } {
            set sErrMsg \"$sAction $sType $sName NOT successful.\\nCommand: $sMql\\nError Reason is $sMsg\\n\"
            append sMsg_Log $sErrMsg
            mql abort transaction
            puts -nonewline \"!\"
            if {$bSpinnerAgent} {
               set iLogFileErr [open $sLogFileError a+]
               puts $iLogFileErr $sErrMsg
               close $iLogFileErr
            }
            incr iAccessError
        } else {
            append sMsg_Log \"# $sAction $sType $sName Successful.\"
            puts -nonewline \":\"
            mql commit transaction
        }
    }
    return $sMsg
}
#End pProcessMqlCmd


# Procedure to pass tcl-type variables in tcl eval commands
   proc pRegSubEscape {sEscape} {
      regsub -all \"\\134$\" $sEscape \"\\134\\134\\$\" sEscape
      regsub -all \"\\134{\" $sEscape \"\\134\\134\\173\" sEscape
      regsub -all \"\\134}\" $sEscape \"\\134\\134\\175\" sEscape
      regsub -all \"\\134\\133\" $sEscape \"\\134\\134\\133\" sEscape
      regsub -all \"\\134\\135\" $sEscape \"\\134\\134\\135\" sEscape
      if {[string range $sEscape 0 0] == \"\\042\" && [string range $sEscape end end] == \"\\042\" && [string length $sEscape] > 2} {
         set iLast [expr [string length $sEscape] -2]
   	 set sEscape [string range $sEscape 1 $iLast]
      }
      regsub -all \"\\042\\042\" $sEscape \"\\042\" sEscape
      regsub -all \"\\042\" $sEscape \"\\134\\042\" sEscape
      return $sEscape
   }
#End pRegSubEscape


proc pCompareLists { lList1 lList2 } {

    set lCommon {}
    set lUnique1 {}
    foreach i1 $lList1 {
        set nFound [ lsearch $lList2 $i1 ]
        if { $nFound == -1 } {
            lappend lUnique1 $i1
        } else {
            lappend lCommon $i1
            set lList2 [ lreplace $lList2 $nFound $nFound ]
        }
    }
    set lResults [ list $lUnique1 $lCommon $lList2 ]
    return $lResults
}


proc pPolicyData { sPol } {
    global sPolicyRule bAllState

    set lAccessModes [ list read modify delete checkout checkin schedule lock \\
        unlock execute freeze thaw create revise promote demote grant enable \\
        disable override changename changetype changeowner changepolicy revoke \\
        changevault fromconnect toconnect fromdisconnect todisconnect \\
        viewform modifyform show ]

    set lData {}
    set sStates [list 999999]
    if {$sPolicyRule == \"policy\"} {
        set sStates [ split [ mql print policy $sPol select state dump | ] | ]
        if {$bAllState && $sStates != [list ]} {lappend sStates \"allstate\"}
    }
    foreach sSt $sStates {
        set sStateCmdOwner \"owneraccess\"
        set sStateCmdPublic \"publicaccess\"
        set sStateCmdAccess \"access\"
        set sStateCmdFilter \"filter\"
        if {$sPolicyRule == \"policy\"} {
            if {$sSt == \"allstate\"} {
                set sStateCmdOwner \"allstate.owneraccess\"
                set sStateCmdPublic \"allstate.publicaccess\"
                set sStateCmdAccess \"allstate.access\"
                set sStateCmdFilter \"allstate.filter\"
            } else {           
                set sStateCmdOwner \"state\\134\\[\\$sSt\\134\\].owneraccess\"
                set sStateCmdPublic \"state\\134\\[\\$sSt\\134\\].publicaccess\"
                set sStateCmdAccess \"state\\134\\[\\$sSt\\134\\].access\"
                set sStateCmdFilter \"state\\134\\[\\$sSt\\134\\].filter\"
            }
        }
        set sOwner Owner
        eval \"set sAccess \\[mql print $sPolicyRule \\\"$sPol\\\" select $sStateCmdOwner dump \\]\"
        set sRights [ split [ string trim $sAccess ] , ]
        if { $sRights == \"all\" } {
            set sRights $lAccessModes
        } elseif { $sRights == \"none\" } {
            set sRights \"\"
        }
        lappend lData [ list $sSt $sOwner $sRights \"\" ]
        set sOwner Public
        eval \"set sAccess \\[mql print $sPolicyRule \\\"$sPol\\\" select $sStateCmdPublic dump \\]\"
        set sRights [ split [ string trim $sAccess ] , ]
        if { $sRights == \"all\" } {
            set sRights $lAccessModes
        } elseif { $sRights == \"none\" } {
            set sRights \"\"
        }
        lappend lData [ list $sSt $sOwner $sRights \"\" ]
        
        eval \"set sUser \\[ mql print $sPolicyRule \\\"$sPol\\\" select $sStateCmdAccess \\]\"
        set sUsers [ split $sUser \\n ]
        foreach i $sUsers {
            set i [ string trim $i ]
            if {[string first $sPolicyRule $i] == 0} {continue}
            if { $i != \"\" } {
                if {[string first \".\" $i] >= 0} {
                    set i [ lindex [ split $i \".\" ] 1 ]
                }
                set sLine [ split $i \"=\" ]
                set sRights [ split [ string trim [ lindex $sLine 1 ] ] , ]
                if { $sRights == \"all\" } {
                    set sRights $lAccessModes
                } elseif { $sRights == \"none\" } {
                    set sRights \"\"
                }
                set sUs [string trim [ lindex $sLine 0 ] ]
                if {[string first \"access\\[\" $sUs] > -1} {
                    regsub \"access\\134\\[\" $sUs \"|\" sUs
                    set sUs [lindex [split $sUs |] 1]
                    regsub \"\\134\\]\" $sUs \"\" sOwner
                    eval \"set sFilter \\[ mql print $sPolicyRule \\\"$sPol\\\" select $sStateCmdFilter\\134\\[$sOwner\\134\\] dump \\]\"
                    lappend lData [ list $sSt $sOwner $sRights $sFilter ]
                }
            }
        }
    }
    return $lData
}
#End pPolicyData

#main

    set sMxVersion \"10.9\"
    if {[string first \"V6\" $sMxVersion] >= 0} {
       set sAppend [lindex [split $sMxVersion \"R\"] 1]
       set sAppend [join [lrange [split $sAppend -] 0 1] \"\"]
       set sAppend [join [lrange [split $sAppend .] 0 1] \"\"]
       set sMxVersion \"10.9$sAppend\"
    } else {
       set sMxVersion [join [lrange [split $sMxVersion .] 0 1] .]
    }
    set bScan [mql get env SPINNERSCANMODE]; #scan mode
    if {$bScan != \"TRUE\"} {set bScan FALSE}
    set bShowModOnly [mql get env SHOWMODONLY]
    set lFilesXLS [mql get env FILELIST]

    array set aPolicyRule [list policy Policy rule Rule]
    set sSuffix [clock format [clock seconds] -format \".%m%d%y\"]
    if {$bScan} {set sSuffix \".SCAN\"}
    set sDelimit \"\\t\"

    set sPolicyRuleAccess [mql get env ACCESSTYPE]
    if { $sPolicyRuleAccess == \"\"} {
       set lsPolicyRule [list policy rule]
    } else {
       regsub \"access\" $sPolicyRuleAccess \"\" sPolicyRule
       set lsPolicyRule [list $sPolicyRule]
    }
    foreach sPolicyRule $lsPolicyRule {
        set iAccessError 0
        set sMsg_Log \"\"
        eval \"set slPolicy \\[mql list \\\"$sPolicyRule\\\" * \\]\"
        set lPolicies [split $slPolicy \\n]
       
        if {[mql get env SPINNERLOGFILE] != \"\"} {; # SpinnerAgent Hook
           set bSpinnerAgent TRUE
           set sOutFile \"[mql get env SPINNERLOGFILE]\"
           set sLogFileError [mql get env SPINNERERRORLOG]
        } else {
           set bSpinnerAgent FALSE    
           set sOutFile \"./logs/$aPolicyRule($sPolicyRule)Access$sSuffix.log\"
           file delete $sOutFile
        }
        
        set lFiles \"\"
        if {$lFilesXLS == \"\"} {set lFilesXLS [ glob -nocomplain \"./Business/$aPolicyRule($sPolicyRule)/*.xls\" ]}
        foreach filename $lFilesXLS {
            set name [file rootname [file tail $filename ]]
            lappend lFiles $name
        }
        
        set lNames [ pCompareLists $lFiles $lPolicies ]
    
        set sExtra [ lindex $lNames 0 ]
        set sCommon [ lindex $lNames 1 ]
        
        foreach sName $sCommon {
            set bAllState FALSE
            if {$sMxVersion >= 10.8} {
                catch {set bAllState [mql print policy $sName select allstate dump]} sMsg
            }
            pfile_write $sOutFile $sMsg_Log
            set sMsg_Log \"\"
            set sPolicyFile {}
            set sPolicyDB [ pPolicyData $sName ]
	    # IR Fix 317721
            set lFileData [ split [ pfile_read \"$sName.xls\" ] \\n ]
            set nCount 0
            foreach sLine $lFileData {
                set sLineData [ split $sLine $sDelimit ]
                set nL [ llength $sLineData ]
                if { $sLineData == \"\" } {
                    continue
                }
                if { $nCount == 0 } {
                    set sHeader [ string tolower $sLineData ]
                } else {
                    # process the data line!!
                    if {$sPolicyRule == \"rule\"} {
                         set sState 999999
                    } else {
                         set sState [ lindex $sLineData 0 ]
                    }
                    set sOwner [ lindex $sLineData 1 ]

                    set nPos 0
                    set sRights {}
                    set sFilter {}
                    foreach  i $sHeader j $sLineData {
                        if { $nPos > 1 } {
                            set bHasAccess [ string tolower $j ]
                            if {$i == \"filter\"} {
                                set sFilter $j
                            } elseif { $bHasAccess == \"y\" } {
                                lappend sRights $i
                            }
                        }
                        incr nPos
                    }
                    lappend sPolicyFile [ list $sState $sOwner $sRights $sFilter ]
                }
                incr nCount
            }
            set lRes [ pCompareLists $sPolicyFile $sPolicyDB ]
            set lLeft [ lindex $lRes 0 ]
            set lComm [ lindex $lRes 1 ]
            set lRight [ lindex $lRes 2 ]
    
            append sMsg_Log \"\\n# \\[[clock format [clock seconds] -format %H:%M:%S]\\] $aPolicyRule($sPolicyRule)Access '$sName':\"
            puts -nonewline \"\\n$sPolicyRule $sName\"
            
            foreach sCommon $lComm {
                set sSt [ lindex $sCommon 0 ]
                if {$sSt == \"999999\"} {
                   set sInsert \"\"
                } else {
                   set sInsert \" state $sSt\"
                }
                set sUser [ lindex $sCommon 1 ]
                if {$bShowModOnly == \"FALSE\"} {append sMsg_Log \"# No Change Required for$sInsert $sUser\\n\"}
                puts -nonewline \".\"
            }
            
            foreach sLeft $lLeft {
                set sSt [ lindex $sLeft 0 ]
                if {$sSt == \"999999\"} {
                    set sInsert \"\"
                    set sCmdInsert \"\"
                } else {
                    if {$sSt == \"allstate\"} {
                        if {$bAllState} {
                            set sInsert \" allstate\"
                            set sCmdInsert \"allstate\"
                        } else {
                            continue
                        }
                    } else {
                        set sInsert \" state $sSt\"
                        set sCmdInsert \"state \\134\\\"$sSt\\134\\\"\"
                    }
                }
                set sOwn [ lindex $sLeft 1 ]
                set sAcc [ lindex $sLeft 2 ]
                set sFilter [ lindex $sLeft 3 ]
                set nIndex [ lsearch -glob $lRight [list $sSt $sOwn*] ]
                
                set sDB [ lindex $lRight $nIndex ]
                set sDBSt [ lindex $sDB 0 ]
                set sDBOwn [ lindex $sDB 1 ]
                set sDBAcc [ lindex $sDB 2 ]
                set sDBFilter [ lindex $sDB 3 ]
                
                set lReqAcc [ pCompareLists $sAcc $sDBAcc ]
                
                set lAdd [ join [ lindex $lReqAcc 0 ] , ]
                set lDel [ join [ lindex $lReqAcc 2 ] , ]
                
                if {$sDBFilter != \"\"} {set sDBFilter [pRegSubEscape $sDBFilter]}
                if {$sFilter != \"\"} {set sFilter [pRegSubEscape $sFilter]}
                
                if {[ llength $lAdd ] != 0 || $sFilter != $sDBFilter} {
                  
                    if {$lAdd == \"\"} {set lAdd none}
                    append sMsg_Log \"mod $aPolicyRule($sPolicyRule) $sName$sInsert add user \\\"$sOwn\\\" $lAdd filter \\\"$sFilter\\\"\\n\"
                    
                    if { $sOwn == \"Public\" || $sOwn == \"Owner\" } {
                        set sCmd \"mql mod $sPolicyRule \\\"$sName\\\" $sCmdInsert add \\\"$sOwn\\\" \\\"$lAdd\\\"\"
                    } else {
                        set sCmd \"mql mod $sPolicyRule \\\"$sName\\\" $sCmdInsert add user \\\"$sOwn\\\" \\\"$lAdd\\\" filter \\\"$sFilter\\\"\"
                    }
                    pProcessMqlCmd Mod $aPolicyRule($sPolicyRule) $sName $sCmd
                } else {
                    puts -nonewline \".\"
                }
    
                if { [ llength $lDel ] != 0 } {
                    append sMsg_Log \"mod $aPolicyRule($sPolicyRule) $sName$sInsert remove $sOwn $lDel\\n\"                    

                    if { $sOwn == \"Public\" || $sOwn == \"Owner\" } {
                        set sCmd \"mql mod $sPolicyRule \\\"$sName\\\" $sCmdInsert remove \\\"$sOwn\\\" \\\"$lDel\\\"\"
                    } else {
                        set sCmd \"mql mod $sPolicyRule \\\"$sName\\\" $sCmdInsert remove user \\\"$sOwn\\\" \\\"$lDel\\\"\"
                    }
                    pProcessMqlCmd Mod $aPolicyRule($sPolicyRule) $sName $sCmd
                }
                
                if { $nIndex != -1 } {
                    set lRight [ lreplace $lRight $nIndex $nIndex ]
                }
            }
            set lLeft {}
            
            foreach sRight $lRight {
                set sSt [ lindex $sRight 0 ]
                if {$sSt == \"999999\"} {
                    set sInsert \"\"
                    set sCmdInsert \"\"
                } else {
                    if {$sSt == \"allstate\"} {
                        if {$bAllState} {
                            set sInsert \" allstate\"
                            set sCmdInsert \"allstate\"
                        } else {
                            continue
                        }
                    } else {
                        set sInsert \" state $sSt\"
                        set sCmdInsert \"state \\134\\\"$sSt\\134\\\"\"
                    }
                }
                set sOwn [ lindex $sRight 1 ]
                append sMsg_Log \"# Remove all access for $aPolicyRule($sPolicyRule) $sName$sInsert person $sOwn\\n\"
                
                if { $sOwn == \"Public\" || $sOwn == \"Owner\" } {
                    set sCmd \"mql mod $sPolicyRule \\\"$sName\\\" $sCmdInsert remove \\\"$sOwn\\\" all\"
                } else {
                    set sCmd \"mql mod $sPolicyRule \\\"$sName\\\" $sCmdInsert remove user \\\"$sOwn\\\" all\"
                }
                pProcessMqlCmd Mod $aPolicyRule($sPolicyRule) $sName $sCmd
            }
            set lRight {}
        }
        
        pfile_write $sOutFile $sMsg_Log
        if {$bSpinnerAgent} {pfile_write $sOutFile \"\"}
        puts \"\"
        mql set env ACCESSERROR $iAccessError
    }
}" 1 0 0 0 0 0 0 0 0 0 0 0 "" 0 0
 0 1
 SpinnerAgent NULL noname "3/27/2017 3:41:27 PM" 0
"12/6/2015 11:42:57 PM" "3/14/2018 3:57:25 PM"
9
 0 1 "12/6/2015 11:42:57 PM" creator "add program emxSpinnerAccess.tcl mql execute immediate !needsbusinessobject !downloadable !pipe !pooled nothidden file ./Business/SourceFiles/emxSpinnerAccess.tcl"
 0 2 "12/6/2015 11:42:57 PM" creator "add property SpinnerAgent on program emxSpinnerAccess.tcl value '12/6/2015 11:42:57 PM'"
 0 2 "12/6/2015 11:42:57 PM" creator "mod program emxSpinnerAccess.tcl description ''"
 0 2 "2/3/2016 5:21:01 PM" creator "mod property SpinnerAgent on program emxSpinnerAccess.tcl value '2/3/2016 5:21:01 PM'"
 0 2 "2/3/2016 5:21:01 PM" creator "mod program emxSpinnerAccess.tcl file ./Business/SourceFiles/emxSpinnerAccess.tcl"
 0 2 "3/7/2016 10:03:58 AM" creator "mod property SpinnerAgent on program emxSpinnerAccess.tcl value '3/7/2016 10:03:58 AM'"
 0 2 "3/7/2016 10:03:58 AM" creator "mod program emxSpinnerAccess.tcl file ./Business/SourceFiles/emxSpinnerAccess.tcl"
 0 2 "3/27/2017 3:41:27 PM" creator "mod property SpinnerAgent on program emxSpinnerAccess.tcl value '3/27/2017 3:41:27 PM'"
 0 2 "3/27/2017 3:41:27 PM" creator "mod program emxSpinnerAccess.tcl file ./Business/SourceFiles/emxSpinnerAccess.tcl"

!MTRX!END

!MTRX!AD! program emxSpinnerAgent.tcl "3DEXPERIENCE R2015x(24.0.0.0)"
emxSpinnerAgent.tcl 0 "" "#########################################################################*10.90
#
# @progdoc      emxSpinnerAgent.tcl vMV6R2009-1.0
#
# @Description: Dynamic scripter for schema using tab-delimited text files.
#               Functionality includes add, modify, delete w/registrations.
#
# @Parameters:  Arg 1: Settings File (optional); Arg 2: Spinner Directory (optional)
#
# @Usage:       Run this program in an MQL command window w/data files in directories:
#
#               exec prog emxSpinnerAgent.tcl [Settings File] [Spinner Directory]
#
#               . (current dir)         Spinner directory
#               ./Business              Business data files
#               ./Business/Policy       Policy access data files
#               ./Business/Rule         Rule access data files
#               ./Business/SourceFiles  Database program files
#               ./Business/PageFiles    Database page files
#               ./Export/[SCHEMA TYPE]  Export files from Bus Doc Generator program
#               ./Objects               Business Object data files
#               ./Objects/Files         Business Object Files data files
#               ./Objects/Grants        Business Object Grants data files
#               ./Pix                   Icon files for thick client
#               ./Relationships         Relationship data files
#               ./System                System data files
#
# @progdoc      Copyright (c) MatrixOne Inc., June 26, 2002
#
#########################################################################
#
# @Modifications: See SchemaAgent_ReadMe.htm
#
#########################################################################
tcl;
mql verb off
eval {
   if {[info host] == \"mostermant43\" } {
      source \"c:/Program Files/TclPro1.3/win32-ix86/bin/prodebug.tcl\"
      set cmd \"debugger_eval\"
      set xxx [debugger_init]
   } else {
      set cmd \"eval\"
   }
}
$cmd {
# Read arguments
   set sSpinnerPath [mql get env 1]
   set sArg1 [string tolower $sSpinnerPath]
   set sSpinnerSetting [mql get env 2]
   set sArg2 [string tolower $sSpinnerSetting]
   set sArg3 [string tolower [mql get env 3]]
   set bScan FALSE
   set bReset FALSE
   if {$sArg3 == \"scan\"} {
      set bScan TRUE
   } elseif {$sArg3 == \"reset\" || $sArg3 == \"force\"} {
      set bReset TRUE
   } elseif {$sArg2 == \"scan\"} {
      set bScan TRUE
      set sSpinnerSetting \"\"
   } elseif {$sArg2 == \"reset\" || $sArg2 == \"force\"} {
      set bReset TRUE
      set sSpinnerSetting \"\"
   } elseif {$sArg1 == \"scan\"} {
      set bScan TRUE
      set sSpinnerPath \"\"
      set sSpinnerSetting \"\"
   } elseif {$sArg1 == \"reset\" || $sArg1 == \"force\"} {
      set bReset TRUE
      set sSpinnerPath \"\"
      set sSpinnerSetting \"\"
   }
   if {$bScan} {mql set env SPINNERSCANMODE TRUE}
   if {$sSpinnerPath == \"\"} {
      set sSpinnerPath \".\"
   } else {
      if {[catch {cd $sSpinnerPath} sMsg] != 0} {
      	 puts \"\\nERROR:  Path '$sSpinnerPath' does not exist or permission denied\"
      	 exit 1
      	 return
      }
   }
# Read settings
   if {$sSpinnerSetting == \"\"} {set sSpinnerSetting emxSpinnerSettings.tcl}
   if {[catch {
      if {[file exists \"$sSpinnerPath/$sSpinnerSetting\"] == 1} {
         set iFileSet [open \"$sSpinnerPath/$sSpinnerSetting\" r]
         eval [read $iFileSet]
         close $iFileSet
         set sSettingLoc \"file '$sSpinnerPath/$sSpinnerSetting'\"
      } elseif {[mql list program $sSpinnerSetting] != \"\"} {
         eval [mql print program $sSpinnerSetting select code dump]
         set sSettingLoc \"database program '$sSpinnerSetting'\"
      } else {
      	 puts \"ERROR:  Spinner Settings file missing.  Load 'emxSpinnerSettings.tcl' in database or place in Spinner path\"
      	 exit 1
      	 return
      }
   } sMsg] != 0} {
      puts \"\\nERROR: Problem with settings file '$sSpinnerSetting'\\n$sMsg\"
      exit 1
      return
   }
   set lsSetting [list sParentChild bUseAssignmentField bUseAccessField bRetainBusObject bImportOverwrite bBusObjOverwrite bBusRelOverwrite bTriggerAdd bTriggerMod bTriggerDel bTriggerChk sReplaceSymbolic sDelimiter sRangeDelim bShowModOnly bStreamLog bShowTransaction bOverlay bCompile lsSubDirSequence lsFileExtSkip rRefreshLog bAbbrCue iBusObjCommit bForeignVault bContinueOnError bChangeAttrType bPersonOverwrite bCDM bOut]
   set bSetErr FALSE
   foreach sSetting $lsSetting {
      if {[info exists \"$sSetting\"]} {
      } else {
         puts \"ERROR:  Setting '$sSetting' is not defined.  Add parameter to $sSettingLoc - pull from latest 'emxSpinnerSettings.tcl' program\"
         set bSetErr TRUE
      }
   }
   if {$bSetErr} {
      exit 1
      return
   }
   set bExecute TRUE
   if {[mql get env 0] == \"\"} {set bExecute FALSE}

# Procedure to pull extra quotes generated by Excel saves plus tagged dumper values
   proc pRegSubExcel {sExcel} {
      if {[string range $sExcel 0 0] == \"\\042\" && [string range $sExcel end end] == \"\\042\" && [string length $sExcel] > 2} {
      	 if {[string first \",\" $sExcel] > -1 || [string first \"\\042\\042\" $sExcel] > -1} {
      	    set iLast [expr [string length $sExcel] -2]
      	    set sExcel [string range $sExcel 1 $iLast]
      	    regsub -all \"\\042\\042\" $sExcel \"\\042\" sExcel
      	 }
      }
      regsub -all \"<ESC>\" $sExcel \"\\134\" sExcel
      return $sExcel
   }

# Procedure to pass tcl-type variables in tcl eval commands
   proc pRegSubEvalEscape {sEscape} {
      global sSchemaType
      if {$sSchemaType == \"attribute\"} {regsub -all \"\\134\\134\" $sEscape \"\\134\\134\\134\" sEscape}
      regsub -all \"\\134$\" $sEscape \"\\134\\134\\$\" sEscape
      regsub -all \"\\134\\173\" $sEscape \"\\134\\134\\173\" sEscape
      regsub -all \"\\134\\175\" $sEscape \"\\134\\134\\175\" sEscape
      regsub -all \"\\134\\133\" $sEscape \"\\134\\134\\133\" sEscape
      regsub -all \"\\134\\135\" $sEscape \"\\134\\134\\135\" sEscape
      regsub -all \"\\042\" $sEscape \"\\134\\042\" sEscape
      regsub -all \"'\" $sEscape \"\\047\" sEscape
      return $sEscape
   }

# Procedure to convert coded filenames to matrix names
   proc pRemSpecChar {filename} {
      set lChar [list {\\134 %5C} {/ %2F} {: %3A} {\\* %2A} {\\? %3F} {\\| %7C}]
      foreach i $lChar {
         set sLabel [lindex $i 1]
         set sValue [lindex $i 0]
         regsub -all -- \"$sLabel\" $filename \"$sValue\" filename
         regsub -all \"\\134\\134\" $filename \"\\134\\134\\134\" filename
      }
      return $filename
   }

# Procedure to skip blanks if bOverlay switch is set
   proc pOverlay {lsNumber} {
      global aCol aDat bAdd
      foreach sNumber $lsNumber {
        if {$aCol($sNumber) == \"<NULL>\"} {
           set aCol($sNumber) \"\"
        } elseif {$bAdd != \"TRUE\" && $aCol($sNumber) == \"\"} {
           set aCol($sNumber) $aDat($sNumber)
      	} elseif {$bAdd == \"TRUE\"} {
      	   set aDat($sNumber) \"\"
      	}
      }
   }

# Procedure to skip blanks if bOverlay switch is set
   proc pOverlayList {lsPlan lsActual} {
      global lsDel
      if {$lsPlan == \"<NULL>\"} {
         return \"\"
      } elseif {$lsPlan == \"\" || $lsPlan == $lsActual} {
    	   return $lsActual
      } else {
      	 set lsPlan [lindex [pMergeList $lsPlan \"\" $lsActual \"\" \"\"] 0]
         return $lsPlan
      }
   }

# Procedure to merge plan and actual lists for bOverlay switch
   proc pMergeList {lsPlan lsValue lsActual lsTrueValue sType} {
      global lsDel lsPlanTemp lsValueTemp
      pSetValue [list lsDel lsPlanTemp lsValueTemp] \"\"
      foreach sPlan $lsPlan sValue $lsValue {
         set iLenMinTwo [expr [string length $sPlan] -2]
         if {$sType == \"ATTR\" && [string first \"<>\" $sPlan] >= 0} {
            lappend lsDel \"[string range $sPlan 0 [string first \"^\" $sPlan]]\"
         } elseif {$sType == \"ATTR\" && [string first \"<<\" $sPlan] >= 0 && [string first \">>\" $sPlan] == $iLenMinTwo} {
            set iRange [string first \"<<\" $sPlan]
            set sPrePlan [string range $sPlan 0 [expr $iRange - 1]]
            set sPlan [string range $sPlan $iRange end]
            regsub \"<<\" $sPlan \"\" sPlan
            regsub \">>\" $sPlan \"\" sPlan
            set sPlan [string trim $sPlan]
            regsub -all \"<SPACE>\" $sPlan \" \" sPlan 
            set sPlan \"$sPrePlan$sPlan\"
            if {[lsearch $lsActual $sPlan] >= 0} {lappend lsDel $sPlan}
         } elseif {[string first \"<<\" $sPlan] == 0 && [string range $sPlan $iLenMinTwo end] == \">>\"} {
            set sPlan [string range $sPlan 2 [expr $iLenMinTwo - 1]]
            set sPlan [string trim $sPlan]
            regsub -all \"<SPACE>\" $sPlan \" \" sPlan 
            if {[lsearch $lsActual $sPlan] >= 0} {lappend lsDel $sPlan}
         } else {
            regsub -all \"<SPACE>\" $sPlan \" \" sPlan 
            lappend lsPlanTemp $sPlan
            regsub -all \"<SPACE>\" $sValue \" \" sValue 
            lappend lsValueTemp $sValue
         }
      }
      set lsPlan \"\"
      set lsValue \"\"
      set iCtrTemp 0
      foreach sActual $lsActual sTrueValue $lsTrueValue {
         if {$lsDel != \"\" && [lsearch $lsDel $sActual] >= 0} {
         } else {
            set iPlace [lsearch $lsPlanTemp $sActual] 
            if {$sType == \"STATE\" && $sTrueValue != \"\"} {
               set iPlaceSt [lsearch $lsValueTemp $sTrueValue]
               if {$iPlaceSt >= 0} {set iPlace $iPlaceSt}
            }
            if {$iPlace >= 0} {
               for {} {$iCtrTemp <= $iPlace} {incr iCtrTemp} {
                  lappend lsPlan [lindex $lsPlanTemp $iCtrTemp]
                  lappend lsValue [lindex $lsValueTemp $iCtrTemp]
               }
            } else {
               lappend lsPlan $sActual
               lappend lsValue $sTrueValue
            }
         } 
      }
      for {} {$iCtrTemp < [llength $lsPlanTemp]} {incr iCtrTemp} {
         lappend lsPlan [lindex $lsPlanTemp $iCtrTemp]
         lappend lsValue [lindex $lsValueTemp $iCtrTemp]
      }
      return [list $lsPlan $lsValue]
   }

# Procedure to check and set attribute values
   proc pCompareAttr {sAttrCurrent sAttrDefault sAttrAlternate bTrueFalse bCol} {
      global bOverlay bAdd
      if {$bCol && $bAdd != \"TRUE\" && $bOverlay && $sAttrCurrent == \"\"} {
         return \"\"
      } elseif {[string tolower $sAttrCurrent] != $sAttrAlternate && [string tolower $sAttrCurrent] != $bTrueFalse} {
         return $sAttrDefault
      } else {
         return $sAttrAlternate
      }
   }

# Procedure to query policy and rule access
   proc pQueryAccess {sSchemaType sSchemaName sSelect} {
      set lsAccessActual \"\"
      set lsAccessActualTemp [split [pQuery \"\" \"print $sSchemaType \\042$sSchemaName\\042 select $sSelect\"] \\n]
      foreach sAccessTemp $lsAccessActualTemp {
         set sAccessTemp [string trim $sAccessTemp]
         if {[string first \"access\\133\" $sAccessTemp] > -1} {
            regsub \"access\\134\\133\" $sAccessTemp \"|\" sAccessTemp
            set sAccessTemp [lindex [split $sAccessTemp |] 1]
            regsub \"\\134\\135\" $sAccessTemp \"\" sAccessTemp
            lappend lsAccessActual $sAccessTemp
         }
      }
      return $lsAccessActual
   }

# Procedure to add range values
   proc pPlanAdd {lsPlan sSchemaType sSchemaName sActionAdd sActionPost} {
      global sSystem aCmdMenuPlan
      set sAppend \"\"
      set iOrder 1
      foreach sPlan $lsPlan {
      	 if {$sSchemaType == \"menu\"} {set sActionAdd \"add $aCmdMenuPlan($sPlan)\"}
      	 if {$sSchemaType == \"form\" && $sActionAdd == \"field bus dummy name\"} {
      	    set sActionPost \"order $iOrder\"
      	    incr iOrder
      	 }
         append sAppend \" $sActionAdd \\042$sPlan\\042 $sActionPost\"
      }
      if {$sAppend != \"\"} {pMqlCmd \"mod $sSchemaType \\042$sSchemaName\\042 $sSystem$sAppend\"}
   }

# Procedure to add and remove list elements
   proc pPlanActualAddDel {lsActual lsActualForPlan lsPlan sSchemaType sMidCommand sSchemaName sActionDel sActionAdd sActionAppend} {
      global sSystem aCmdMenuPlan aCmdMenuActual
      if {$lsActualForPlan == \"\"} {set lsActualForPlan $lsActual}
      set sAppend \"\"
      foreach sPlan $lsPlan sActual $lsActual {
         if {$sActual != \"\" && [lsearch $lsPlan $sActual] < 0} {
            if {$sSchemaType == \"menu\"} {set sActionDel	\"remove $aCmdMenuActual($sActual)\"}
            append sAppend \" $sActionDel \\042$sActual\\042\"
         }
         if {$sPlan != \"\" && [lsearch $lsActualForPlan $sPlan] < 0} {
            if {$sSchemaType == \"menu\"} {set sActionAdd \"add $aCmdMenuPlan($sPlan)\"}
            append sAppend \" $sActionAdd \\042$sPlan\\042$sActionAppend\"
            if {$sSchemaType == \"type\" && $sActionAdd == \"add method\"} {pDeleteMethod $sSchemaName $sPlan}
         }
      }
      if {$sAppend != \"\"} {pMqlCmd \"mod $sSchemaType $sMidCommand \\042$sSchemaName\\042 $sSystem$sAppend\"}
   }

# Procedure to evaluate queries
   proc pQuery {sDefault sCmd} {
      if {[catch {set sQuery [eval \"mql $sCmd\"]} sMsg] != 0} {
         return $sDefault
      } else {
         return $sQuery
      }
   }

# Procedure to evaluate queries
   proc pPrintQuery {sDefault sSelect sPipe sSplStr} {
      global sSystem aSchemaElement sSchemaType aCol
      if {[catch {set sQuery [eval \"mql print $aSchemaElement($sSchemaType) \\042$aCol(0)\\042 $sSystem select \\042$sSelect\\042 dump $sPipe\"]} sMsg] != 0} {
         return $sDefault
      } else {
         if {$sSplStr == \"str\"} {
            set sQuery [string tolower $sQuery]
         } elseif {$sSplStr == \"spl\"} {
            set sQuery [split $sQuery $sPipe]
         }
         return $sQuery
      }
   }

# Procedure to set values
   proc pSetValue {lsList sValue} {
      foreach sList $lsList {
      	 set iTest [expr [string first \"(\" $sList] - 1]
      	 if {$iTest > 0} {
      	    eval \"global \\042[string range $sList 0 $iTest]\\042\"
      	 } else {
            eval \"global \\042$sList\\042\"
         }
         eval \"set \\042$sList\\042 \\042$sValue\\042\"
      }
   }

# Procedure to set action
   proc pSetAction {sActionValue} {
      global sAction bScan bAppend
      if {$bScan != \"TRUE\"} {
         set sAction $sActionValue
         set bAppend TRUE
      } else {
         set sAction \"\"
         set bAppend FALSE
      }
   }

# Procedure to trim list ranges
   proc pTrimList {sList} {
      global sRangeDelim bOverlay
      set lsList [split $sList $sRangeDelim]
      set lsListPlan [list ]
      foreach sList $lsList {
         set sList [string trim $sList]
         if {!$bOverlay} {regsub -all \"<SPACE>\" $sList \" \" sList}
         lappend lsListPlan $sList
      }
      return $lsListPlan
   }

# Procedure check for name changes on upstream changes
   proc pCheckNameChange {lsList sSchemaElement} {
      global sSchemaType aCol aSchChgName aRepeatChange
      foreach sList $lsList {
         if {[catch {set sTest $aSchChgName(\"$sSchemaElement|$sList\")} sMsg] == 0} {
      	    if {[catch {set sTest1 $aRepeatChange(\"$sSchemaElement|$sList\")} sMsg] != 0} {
               set aRepeatChange(\"$sSchemaElement|$sList\") TRUE
               pWriteWarningMsg \"\\nWARNING: '$sSchemaType' '$aCol(0)' references '$sSchemaElement' '$sList' with new name '$sTest'.\\nChange this reference in the '$sSchemaType' data file to avoid errors on subsequent runs.\"
            }
            set iIndex [lsearch $lsList $sList ]
            set lsList [lreplace $lsList $iIndex $iIndex $sTest]
         }
      }
      return $lsList
   }

# Procedure to check for multiple entries and duplicate registrations
proc pDuplicate {lsFile} {
   global sSchemaType
   set lsErrorMsg [list ]
   set lsCol1 [list ]
   set lsCol2 [list ]
   foreach sLine $lsFile {
     if {$sLine != \"\" && [string range $sLine 0 7] != \"<HEADER>\"} {
         set lsLine [split $sLine \\t]
         for {set i 1} {$i < 7} {incr i} {set sCol($i) [string trim [lindex $lsLine [expr $i - 1]]]}
         switch $sSchemaType {
            signature {
               set sCol123 \"$sCol(1)|$sCol(2)|$sCol(3)\"
               if {[lsearch $lsCol1 $sCol123] > -1} {
                  lappend lsErrorMsg \"ERROR: Schema element \\042$sSchemaType\\042 name \\042$sCol(1)\\042 state \\042$sCol(2)\\042 signature \\042$sCol(3)\\042 is duplicated\"
               } else {
                  lappend lsCol1 $sCol123
               }
            } state - column - unit {
               set sCol12 \"$sCol(1)|$sCol(2)\"
               if {[lsearch $lsCol1 $sCol12] > -1} {
                  set sName2 $sSchemaType
                  lappend lsErrorMsg \"ERROR: Schema element \\042$sSchemaType\\042 name \\042$sCol(1)\\042 $sName2 \\042$sCol(2)\\042 is duplicated\"
               } else {
                  lappend lsCol1 $sCol12
               }
            } trigger {
               set sCol12345 \"$sCol(1)|$sCol(2)|$sCol(3)|$sCol(4)|$sCol(5)\"
               if {[lsearch $lsCol1 $sCol12345] > -1} {
                  if {$sCol(1) == \"policy\"} {
                     lappend lsErrorMsg \"ERROR: \\042$sSchemaType\\042 for schema type \\042$sCol(1)\\042 name \\042$sCol(2)\\042 state \\042$sCol(3)\\042 trigger type \\042$sCol(4)$sCol(5)\\042 is duplicated\"
                  } else {
                     lappend lsErrorMsg \"ERROR: \\042$sSchemaType\\042 for schema type \\042$sCol(1)\\042 name \\042$sCol(2)\\042 trigger type \\042$sCol(4)$sCol(5)\\042 is duplicated\"
                  }
               } else {
                  lappend lsCol1 $sCol12345
               }
            } property {
               set sCol12356 \"$sCol(1)|$sCol(2)|$sCol(3)|$sCol(5)|$sCol(6)\"
               if {[lsearch $lsCol1 $sCol12356] > -1} {
                  lappend lsErrorMsg \"ERROR: Property name \\042$sCol(3)\\ on schema element \\042$sCol(1)\\042 name \\042$sCol(2)\\042 is duplicated\"
               } else {
                  lappend lsCol1 $sCol12356
               }
            } default {
               if {$sSchemaType != \"field\"} {
                  if {[lsearch $lsCol1 $sCol(1)] > -1} {
                     lappend lsErrorMsg \"ERROR: Schema element \\042$sSchemaType\\042 name \\042$sCol(1)\\042 is duplicated\"
                  } elseif {$sCol(2) != \"\" && $sCol(2) != \"<NULL>\" && [lsearch $lsCol2 $sCol(2)] > -1} {
                     lappend lsErrorMsg \"ERROR: Schema element \\042$sSchemaType $sCol(1)\\042 registry name \\042$sCol(2)\\042 is duplicated\"
                  } else {
                     lappend lsCol1 $sCol(1)
                     if {$sCol(2) != \"\" && $sCol(2) != \"<NULL>\"} {
                        lappend lsCol2 $sCol(2)
                     }
                  }
               }
            }
         }
      }
   }
   return $lsErrorMsg
}

# Procedure to return timestamps from file pattern
   proc pTimeStamp {sPattern} {
      global lsFileExtSkip
      set lsMatch [glob -nocomplain $sPattern]
      set lsStamp \"\"
      foreach sMatch $lsMatch {
         if {[lsearch $lsFileExtSkip [file ext $sMatch]] < 0} {lappend lsStamp \"[file tail $sMatch]:[file mtime $sMatch]\"}
      }
      set sStamp [join [lsort $lsStamp] >]
      if {$sStamp == \"\"} {set sStamp 0}
      return $sStamp
   }
   
# Procedure to process mql commands
   proc pMqlCmd {sCmd} {
      global bUpdate bScan
      pAppend \"mql $sCmd\" FALSE
      if {$bScan != \"TRUE\"} {eval \"mql $sCmd\"}
      set bUpdate TRUE
   }

# Procedure to write to log file
   proc pAppend {sString bNoChg} {
      global sFile sAction bAppend bModFlag bStreamLog
      if {$bNoChg} {
         if {$bStreamLog == \"TRUE\"} {puts \"# $sAction$sString\\n\"}
         append sFile \"# $sAction$sString\\n\"
         set bModFlag FALSE
      } elseif {$bAppend} {
         if {$bModFlag != \"TRUE\"} {append sFile \"\\n\"}
         if {$bStreamLog == \"TRUE\"} {puts \"# $sAction\\n$sString\\n\"}
         append sFile \"# $sAction\\n$sString\\n\"
         set bAppend FALSE
      } else {
         if {$bStreamLog == \"TRUE\"} {puts \"$sString\\n\"}
         append sFile \"$sString\\n\"
      }
   }

# Procedure for writing Spinner log file
   proc pSpinDone {sSchemaType} {
      global sSpinDone lsSchemaTypeTitle aTimeStamp aTimeStampFile bScan sInstanceProperty bOverlay
      array set aTimeStamp [list $sSchemaType $aTimeStampFile($sSchemaType)]
      set fSpinDone [open $sSpinDone w]
      foreach sSchemaTypeTest $lsSchemaTypeTitle {
         set sSchemaTypeTest [string tolower $sSchemaTypeTest]
         puts $fSpinDone \"$sSchemaTypeTest|$aTimeStamp($sSchemaTypeTest)\"
         if {$sSchemaTypeTest == \"program\"} {
            array set aTimeStamp [list sourcefile $aTimeStampFile(sourcefile)]
            puts $fSpinDone \"sourcefile|$aTimeStamp(sourcefile)\"
         } elseif {$sSchemaTypeTest == \"page\"} {
            array set aTimeStamp [list pagefile $aTimeStampFile(pagefile)]
            puts $fSpinDone \"pagefile|$aTimeStamp(pagefile)\"
         }
      }
      puts $fSpinDone \"overlay|$bOverlay\"
      close $fSpinDone
      if {[mql print person creator select property\\133$sInstanceProperty\\135.name dump] == \"\" && $bScan != \"TRUE\"} {
         catch {mql add property $sInstanceProperty value [file mtime $sSpinDone] on person creator} sMsg
      } elseif {$bScan != \"TRUE\"} {
         catch {mql mod property $sInstanceProperty value [file mtime $sSpinDone] on person creator} sMsg
      }
   }

# Procedure to write screen cue
   proc pWriteCue {} {
      global iAddCtr iModCtr iDelCtr iErrCtr iTenPercent iPrevAddModDel iPrevError bAbbrCue
      set iAddModDel [expr $iAddCtr + $iModCtr + $iDelCtr - $iPrevAddModDel]
      set iError [expr $iErrCtr - $iPrevError]
      set iPrevAddModDel [expr $iAddCtr + $iModCtr + $iDelCtr]
      set iPrevError $iErrCtr
      set sWrite \"...\"
      if {$iAddModDel && $iError && $bAbbrCue != \"TRUE\"} {
         set sWrite \"  \\050$iAddModDel\\: $iError\\!\\051\"
      } elseif {$iAddModDel && $bAbbrCue != \"TRUE\"} {
         set sWrite \"  \\050$iAddModDel\\:\\051\"
      } elseif {$iError} {
         set sWrite \"  \\050$iError\\!\\051\"
      }
      puts -nonewline \"$sWrite[expr $iTenPercent * 10]%\"
   }

# Procedure to write error to screen and log
   proc pWriteErrorMsg {sMessage} {
      global sLogFileError
      puts $sMessage
      set iLogFileErr [open $sLogFileError a+]
      puts $iLogFileErr $sMessage
      close $iLogFileErr
   }  
      
# Procedure to write warning to screen and log
   proc pWriteWarningMsg {sMessage} {
      global sWarning sFile bOut
      if {$bOut} {puts $sMessage}
      append sWarning \"$sMessage\\n\"
      append sFile \"$sMessage\\n\"
   }  
      
# Main
   if {$bExecute} {
      set sFirstLine [lindex [split [mql print program emxSpinnerAgent.tcl select code dump] \\n] 0]
   } elseif {[catch {
      set iSpinFile [open emxSpinnerAgent.tcl r]
      set sFirstLine [gets $iSpinFile]
      close $iSpinFile
   } sMsg] != 0} {
      puts \"\\nERROR: Program execution halted - Change working directory to location of 'emxSpinnerAgent.tcl'\"
      exit 1
      return
   }
   set iEnd [expr [string last \"*\" $sFirstLine] + 1]
   set sSpinBuild [string range $sFirstLine $iEnd end]
   puts \"\\nStarting emxSpinnerAgent v$sSpinBuild...\"
   puts \"   settings loaded from $sSettingLoc\"
   set sRegTest1 [mql list program emxRegUnRegSchema.tcl]
   if {$sRegTest1 == \"\"}  {
      puts \"ERROR: Program execution halted - This database is not registered for Spinner\"
      exit 1
      return
   }
   set sFirstLine [lindex [split [mql print program emxRegUnRegSchema.tcl select code dump] \\n] 0]
   set iEnd [expr [string last \"*\" $sFirstLine] + 1]
   set rVersion [string range $sFirstLine $iEnd end]
   set rRegVersion 10.58
   if {$rVersion < $rRegVersion} {
      puts \"ERROR: Registration program 'emxRegUnRegSchema.tcl' in this database needs to be upgraded to version >= $rRegVersion\"
      exit 1
      return
   }
   eval  [mql print program emxRegUnRegSchema.tcl select code dump]
# Scan Mode
   if {$bScan != \"TRUE\"} {set bScan [mql get env SPINNERSCANMODE]}
   if {$bScan != \"TRUE\"} {set bScan FALSE}
   if {$bScan} {puts \"***SCAN MODE ACTIVATED***\"}
   if {$bOverlay} {puts \"** Overlay mode activated **\"}
# Set static variables
   set rTcl [info tcl]
   pSetValue [list bFirstRun bLogMsg] TRUE 
   set bMultiDir FALSE
   if {[llength $lsSubDirSequence] > 1} {set bMultiDir TRUE}
   set sMxVersion \"10.9\"
   if {[string first \"V6\" $sMxVersion] >= 0} {
      set sAppend [lindex [split $sMxVersion \"R\"] 1]
      set sAppend [join [lrange [split $sAppend -] 0 1] \"\"]
      set sAppend [join [lrange [split $sAppend .] 0 1] \"\"]
      # Fix spinner bug for V6 version error (do not import Web Form, Field), added by mike, Nov. 12 2008
      #set sMxVersion \"10.9$sAppend\"
      set sMxVersion \"10.9\"
      # Ended by mike.
   } else {
      set sMxVersion [join [lrange [split $sMxVersion .] 0 1] .]
   }
   set lsBusiness [list Program Group Role Association Attribute Type Relationship Interface \"Format\" Policy State Signature Command \"Menu\" Inquiry Table Column WebForm Field Portal Channel Rule Trigger Page Property Rule Expression Dimension Unit]
   set lsNonBusiness [list system policyaccess ruleaccess busobj busgrant busfile busrel person]
   set lsImport [list wizard index report form process resource prog]
   set lsSchemaTypeTitle [list System Program Prog Wizard Role Group Person Association]
   if {$sMxVersion >= 10.7} {set lsSchemaTypeTitle [concat $lsSchemaTypeTitle [list Dimension Unit]]}
   set lsSchemaTypeTitle [concat $lsSchemaTypeTitle [list Attribute Index Type Relationship \"Format\" Policy State Signature PolicyAccess Command Menu Inquiry Table Column]]
   if {$sMxVersion >= 10.5} {set lsSchemaTypeTitle [concat $lsSchemaTypeTitle [list WebForm Field]]}
   if {$sMxVersion >= 10.5} {set lsSchemaTypeTitle [concat $lsSchemaTypeTitle [list Channel Portal]]}
   if {$sMxVersion >= 10.6} {set lsSchemaTypeTitle [concat $lsSchemaTypeTitle [list Interface Expression]]}
   set lsSchemaTypeTitle [concat $lsSchemaTypeTitle [list Report Form Process Page Resource Rule RuleAccess Trigger Property BusObj BusGrant BusFile BusRel]]
   set lsRangeValue [list \">=\" \"<=\" \"!=\" \"=\" \"<\" \">\" \"!smatch\" \"!match\" smatch match between uses]
   array set aHiddenIndex [list program 9 group 7 role 7 association 4 attribute 7 type 7 relationship 5 interface 7 expression 4 format 11 policy 5 state \"\" signature \"\" command 9 menu 10 inquiry 8 table 4 column \"\" webform 4 field \"\" channel 10 portal 9 rule 8 trigger \"\" property \"\" policyaccess \"\" ruleaccess \"\" wizard \"\" prog \"\" person \"\" report \"\" form \"\" process \"\" page 4 resource \"\" busobj \"\" busgrant \"\" busfile \"\" busrel \"\" system \"\" index \"\" dimension 4 \"unit\" \"\"]
   array set aIconIndex [list program 11 group 8 role 8 association 5 attribute 9 type 9 relationship 21 interface 9 expression 5 format 12 policy 13 state 12 signature 8 command 11 menu 11 inquiry 9 table 5 column 14 webform 6 field 14 channel 11 portal 10 rule 9 trigger 7 property 6 policyaccess \"\" ruleaccess \"\" wizard \"\" prog \"\" person \"\" report \"\" form \"\" process \"\" page 5 resource \"\" busobj \"\" busgrant \"\" busfile \"\" busrel \"\" system \"\" index \"\" dimension 5 \"unit\" 11]
   array set aDescIndex [list program 2 group 2 role 2 association 2 attribute 3 type 4 relationship 2 interface 4 expression 2 format 2 policy 2 state 2 signature 2 command 2 menu 2 inquiry 2 table 2 webform 2 channel 2 portal 2 rule 2 page 2 dimension 2]
   array set aSchemaElement [list system system program program group group role role association association attribute attribute type type relationship relationship interface interface expression expression format format policy policy state policy signature policy command command menu menu inquiry inquiry table table column table webform form field form portal portal channel channel rule rule trigger \"\" property \"\" policyaccess policy ruleaccess rule wizard program prog program person person report report form form process process page pageobject resource resource busobj bus busgrant bus busfile bus busrel rel index index dimension dimension \"unit\" dimension]
   array set aMultiColumn [list group [list 4 5] role [list 4 5] association [list ] attribute [list 5 8] type 5 relationship [list 3 7 8 13 14] interface [list 2 5 6] expression [list ] format [list ] policy [list 6] state [list 6] signature [list ] command [list 6 7 8] menu [list 6 7 8] inquiry [list 7] table [list 3] column [list 7 8 9] webform [list 3 5] field [list 7 8 9] channel [list 6 7 8] portal [list 6 7 8] rule [list ] trigger [list ] dimension [list 3] property [list ] page [list ] resource [list ] process [list ]]
   array set aDelimiter [list tab \"\\011\" pipe \"|\" comma \",\" carot \"^\" tilde \"~\" newline \"\\012\"]
   array set aRangeDelim [list tab \"\\011\" pipe \"|\" comma \",\" carot \"^\" tilde \"~\" space \" \"]
   if {$sDelimiter == $sRangeDelim} {
      puts \"Program halted: Delimiter '$sDelimiter' cannot be the same as the range delimiter!\\nReset this parameter in the settings file\"
      exit 1
      return
   }
   set sRangeDelim $aRangeDelim($sRangeDelim)
   set sSpinnerUser [mql print context]
   regsub \" person \" $sSpinnerUser \"|\" slsSpinnerUser
   set sSpinnerUser [lindex [split $slsSpinnerUser |] 1]
   if {[pQuery \"none\" \"print person \\042$sSpinnerUser\\042 select admin dump\"] != \"all\"} {
      puts \"Program halted: Full administrative access is required to run this program\"
      exit 1
      return
   }
# Cycle thru multiple directories
   foreach sSubDir $lsSubDirSequence {
      if {$sSubDir == \"\"} {
         set sSpinDir $sSpinnerPath
      } else {
         set sSpinDir \"$sSpinnerPath/$sSubDir\"
      }
      # Added this Variable to fix Incident 315943
	    set sSpinnerEnv [mql set env SPINNERPATH $sSpinDir ]
      if {[llength $lsSubDirSequence] == 1 && $sSpinDir == \".\"} {
      } else {
         puts \"\\nProcessing directory: $sSpinDir\"
      }
      set sLogFileDir \"$sSpinDir/logs\"
      array set aTSPath [list policyaccess \"$sSpinDir/Business/Policy\" busobj \"$sSpinDir/Objects\" busgrant \"$sSpinDir/Objects/Grants\" busfile \"$sSpinDir/Objects/Files\" busrel \"$sSpinDir/Relationships\"]
      set sSuffix [clock format [clock seconds] -format \".%Y%m%dt%H%M\"]
      set sProgStart [clock format [clock seconds] -format \"%H:%M:%S\"]
      if {$bScan} {set sSuffix \".SCAN\"}
      pSetValue [list bAppend bModFlag bSkipElement bEscQuote] FALSE
      pSetValue [list resultappend lsSchemaTest sWarning sInstance sInstanceProperty sLogFileMsg] \"\"
# Set up or read main spinner log file
      set lsPrint \"\" 
	  #[split [pQuery \"\" \"print config\"] \\n]
      foreach sPrint $lsPrint {
         if {[string first \"BOOTFILE=\" $sPrint] > -1} {
            set sFirst [expr [string first \"=\" $sPrint] + 1]
            set sBootFile [string range $sPrint $sFirst end]
            regsub -all \"\\134\\134\" $sBootFile \"/\" sBootFile
            if {[catch {set iBoot [open $sBootFile r]} sMsg] == 0} {
               set sInstance [string range [gets $iBoot] 9 end]
               set sInstanceProperty $sInstance
               if {$sSubDir != \"\" && $sInstance != \"\"} {set sInstanceProperty \"$sSubDir\\_$sInstance\"}
               break
            }
         }
      }
      if {$sInstance != \"\"} {set sLogFileDir \"$sLogFileDir/$sInstance\"}
      if {[file exists $sLogFileDir] == 0} {
         if {[catch {file mkdir $sLogFileDir} sMsg] != 0} {
            puts \"Program halted: Error creating log directory\\n$sMsg\"
            exit 1
            return
         }
      }
      set sLogFilePath \"$sLogFileDir/Spinner$sSuffix.log\"
      mql set env SPINNERLOGFILE $sLogFilePath
      if {$bScan && [file exists $sLogFilePath]} {file delete $sLogFilePath}
      set sLogFileError \"$sLogFileDir/SpinnerError.log\"
      set iLogFileErr [open $sLogFileError w]
      close $iLogFileErr
      mql set env SPINNERERRORLOG $sLogFileError
      set sSpinDone \"$sLogFileDir/SpinDone.log\"
      if {$bScan != \"TRUE\"} {
         if {[file exists $sSpinDone] == 1} {
            if {$sSpinDir == $sSpinnerPath && [expr [clock seconds] - [file mtime $sSpinDone]] > [expr $rRefreshLog * 86400]} { 
               file delete -force $sSpinDone
            } elseif {$bReset} {
               file delete -force $sSpinDone
            }
         }
         if {[file exists $sSpinDone] == 0} {
            set fSpinDone [open $sSpinDone w]
            foreach sSchemaTypeTitle $lsSchemaTypeTitle {puts $fSpinDone \"[string tolower $sSchemaTypeTitle]|0\"}
            puts $fSpinDone \"sourcefile|0\"
            puts $fSpinDone \"pagefile|0\"
            close $fSpinDone
         }
         set fSpinDone [open $sSpinDone r]
         while {[eof $fSpinDone] == 0} {
            set sInput [gets $fSpinDone]
            if {$sInput != \"\"} {
               set lsInput [split $sInput |]
               array set aTimeStamp [list [lindex $lsInput 0] [lindex $lsInput 1]]
            }
         }
         close $fSpinDone
         if {[catch {set aTimeStamp(overlay) $aTimeStamp(overlay)} sMsg] == 0} {
            if {$aTimeStamp(overlay) == \"TRUE\" && $bOverlay != \"TRUE\"} {
               puts \"Program halted:  Last run was performed with the 'overlay' option activated.\\nEither reset option or delete file '$sLogFileDir/SpinDone.log' to process in classic mode\"
               exit 1
               return
            }
         }
      }
# Set up data files array
      set lsSchemaType \"\"
      set bFoundSchema FALSE
      foreach sSchemaTypeTitle $lsSchemaTypeTitle {
         set sSchemaType [string tolower $sSchemaTypeTitle]
         set lsTSFile($sSchemaType) \"\"
         array set aSchemaTitle [list $sSchemaType $sSchemaTypeTitle]
         if {$sSchemaType == \"system\"} {
            array set aTimeStampFile [list system [pTimeStamp \"$sSpinDir/System/*.*\"]]
         } elseif {$sSchemaType == \"policyaccess\"} {
            array set aTimeStampFile [list policyaccess [pTimeStamp \"$sSpinDir/Business/Policy/*.*\"]]
         } elseif {$sSchemaType == \"ruleaccess\"} {
            array set aTimeStampFile [list ruleaccess [pTimeStamp \"$sSpinDir/Business/Rule/*.*\"]]
         } elseif {$sSchemaType == \"busobj\"} {
            array set aTimeStampFile [list busobj [pTimeStamp \"$sSpinDir/Objects/*.xls\"]]
         } elseif {$sSchemaType == \"busgrant\"} {
            array set aTimeStampFile [list busgrant [pTimeStamp \"$sSpinDir/Objects/Grants/*.xls\"]]
         } elseif {$sSchemaType == \"busfile\"} {
            array set aTimeStampFile [list busfile [pTimeStamp \"$sSpinDir/Objects/Files/*.xls\"]]
         } elseif {$sSchemaType == \"busrel\"} {
            array set aTimeStampFile [list busrel [pTimeStamp \"$sSpinDir/Relationships/*.xls\"]]
         } elseif {[lsearch $lsImport $sSchemaType] > -1} {
            array set aTimeStampFile [list $sSchemaType [pTimeStamp \"$sSpinDir/Export/$sSchemaType/*.exp\"]]
         } elseif {$sSchemaType == \"program\"} {
            array set aTimeStampFile [list program [pTimeStamp \"$sSpinDir/Business/*ProgramData*.*\"]]
            array set aTimeStampFile [list sourcefile [pTimeStamp \"$sSpinDir/Business/SourceFiles/*\"]]
         } elseif {$sSchemaType == \"page\"} {
            array set aTimeStampFile [list page [pTimeStamp \"$sSpinDir/Business/*PageData*.*\"]]
            array set aTimeStampFile [list pagefile [pTimeStamp \"$sSpinDir/Business/PageFiles/*\"]]
         } else {
            array set aTimeStampFile [list $sSchemaType [pTimeStamp \"$sSpinDir/Business/*$sSchemaTypeTitle\\Data*.*\"]]
         }
         if {[catch {
            if {$bScan || $aTimeStamp($sSchemaType) != $aTimeStampFile($sSchemaType)} {
               lappend lsSchemaType $sSchemaType
               set bFoundSchema TRUE
               switch $sSchemaType {
                  role - group {
                     if {[lsearch $lsSchemaTest policy] < 0} {lappend lsSchemaTest person}
                  } attribute {
                     set lsSchemaTest [concat $lsSchemaTest [list type relationship]]
                     if {$sMxVersion >= 10.6} {lappend lsSchemaTest interface}
                  } type {
                     if {[lsearch $lsSchemaTest relationship] < 0} {lappend lsSchemaTest relationship}
                     lappend lsSchemaTest policy
                     if {$sMxVersion >= 10.6 && [lsearch $lsSchemaTest interface] < 0} {lappend lsSchemaTest interface}
                  } format {
                     if {[lsearch $lsSchemaTest policy] < 0} {lappend lsSchemaTest policy}
                  } policy {
                     lappend lsSchemaTest state
                     lappend lsSchemaTest signature
                     lappend lsSchemaTest policyaccess
                  } state {
                     if {[lsearch $lsSchemaTest signature] < 0} {lappend lsSchemaTest signature}
                     if {[lsearch $lsSchemaTest policyaccess] < 0} {lappend lsSchemaTest policyaccess}
                  } command {
                     lappend lsSchemaTest menu
                  } table {
                     lappend lsSchemaTest column
                  } webform {
                     lappend lsSchemaTest field
                  } dimension {
                     lappend lsSchemaTest unit
                  } channel {
                     lappend lsSchemaTest portal
                  } policyaccess - busobj - busgrant - busfile - busrel {
                     if {$bScan != \"TRUE\"} {
                        set lsTS [split $aTimeStamp($sSchemaType) >]
                        foreach slsTS $lsTS {
                           set lslsTS [split $slsTS :]
                           array set aTS [list [lindex $lslsTS 0] [lindex $lslsTS 1]]
                        }
                        set lsTSTest \"\"
                        set lsTSF [split $aTimeStampFile($sSchemaType) >]
                        foreach slsTSF $lsTSF {
                           set lslsTSF [split $slsTSF :]
                           array set aTSFile [list [lindex $lslsTSF 0] [lindex $lslsTSF 1]]
                           lappend lsTSTest [lindex $lslsTSF 0]
                        }
                        foreach sTSTest $lsTSTest {
                           if {[catch {
                              if {$aTSFile($sTSTest) != $aTS($sTSTest)} {lappend lsTSFile($sSchemaType) \"$aTSPath($sSchemaType)/$sTSTest\"}
                           } sMsg] != 0} {
                              lappend lsTSFile($sSchemaType) \"$aTSPath($sSchemaType)/$sTSTest\"
                           }
                        }
                     } 
                  }
               } 
            } elseif {$sSchemaType == \"program\" && $aTimeStamp(sourcefile) != $aTimeStampFile(sourcefile)} {
               lappend lsSchemaType program
               set bFoundSchema TRUE
            } elseif {$sSchemaType == \"page\" && $aTimeStamp(pagefile) != $aTimeStampFile(pagefile)} {
               lappend lsSchemaType page
               set bFoundSchema TRUE
            } elseif {[lsearch $lsSchemaTest $sSchemaType] >= 0 && $aTimeStampFile($sSchemaType) > 0} {
               lappend lsSchemaType $sSchemaType
            }
         } sMsg] != 0} {
            file delete -force $sSpinDone
            pWriteErrorMsg \"ERROR: Log file '$sSpinDone' was incompatible with this Spinner version and now deleted. Please restart this program.\"
            exit 1
            return
         }
      }
      if {$lsSchemaType != \"\"} {
# Set up arrays for symbolic name mapping
            set bAEF FALSE
            if {[mql list program \"eServiceSchemaVariableMapping.tcl\"] != \"\"} {
               puts \"Building name to symbolic name mapping arrays...\"
               if {$bFirstRun} {
                  set lsPrimitive [list ]
                  set lsPropertyName [split [mql print program eServiceSchemaVariableMapping.tcl select property.name dump |] |]
                  set lsPropertyTo [split [mql print program eServiceSchemaVariableMapping.tcl select property.to dump |] |]
               }
               foreach sPropertyName $lsPropertyName sPropertyTo $lsPropertyTo {
                  set sSchemaTest [lindex [split $sPropertyName \"_\"] 0]
                  if {$sSchemaTest == \"form\"} {set sSchemaTest \"webform\"}
                  if {[lsearch $lsPrimitive $sSchemaTest] >= 0} {continue}
                  if {[lsearch $lsSchemaType $sSchemaTest] > -1 || [lsearch $lsSchemaType \"property\"] > -1} {
                     if {[catch {set bTest $aSchemaTest($sSchemaTest)} sMsg] != 0} {
                        if {[catch {set bTest $aSchemaElement($sSchemaTest)} sMsg] == 0} {
                           set aSchemaTest($sSchemaTest) TRUE
                           puts -nonewline \"$sSchemaTest \"
                        }
                     }
                     if {$sSchemaTest == \"webform\"} {set sSchemaTest \"form\"}
                     set sTypeReplace \"$sSchemaTest \"
                     if {$sSchemaTest == \"attribute\"} {set sTypeReplace \"att \"}
                     regsub $sTypeReplace $sPropertyTo \"\" sPropertyTo
                     array set aSymbolic [list \"$sSchemaTest|$sPropertyTo\" $sPropertyName]
                     if {[catch {set sPropertyToTest $aSchemaName($sPropertyName)} sMsg] == 0} {
                        pWriteWarningMsg \"\\nWARNING: Symbolic name \\042$sPropertyName\\042 is being used for [join [split $sPropertyTo ,] \" and \"] in the schema\"
                     }
                     array set aSchemaName [list $sPropertyName $sPropertyTo]
                  }
               }
               set lsPrimitive [concat $lsPrimitive $lsSchemaType]
               puts \"\"
               set bAEF TRUE
            }
            set bFirstRun FALSE
# Process Data Files
         set bProcess TRUE
         while {$bProcess} {
            set bProcess FALSE
            foreach sSchemaType $lsSchemaType {
               set sFile \"\"
               pSetValue [list iErrCtr iAddCtr iModCtr iDelCtr iSkipCtr iRegisterCounter iPrevError iPrevAddModDel iMultiCtr iAddCtrTot iModCtrTot iDelCtrTot iSkipCtrTot] 0
               set iTenPercent 1
# System, Access, Bus Object, Bus File, and Bus Rel Spinners
               if {[lsearch $lsNonBusiness $sSchemaType] >= 0} {
                  switch $sSchemaType {
                     system {
                        set sSpinnerProg \"emxSpinnerSystem.tcl\"
                        set rProgVersion \"10.58\"
                        set sVarError SYSTEMERROR
                     } busobj {
                        set sSpinnerProg \"emxSpinnerBusObjects.tcl\"
                        set rProgVersion \"10.58\"
                        mql set env BUSOBJMODIFEXISTS $bBusObjOverwrite
                        mql set env BUSFILELIST $lsTSFile($sSchemaType)
                        mql set env TRIGGERCREATE $bTriggerAdd
                        mql set env TRIGGERMODIFY $bTriggerMod
                        mql set env TRIGGERDELETE $bTriggerDel
                        set sVarError BUSOBJERROR
                     } busgrant {
                        set sSpinnerProg \"emxSpinnerBusGrants.tcl\"
                        set rProgVersion \"10.59\"
                        mql set env BUSGRANTLIST $lsTSFile($sSchemaType)
                        set sVarError BUSGRANTERROR
                     } busfile {
                        set sSpinnerProg \"emxSpinnerBusFiles.tcl\"
                        set rProgVersion \"10.58\"
                        mql set env FILELIST $lsTSFile($sSchemaType)
                        mql set env CHECKINLIST $lsTSFile($sSchemaType)
                        mql set env TRIGGERCHECKIN $bTriggerChk
                        mql set env CDMAWARE $bCDM
                        set sVarError BUSFILERROR
                     } busrel {
                        set sSpinnerProg \"emxSpinnerBusRels.tcl\"
                        set rProgVersion \"10.58\"
                        mql set env BUSRELMODIFEXISTS $bBusRelOverwrite
                        mql set env RELFILELIST $lsTSFile($sSchemaType)
                        mql set env TRIGGERCREATE $bTriggerAdd
                        mql set env TRIGGERMODIFY $bTriggerMod
                        mql set env TRIGGERDELETE $bTriggerDel
                        set sVarError BUSRELERROR
                     } person {
                        set sSpinnerProg \"emxSpinnerPerson.tcl\"
                        set rProgVersion \"10.58\"
                        set sVarError PERSONERROR
                        mql set env OVERLAY $bOverlay
                        mql set env PERSONMODIFEXISTS $bPersonOverwrite
                     } default {
                        set sSpinnerProg \"emxSpinnerAccess.tcl\"
                        set rProgVersion \"10.56\"
                        mql set env SHOWMODONLY bShowModOnly
                        mql set env FILELIST $lsTSFile($sSchemaType)
                        set sVarError ACCESSERROR
                     }
                  }
                  if {($bExecute && [mql list program $sSpinnerProg] != \"\") || ($bExecute != \"TRUE\" && [file exists $sSpinnerProg])} {
                     puts -nonewline \"\\nProcessing $aSchemaTitle($sSchemaType) data...\"
                     if {$bExecute} {
                        set sFirstLine [lindex [split [mql print program $sSpinnerProg select code dump] \\n] 0]
                     } else {
                     	set iSpinProg [open \"$sSpinnerProg\" r]
                     	set sFirstLine [gets $iSpinProg]
                     	close $iSpinProg
                     }
                     set iEnd [expr [string last \"*\" $sFirstLine] + 1]
                     set rVersion [string range $sFirstLine $iEnd end]
                     if {$rVersion < $rProgVersion} {
                        pWriteErrorMsg \"\\nERROR: Program execution halted.  Program '$sSpinnerProg' needs to be upgraded to version >= $rProgVersion\"
                        exit 1
                        return
                     }
                     mql set env ACCESSTYPE $sSchemaType
                     if {$bExecute} {
                     	mql exec prog \"$sSpinnerProg\"
                     } else {
                     	mql run \"$sSpinnerProg\"
                     }
                     set iAccessError [eval mql get env $sVarError]
                     if {$iAccessError > 0} {
                        puts \"$iAccessError error(s) generated - Review log file '$sLogFileError', correct problem(s) and restart\"
                        if {$bContinueOnError != \"TRUE\"} {
                           exit 1
                           return
                        }
                     } elseif {$bScan != \"TRUE\"} {
                        pSpinDone $sSchemaType
                     }
                  } elseif {$aTimeStampFile($sSchemaType) > 0} {
                     puts \"\\nWARNING: Program '$sSpinnerProg' not present - no $sSchemaType files run\"
                  }
# Import Non-Spinner Schema
               } elseif {[lsearch $lsImport $sSchemaType] > -1} {
                  if {$bScan != \"TRUE\"} {
                     set bPercent FALSE
                     set lsExport [glob -nocomplain \"$sSpinDir/Export/$sSchemaType/*.exp\"]
                     if {[llength $lsExport] > 0} {
                        if {[llength $lsExport] > 50} {
                           set iPercent [expr [llength $lsExport] / 10]
                           set bPercent TRUE
                        }
                        set sAction \"\"
                        puts \"\\nImporting $aSchemaTitle($sSchemaType) items...\\n option for 'overwrite': $bImportOverwrite\"
                        foreach sExport $lsExport {
                           if {[lsearch $lsFileExtSkip [file ext $sExport]] < 0} {
                              pSetValue [list bSkipImport bUpdate] FALSE
                              pSetValue [list sT sN sR] \"\"
                              set sT [file root [file tail $sExport]]
                              set sT [pRemSpecChar $sT]
                              set sOut \":\"
                              if {[pQuery \"\" \"print $aSchemaElement($sSchemaType) \\134\\042$sT\\134\\042\"] == \"\"} {set sOut \"+\"}
                              if {$bImportOverwrite || $sOut == \"+\"} {
                                 set sMqlCommand \"import $aSchemaElement($sSchemaType) \\134\\042$sT\\134\\042 overwrite from file \\134\\042$sExport\\134\\042\"
                              } else {
                            	    set bSkipImport TRUE
                              }
                              if {$bSkipImport != \"TRUE\"} {
                                 mql start transaction update
                                 if {[catch {pMqlCmd $sMqlCommand} sMsg] != 0} {
                                    pAppend \"TRANSACTION NOT SUCCESSFUL! $sMsg\\n\" FALSE
                                    mql abort transaction
                                    incr iErrCtr
                                    if {$bPercent != \"TRUE\"} {puts -nonewline \"!\"}
                                    set iLogFileErr [open $sLogFileError a+]
                                    puts $iLogFileErr \"$sMqlCommand\\n$sMsg\"
                                    close $iLogFileErr
                                 } else {
                                    mql commit transaction
                                    if {$bPercent != \"TRUE\"} {puts -nonewline \"$sOut\"}
                                    incr iAddCtr
                                    if {$sSchemaType == \"person\"} {pMqlCmd \"import workspace * overwrite from file \\134\\042$sExport\\134\\042\"}
                                 }
                              } else {
                                 if {$bPercent != \"TRUE\"} {puts -nonewline \".\"}
                                 incr iSkipCtr
                              }
                              if {$bPercent && $iTenPercent < 10 && [expr $iAddCtr + $iSkipCtr + $iErrCtr] > [expr $iTenPercent * $iPercent]} {
                                 pWriteCue
                                 incr iTenPercent
                              }
                           }
                        }
                        if {$bPercent} {pWriteCue}
                        if {$iErrCtr} {
                           set pFile [open $sLogFilePath a+]
                           puts $pFile $sFile
                           close $pFile
                           puts \"\\n$iErrCtr error(s) generated - Review '$sLogFileError', correct problem(s) and restart\"
                           if {$bContinueOnError != \"TRUE\"} {
                              exit 1
                              return
                           }
                        } else {
                           set pFile [open \"$sLogFilePath\" a+]
                           puts $pFile $sFile
                           close $pFile
                           puts \"\\n$iAddCtr items imported, $iSkipCtr items skipped - log file: $sLogFilePath\"
                        }
                      }
                      pSpinDone $sSchemaType
                  }
               } else {
# Start Business Spinner               	
                  if {[lsearch $lsBusiness $aSchemaTitle($sSchemaType)] >= 0} {
                     set sSchemaTest $aSchemaTitle($sSchemaType)
                     if {[lsearch [list Role Group] $sSchemaTest] >= 0} {set sSchemaTest \"User\"}
                     if {[lsearch [list Command \"Menu\" Channel Portal Inquiry Table Column WebForm Field] $sSchemaTest] >= 0} {set sSchemaTest \"WebComp\"}
                     if {[lsearch [list Dimension Unit] $sSchemaTest] >= 0} {set sSchemaTest \"Dimension\"}
                     set sSchemaTestProg \"emxSpinner$sSchemaTest.tcl\"
                     if {$sSchemaTest == \"State\" || $sSchemaTest == \"Signature\"} {set sSchemaTestProg \"emxSpinnerPolicy.tcl\"}
                     if {$sSchemaTest == \"Association\"} {set sSchemaTestProg \"emxSpinnerUser.tcl\"}
                     if {[info procs \"pAnalyze$sSchemaTest\"] == \"\"} {
                        if {$bExecute != \"TRUE\" && [file exists $sSchemaTestProg]} {
                           set iBusProg [open $sSchemaTestProg r]
                           eval [read $iBusProg]
                           close $iBusProg
                        } elseif {$bExecute && [mql list program \"$sSchemaTestProg\"] != \"\"} {
                           eval [mql print program \"$sSchemaTestProg\" select code dump]
                        } else {
                           if {$bExecute} {
                              puts \"ERROR: Program object '$sSchemaTestProg' is missing from database\"
                           } else {
                              puts \"ERROR: Program '$sSchemaTestProg' is missing from directory '[pwd]'\"
                           }	
                           exit 1
                           return
                        }
                     }
                  }
# Read in data
                  puts \"\\nReading $aSchemaTitle($sSchemaType) data...\"
                  set lsDataFile [glob -nocomplain \"$sSpinDir/Business/*$aSchemaTitle($sSchemaType)Data*.*\"]
                  set slsDataFile \"\"
                  foreach sDataFile $lsDataFile {
                     if {[lsearch $lsFileExtSkip [file ext $sDataFile]] < 0} {
                        set iFile [open $sDataFile r]
                        append slsDataFile \"<HEADER>[read $iFile]\"
                        close $iFile
                     }
                  }
                  set lsFile [split $slsDataFile \\n]
                  if {$rTcl > 8.29 && $sSchemaType != \"field\"} {set lsFile [lsort -unique $lsFile]}
                  if {$sSchemaType == \"policy\"} {
                     if {$bForeignVault} {
                     	set slsVault \"*\"
                     } else {
                        set lsVault \"\"
                        set lsTempVault [split [mql list vault] \\n]
                        foreach sVault $lsTempVault {if {[mql print vault $sVault select map dump] == \"\"} {lappend lsVault $sVault}}
                        set slsVault [join $lsVault ,]
                     }
                  }
# Screen Spinner files
                  if {$sSchemaType == \"program\"} {
                     set lsTempFile [list ]
                     set lsSpinFile [list emxSpinner emxRegUnRe emxDumper_ emxSchema_ emxExtract]
                     foreach sProgFile $lsFile {
                        set sProgTest [string range [string trim $sProgFile] 0 9]
                      	if {[lsearch $lsSpinFile $sProgTest] >= 0} {
                        } else { 
                           lappend lsTempFile $sProgFile
                        }
                     }
                     set lsFile $lsTempFile
                  }
                  set lsType [list ]
                  if {($sSchemaType == \"role\" || $sSchemaType == \"group\")} {
                     puts \"   option to process users in Assignment field: $bUseAssignmentField\\n   option to use parent or child field is set to: $sParentChild\"
                  } elseif {$sSchemaType == \"policy\" || $sSchemaType == \"rule\"} {
                     puts \"   option to process users in Access field: $bUseAccessField\"
# Read in JPOs
                  } elseif {$sSchemaType == \"program\"} {
                     set lsSpecChar [list SLASH COLON LTHAN GTHAN PYPE]
                     array set aSpecChar [list SLASH \"/\" COLON \":\" LTHAN \"<\" GTHAN \">\" PYPE \"\\134\\174\"]
                     puts \"   option to compile JPO's: $bCompile\"
                     set lsSF [glob -nocomplain \"$sSpinDir/Business/SourceFiles/*\"]
                     foreach sSF $lsSF {
                        if {[lsearch $lsFileExtSkip [file ext $sSF]] < 0} { 
                           set sSF [file tail $sSF]
                           foreach sSpecChar $lsSpecChar {
                              regsub -all \"$sSpecChar\" $sSF \"$aSpecChar($sSpecChar)\" sSF
                           }
                           if {[string first \"_mxJPO\" $sSF] > 0} {
                              regsub \"_mxJPO(.)*.java\" $sSF \"_mxJPO.java\" sSFTest
                              if {[string first \"_mxJPO.java\" $sSFTest] > 0} {
                                 regsub \"_mxJPO.java\" $sSFTest \"\" sSFTest
# IR Fix 310671
                                 if {[file root $sSFTest] == $sSFTest && [lsearch $lsFile \"$sSFTest\\t\\*\"] < 0} {
                                    lappend lsFile \"$sSFTest\\t\\t\\tjava\\timmediate\\tFALSE\\tFALSE\\tFALSE\\tFALSE\\tFALSE\"
                                 }
                              } else {
                                 puts \"WARNING: Program file '$sSpinDir/Business/SourceFiles/$sSF' will not be processed\"
                              }  
                           } elseif {[string first \".tcl\" $sSF] > 0 && [pQuery \"\" \"list program \\042$sSF\\042\"] == \"\"} {
                              if {[lsearch $lsFile \"$sSF\\*\"] < 0} {lappend lsFile \"$sSF\\t\\t\\tmql\\timmediate\\tFALSE\\tFALSE\\tFALSE\\tFALSE\\tFALSE\"}
                           } elseif {[lsearch $lsFile \"$sSF\\*\"] < 0} {
                              puts \"WARNING: Program file '$sSpinDir/Business/SourceFiles/$sSF' will not be processed\"
                           }
                        }
                     }
                  }
# Check for multiple entries or duplicate registrations
                  set lsErrorMsg [pDuplicate $lsFile]
                  if {[llength $lsErrorMsg] > 0} {
                     pWriteErrorMsg [join $lsErrorMsg \\n]
                     exit 1
                     return
                  }
# Process business element rows
                  puts -nonewline \"Processing [expr [llength $lsFile] - 2] $aSchemaTitle($sSchemaType) rows\"
                  set iCounter 1
                  set bContinue TRUE
                  set bRepeat FALSE
                  set iPrevErrCtr 0
                  if {$bScan != \"TRUE\"} {append sFile \"# \\133[clock format [clock seconds] -format %H:%M:%S]\\135 $aSchemaTitle($sSchemaType)\\050s\\051\\n\"}
                  while {$bContinue} {
                     if {$bScan != \"TRUE\" && $iCounter != 1} {append sFile \"\\n# Loop $iCounter...\"}
                     set iErrCtr 0
                     set bContinue FALSE
                     set lsErrorType($iCounter) \"\"
                     set iErrorCheck [expr $iCounter - 1]
                     pSetValue [list bMulti bPercent bModFlag] FALSE
                     if {$bRepeat} {
                     	  if {[llength $lsErrorType($iErrorCheck)] > 50} {
                           set iPercent [expr [llength $lsErrorType($iErrorCheck)] / 10]
                           set bPercent TRUE
                           set iTenPercent 1
                           pSetValue [list iErrCtr iAddCtr iModCtr iDelCtr iSkipCtr iPrevAddModDel iPrevError] 0
                        }
                     } elseif {[llength $lsFile] > 50} {
                        set iPercent [expr [llength $lsFile] / 10]
                        set bPercent TRUE
                     }
                     foreach slsType $lsFile {
                        if {$slsType != \"\" && [string range $slsType 0 7] != \"<HEADER>\"} {
                           set bSkipType FALSE
                           if {$bRepeat} {
                              regsub -all \"\\042\" $slsType \"\" sTypeTest
                              regsub -all \"\\134\\133\" $sTypeTest \"\" sTypeTest
                              regsub -all \"\\134\\135\" $sTypeTest \"\" sTypeTest
                              if {[lsearch $lsErrorType($iErrorCheck) $sTypeTest] < 0} {set bSkipType TRUE}
                           }
                           if {$bSkipType != \"TRUE\"} {
                              set bEscQuote FALSE
                              if {[lsearch [list command menu channel portal] $sSchemaType] >= 0} {
                              	 if {[string first \"<ESCQUOTE>\" $slsType] > -1} {
                              	    set bEscQuote TRUE
                              	 } elseif {[regsub -all \"\\134\\134\\042\" $slsType \"<ESCQUOTE>\" slsType]} {
                              	    set bEscQuote TRUE
                              	 }
                              }
                              set lslsType [split $slsType $aDelimiter($sDelimiter)]
                              if {$bMulti} {
                                 if {[string first $aCol(0) [lindex $lslsType 0]] < 0 || [string first \"<MULTILINE.\" [lindex $lslsType 0]] < 0} {
                                    pWriteErrorMsg \"\\nERROR: Data file sequencing error for multiline schema element '$sSchemaType $aCol(0)'\"
                                    exit 1
                                    return
                                 }
                                 lappend lsBufferMulti $slsType
                                 foreach sColNo $aMultiColumn($sSchemaType) {if {[string trim [lindex $lslsType $sColNo]] != \"\"} {append aCol($sColNo) \" | [string trim [lindex $lslsType $sColNo]]\"}}
                                 incr iMulti -1
                                 incr iMultiCtr
                                 if {$iMulti > 1} {continue}
                              }
                              if {$bMulti} {
                                 set bMulti FALSE
                              } else {
                                 if {$bOverlay != \"TRUE\"} {
                                    regsub -all \"<NULL>\" $lslsType \"\" lslsType
                                    if {[string first \"<<\" $lslsType] >= 0 && [string first \">>\" $lslsType] >= 2} {
                                       puts \"Program halted:  Data file for '$sSchemaType' contains delete tags '<<' and '>>'.\\nThese may only be used in 'overlay' mode\"
                                       exit 1
                                       return
                                    }
                                 }
                                 for {set i 0} {$i < [expr $aIconIndex($sSchemaType) + 1]} {incr i} {
                                    set aCol($i) [string trim [lindex $lslsType $i]]
                                    set aCol($i) [pRegSubExcel $aCol($i)]
                                    if {[string first \"<SPACE>\" $aCol($i)] >= 0 && [lsearch $aMultiColumn($sSchemaType) $i] < 0} {regsub -all \"<SPACE>\" $aCol($i) \" \" aCol($i)}
                                    if {$bEscQuote} {
                                       if {$i == 4} {regsub -all \"\\042\" $aCol(4) \"\" aCol(4)}
                                       regsub -all \"<ESCQUOTE>\" $aCol($i) \"\\042\" aCol($i)
                                    }
                                 }
                                 if {[lsearch [list access state signature property column field unit trigger] $sSchemaType] < 0} {set sHidden $aCol($aHiddenIndex($sSchemaType))}
                                 set sIcon $aCol($aIconIndex($sSchemaType))
                                 set bUpdate TRUE
                                 if {[string first \"<MULTILINE.\" $aCol(0)] > -1} {
                                    regsub \"<MULTILINE.\" $aCol(0) \"|\" slsName
                                    set aCol(0) [string trim [lindex [split $slsName |] 0]]
                                    set sMulti [lindex [split [lindex [split $slsName |] 1] .] 1]
                                    regsub \">\" $sMulti \"\" iMulti
                                    set bMulti TRUE
                                    set lsBufferMulti \"\"
                                    lappend lsBufferMulti $slsType
                                    incr iMultiCtr
                                    continue
                                 }
                              }
# Set Add/Modify and Other Registration Parameters
                              if {$sSchemaType == \"state\" || $sSchemaType == \"signature\" || $sSchemaType == \"trigger\" || $sSchemaType == \"column\" || $sSchemaType == \"field\" || $sSchemaType == \"unit\" || $sSchemaType == \"property\"} {
                                 pSetValue [list bReg bAdd bDel] FALSE
                              } else {
                                 set bDel TRUE
                                 set bDelAddAttr FALSE
                                 if {[string first \"<<\" $aCol(0)] == 0 && [string first \">>\" $aCol(0)] == [expr [string length $aCol(0)] -2]} {
                                    set aCol(0) [string range $aCol(0) 2 [expr [string length $aCol(0)] -3]]
                                    if {$sSchemaType == \"attribute\" && [string first \"+\" $aCol(0)] == 0} {
                                       set aCol(0) [string range $aCol(0) 1 end]
                                       set bDelAddAttr TRUE
                                       set bDel FALSE
                                    }
                                 } else {
                                    for {set i 1} {$i < [expr $aIconIndex($sSchemaType)]} {incr i} {
                                       if {$aCol($i) != \"\"} {
                                 	        set bDel FALSE
                                 	        break
                                 	     }
                                    }
                                 }
                                 if {$bOverlay && $aCol(1) == \"\"} {
                                 	  set aCol(1) \"<SKIP>\"
                                 } elseif {$aCol(1) == \"<NULL>\"} {
                                 	  set aCol(1) \"\"
                                 }
                                 set sSymbolic \"\"
                                 if {$aCol(1) != \"\" && $aCol(1) != \"<SKIP>\"} {
                                    set sFormatted_Name [join [split \"$aCol(1)\" $sReplaceSymbolic] \"\"]
                                    set sSymbolic [format %s%s \"$aSchemaElement($sSchemaType)\\_\" $sFormatted_Name]
                                 }
                                 if {$bDel != \"TRUE\"} {
                                    set bReg TRUE
                                 } else {
                                    pSetValue [list bReg bAdd] FALSE
                                 }
                              }
                              if {$sSchemaType == \"table\" || $sSchemaType == \"column\" || ( $sSchemaType == \"property\" && $aCol(0) == \"table\" ) } {
                                 set sColumnField \"column\"
                                 set sSystem \"system\"
                                 set lsTable [split [mql list table system] \\n]
                              } else {
                                 set sColumnField \"field\"
                                 set sSystem \"\"
                                 set lsTable [list ]
                              }
                              if {$bReg} {
                                 pSetValue [list bAdd bRegister bUnRegName bUnRegSym] FALSE
                                 set sNameExists [pPrintQuery \"\" name \"\" \"\"]
                                 set sModName $aCol(0)
                                 if {$aCol(1) == \"<SKIP>\"} {
                                    if {$sNameExists == \"\"} {set bAdd TRUE}
                                 } else {
                                    pSetValue [list sSymbolicFromName sNameFromSymbolic] \"\"
                                    catch {set sSymbolicFromName $aSymbolic($aSchemaElement($sSchemaType)|$aCol(0))} sMsg
                                    if {$sSymbolic != \"\"} {catch {set sNameFromSymbolic $aSchemaName($sSymbolic)} sMsg}
                                 #  Not in database & no registry name specified - add
                                    if {$sNameExists == \"\" && $sSymbolic == \"\"} {
                                       set bAdd TRUE
                                 #  Not in database & orig name symbolic not in database - add & register
                                    } elseif {$sNameExists == \"\" && $sNameFromSymbolic == \"\"} {
                                       pSetValue [list bAdd bRegister] TRUE
                                 #  Not in database & real name from orig name symbolic does not match - mod (rename)
                                    } elseif {$sNameExists == \"\" && $sNameFromSymbolic != $aCol(0)} {
                                       set aCol(0) $sNameFromSymbolic
                                       set bRegister TRUE
                                 #  Has no symbolic reference & no registry name specified - mod
                                    } elseif {$sSymbolicFromName == \"\" && $sSymbolic == \"\"} {
                                 #  Has no symbolic reference & orig name symbolic not in database - mod & register
                                    } elseif {$sSymbolicFromName == \"\" && $sNameFromSymbolic == \"\"} {
                                       set bRegister TRUE
                                 #  Has no symbolic reference & real name from orig name symbolic does not match - mod & unregister name from symbolic then register
                                    } elseif {$sSymbolicFromName == \"\" && $sNameFromSymbolic != $aCol(0)} {
                                       pSetValue [list bRegister bUnRegSym] TRUE
                                 #  Has symbolic reference & no registry name specified - mod & unregister name
                                    } elseif {$sSymbolicFromName != \"\" && $sSymbolic == \"\"} {
                                       set sSymbolicTest [lindex [split $sSymbolicFromName \"_\"] 0]
                                       if {$sSymbolicTest == $aSchemaElement($sSchemaType)} {set bUnRegName TRUE}
                                 #  Has symbolic reference & orig name symbolic not in database - mod & unregister name then register name
                                    } elseif {$sSymbolicFromName != \"\" && $sNameFromSymbolic == \"\"} {
                                       pSetValue [list bRegister bUnRegName] TRUE
                                 #  Symbolic reference matches orig name symbolic & orig name symbolic matches name - mod
                                    } elseif {$sSymbolicFromName == $sSymbolic && $sNameFromSymbolic == $aCol(0)} {
                                 #  Symbolic reference does not match orig name symbolic & orig name symbolic does not match name - mod & unregister name & unregister name from symbolic then register name
                                    } elseif {$sSymbolicFromName != $sSymbolic} {
                                       pSetValue [list bRegister bUnRegName bUnRegSym] TRUE
                                    }
                                 }
                                 set sHidden [pCompareAttr $sHidden nothidden hidden true true]
                                 set bHiddenActual [pQuery false \"print $aSchemaElement($sSchemaType) \\042$aCol(0)\\042 $sSystem select hidden dump\"]
                                 set sHiddenActual [pCompareAttr $bHiddenActual nothidden hidden true false]
                                 if {$sHidden == \"\"} {set sHidden $sHiddenActual}
                                 set sDescriptionActual [pQuery \"\" \"print $aSchemaElement($sSchemaType) \\042$aCol(0)\\042 $sSystem select description dump\"]
                              } else {
                                 set sModName \"\"
                              }
                              set sAddMod Modify
                              if {$bAdd} {set sAddMod \"Add\"}
                              pSetAction \"$sAddMod $sSchemaType $aCol(0)\"
# Analyze data file fields
                              if {$bDel != \"TRUE\"} {
                              	 set iReturn 0
                                 switch $sSchemaType {
                                      role - group {
                                       pAnalyzeUser
                                    } command - menu - channel - portal - inquiry - table - column - webform - field {
                                    	 set iReturn [pAnalyzeWebComp]
                                    	 if {$iReturn} {
                                          exit 1
                                          return
                                       }
                                    } property {
                                       set iReturn [pAnalyzeProperty]
                                       if {$iReturn} {
                                          exit 1
                                          return
                                       }
                                    } dimension - unit {
                                       set iReturn [pAnalyzeDimension]
                                       if {$iReturn} {
                                          exit 1
                                          return
                                       }
                                    } default {
                                       eval \"pAnalyze$aSchemaTitle($sSchemaType)\"
                                    }
                                 }
                              }
# Compare data file to database and add or modify as required
                              if {$bScan != \"TRUE\"} {mql start transaction update}
                              set bUpdate FALSE
                              if { [ catch {
                                 if {$bDel} {
                                    pSetAction \"Delete $sSchemaType $aCol(0)\"
                                    set sSchemaDel $sSchemaType
                                    if {$sSchemaType == \"webform\"} {set sSchemaDel \"form\"}
                                    if {[pQuery \"\" \"print $sSchemaDel \\042$aCol(0)\\042 $sSystem\"] != \"\"} {
                                       pMqlCmd \"delete $sSchemaDel \\042$aCol(0)\\042 $sSystem\"
                                       catch {
                                          if {$aSymbolic($sSchemaDel|$aCol(0)) != \"\"} {
                                             set aSchemaName($aSymbolic($sSchemaDel|$aCol(0))) \"\"
                                             set aSymbolic($aSchemaElement($sSchemaDel)|$aCol(0)) \"\"
                                          }
                                       } sMsg
                                    }
                                 } else {
                                    if {$sSchemaType == \"trigger\" || $sSchemaType == \"property\"} {
                                       set sRegType $aCol(0)
                                       set sRegName $aCol(1)
                                    } else {
                                       set sRegType $aSchemaElement($sSchemaType)
                                       set sRegName $aCol(0)
                                    }
                                    if {$sSchemaType != \"association\" && $sSchemaType != \"property\" && $sSchemaType != \"rule\"} {
                                       if {$sRegType == \"table\"} {
                                          set lsSpinStamp [list 0 \"\"]
                                          if {[lsearch $lsTable $aCol(0)] >= 0} {set lsSpinStamp [split [pQuery 0 \"print $sRegType \\042$sRegName\\042 $sSystem select modified property\\134\\133SpinnerAgent\\134\\135.value dump |\"] |]}
                                       } else {
                                          set lsSpinStamp [split [pQuery \"0|\" \"list $sRegType \\042$sRegName\\042 $sSystem select modified property\\134\\133SpinnerAgent\\134\\135.value dump |\"] |]
                                       }
                                       set sModified [lindex $lsSpinStamp 0]
                                       set sSpinStamp [lindex $lsSpinStamp 1]
                                    }
                                    switch $sSchemaType {
                                       role - group {
                                       	  set iReturn [pProcessUser]
                                       } command - menu - channel - portal - inquiry - table - column - webform - field {
                                       	  set iReturn [pProcessWebComp]
                                       } dimension - unit {
                                       	  set iReturn [pProcessDimension]
                                       } default {
                                          set iReturn [pProcess$aSchemaTitle($sSchemaType)]
                                       }
                                       
                                    }
                                    if {$iReturn} {
                                       exit 1
                                       return
                                    }
                                    if {$bSkipElement != \"TRUE\"} {
                                       if {[lsearch [list state signature property column field unit trigger] $sSchemaType] < 0} {
                                          regsub -all \"\\\\\\n\" $sDescriptionActual \"<NEWLINE>\" sDescriptionActual
                                          if {$bOverlay} {
                                             if {$aCol($aDescIndex($sSchemaType)) == \"<NULL>\"} {
                                                set aCol($aDescIndex($sSchemaType)) \"\"
                                             } elseif {$bAdd != \"TRUE\" && $aCol($aDescIndex($sSchemaType)) == \"\"} {
                                                set aCol($aDescIndex($sSchemaType)) $sDescriptionActual
                                             }
                                          }
                                          if {$bAdd || $aCol($aDescIndex($sSchemaType)) != $sDescriptionActual} {
                                             set aCol($aDescIndex($sSchemaType)) [pRegSubEvalEscape $aCol($aDescIndex($sSchemaType))]
                                             if {$bScan != \"TRUE\"} {
										                            regsub -all \"<NEWLINE>\" $aCol($aDescIndex($sSchemaType)) \"\\\\\\n\" aCol($aDescIndex($sSchemaType))
                                                pMqlCmd \"escape mod $aSchemaElement($sSchemaType) \\042$aCol(0)\\042 $sSystem description \\042$aCol($aDescIndex($sSchemaType))\\042\"
                                             }
                                             set bUpdate TRUE
                                          }
                                          if {$sIcon != \"\" && $bScan != \"TRUE\" && $sSchemaType != \"table\" && $sSchemaType != \"webform\"} {mql mod $sSchemaType $aCol(0) icon \"$sSpinDir/Pix/$sIcon\"}
                                       }
                                       if {$bAdd != \"TRUE\" && $sModName != \"\"} {
                                          if {$aCol(0) != $sModName} {
                                             pMqlCmd \"mod $aSchemaElement($sSchemaType) \\042$aCol(0)\\042 $sSystem name \\042$sModName\\042\"
                                             set aSchChgName(\"$sSchemaType|$aCol(0)\") $sModName
                                          }
                                       }
                                    }
                                    set bSkipElement FALSE
                                 }
                              } result ] != 0 } {
# Unsuccessful transaction
                                 pAppend \"TRANSACTION NOT SUCCESSFUL!  $result$resultappend\\n\" FALSE
                                 set bModFlag TRUE
                                 if {$bScan != \"TRUE\"} {mql abort transaction}
                                 if {$bPercent != \"TRUE\"} {puts -nonewline \"!\"}
                                 set iLogFileErr [open $sLogFileError a+]
                                 puts $iLogFileErr \"$sAction\\n$result$resultappend\"
                                 close $iLogFileErr
                                 if {!$bScan && [lsearch [list role group type menu webform interface] $sSchemaType] >= 0} {
                                    set bContinue TRUE
                                 }
                                 incr iErrCtr
                                 set lsTypeTest \"\"
                                 if {[string first \"<MULTILINE.\" $slsType] > -1} {
                                    set lsTypeTest $lsBufferMulti
                                 } else {
                                    lappend lsTypeTest $slsType
                                 }
                                 foreach sTypeTest $lsTypeTest {
                                    regsub -all \"\\042\" $sTypeTest \"\" sTypeTest
                                    regsub -all \"\\134\\133\" $sTypeTest \"\" sTypeTest
                                    regsub -all \"\\134\\135\" $sTypeTest \"\" sTypeTest
                                    lappend lsErrorType($iCounter) $sTypeTest
                                 }
                              } else {
# Successful transaction
                                 if {$bUpdate} {
                                    if {$bScan != \"TRUE\"} {pAppend \"# Transaction successful.\\n\" FALSE}
                                    set bModFlag TRUE
                                    if {$bAdd} {
                                       incr iAddCtr
                                       incr iAddCtrTot
                                       set sOut \"+\"
                                    } elseif {$bDel} {
                                       incr iDelCtr
                                       incr iDelCtrTot
                                       set sOut \"-\"
                                    } else {
                                       incr iModCtr
                                       incr iModCtrTot
                                       set sOut \":\"
                                    }
                                    if {$bPercent != \"TRUE\" && ($sSchemaType != \"program\" || $aCol(3) != \"java\")} {puts -nonewline \"$sOut\"}
                                    if {$bScan != \"TRUE\"} {mql commit transaction}
                                    if {$bDel != \"TRUE\"} {
# Spinner registration
                                       if {$sModName != \"\"} {set sRegName $sModName}
                                       if {$sSchemaType != \"association\" && $sSchemaType != \"property\" && $sSchemaType != \"rule\"} {
                                       	  set sNewModified [pQuery 0 \"print $sRegType \\042$sRegName\\042 $sSystem select modified dump\"]
                                       	  set sSpinnerAgent [pQuery \"\" \"print $sRegType \\042$sRegName\\042 $sSystem select property\\134\\133SpinnerAgent\\134\\135.value dump\"]
                                       	  if {$sNewModified != 0} {
                                             if {$sSpinStamp == \"\" || $sSpinnerAgent == \"\"} {
                                                if {$bScan != \"TRUE\"} {
                                                   catch {eval \"mql add property SpinnerAgent on $sRegType \\042$sRegName\\042 $sSystem value \\042$sNewModified\\042\"} sMsg
                                                }
                                             } else {
                                                if {$bScan != \"TRUE\"} {
                                                   catch {eval \"mql mod property SpinnerAgent on $sRegType \\042$sRegName\\042 $sSystem value \\042$sNewModified\\042\"} sMsg
                                                }
                                                if {[expr [clock scan $sModified] - [clock scan $sSpinStamp]] > 1} {pWriteWarningMsg \"\\nWARNING: '$sRegType' '$sRegName' was modified on '$sModified' after last Spinner mod on '$sSpinStamp'\"}
                                             }
                                          }
                                       }
# Compile program if JPO
                                       if {$bCompile} {
                                          set sTempName $aCol(0)
                                          if {$sModName != \"\"} {set sTempName $sModName}
                                          if {$sSchemaType == \"program\"} {
                                             if {$aCol(3) == \"java\"} {
                                                if {$bScan != \"TRUE\"} {
                                                   catch {mql compile program $sTempName force update} sMsg
                                                   if {[string first \"already compiled\" $sMsg] < 0} {
                                                      pWriteWarningMsg \"\\nWARNING: JPO '$sTempName' compile error - review 'mxtrace.log'\"
                                                   } elseif {$bPercent != \"TRUE\"} {
                                                      puts -nonewline \";\"
                                                   }
                                                }  
                                                pAppend \"mql compile program $sTempName force update\\n\" FALSE
                                             }
                                          }
                                       }
                                    }
                                 } else {
                                    if {$bScan != \"TRUE\" && $bShowModOnly != \"TRUE\"} {pAppend \" - not required\" TRUE}
                                    if {$bPercent != \"TRUE\"} {puts -nonewline \".\"}
                                    incr iSkipCtr
                                    incr iSkipCtrTot
                                    if {$bScan != \"TRUE\"} {mql commit transaction}
                                 }
# Registrations
                                 if {$bReg && $bAEF} {
                                    if {$bUnRegName} {
                                       pUnRegisterSchema $aSchemaElement($sSchemaType) $sModName $aSymbolic($aSchemaElement($sSchemaType)|$aCol(0))
                                       array set aSymbolic [list \"$aSchemaElement($sSchemaType)|$sModName\" \"\"]
                                       if {$bUnRegSym != \"TRUE\"} {array set aSchemaName [list $sSymbolic \"\"]}
                                    }
                                    if {$bUnRegSym} {
                                       set lsSchemaSymbolic [split $aSchemaName($sSymbolic) |]
                                       foreach sSchemaSymbolic $lsSchemaSymbolic {
                                          pUnRegisterSchema $aSchemaElement($sSchemaType) $sSchemaSymbolic $sSymbolic
                                          array set aSymbolic [list \"$aSchemaElement($sSchemaType)|$sSchemaSymbolic\" \"\"]
                                       }
                                       array set aSchemaName [list $sSymbolic \"\"]
                                    }
                                    if {$bRegister} {
                                       pRegisterSchema $aSchemaElement($sSchemaType) $sModName $aCol(1) $sSymbolic
                                       array set aSymbolic [list \"$aSchemaElement($sSchemaType)|$sModName\" $sSymbolic]
                                       array set aSchemaName [list $sSymbolic $sModName]
                                    }
                                 }
                              }
                              if {$bPercent && $iTenPercent < 10 && [expr $iAddCtr + $iModCtr + $iDelCtr + $iSkipCtr + $iErrCtr + $iMultiCtr] > [expr $iTenPercent * $iPercent]} {
                                 pWriteCue
                                 incr iTenPercent
                              }
                           }
                        }
                     }
# Loop if error and continue loop if errors get corrected
                     if {$bContinue} {
                        if {($iModCtr == 0 && $iAddCtr == 0 & $iDelCtr == 0) || $iPrevErrCtr == $iErrCtr} {
                           set bContinue FALSE
                        } else {
                           incr iCounter
                           set iPrevErrCtr $iErrCtr
                           puts -nonewline \"\\nloop $iCounter\"
                           if {$bContinueOnError != \"TRUE\"} {
                              set iLogFileErr [open $sLogFileError w]
                              close $iLogFileErr
                           }
                           set bRepeat TRUE
                        }
                     }
                     if {$bPercent} {pWriteCue}
                  }
# Process logs
                  if {$iAddCtr > 0 || $iModCtr > 0 || $iDelCtr > 0 || $iSkipCtr > 0 || $iErrCtr > 0} {puts \"\"}
                  set pFile [open $sLogFilePath a+]
                  puts $pFile $sFile
                  close $pFile
                  puts \"$iAddCtrTot adds, $iModCtrTot mods, $iDelCtrTot dels, $iSkipCtrTot skips, $iRegisterCounter regs\"
                  if {$iErrCtr > 0} {
                     puts \"\\n$iErrCtr error(s) generated - Review log file '$sLogFileError', correct problem(s) and restart\"
                     if {$bScan != \"TRUE\" && $bContinueOnError != \"TRUE\"} {break}
                  } elseif {$bScan != \"TRUE\"} {
                     pSpinDone $sSchemaType
                     if {$bContinueOnError != \"TRUE\"} {
                        set iLogFileErr [open $sLogFileError w]
                        close $iLogFileErr
                     }
                  }
               }
# End Business Spinner
            }
            if {$bProcess && !$iErrCtr} {
               set lsSchemaType $lsSchemaElement
            } else {
               set bProcess FALSE
            }
         }
      } else {
         puts \"No changes required -- all data files have already been processed or no data files found.\\nTo force processing, use the parameter 'force': exec prog emxSpinnerAgent.tcl force;\"
         set bLogMsg FALSE
      }
      if {$sWarning != \"\"} {
         set iLogFileErr [open $sLogFileError a+]
         puts $iLogFileErr $sWarning
      } else { 
         set iLogFileErr [open $sLogFileError r+]
         set sLogFileMsg [read $iLogFileErr]
         if {$sLogFileMsg == \"\"} {puts $iLogFileErr \"SpinnerAgent finished with no errors.\"}
      }
      close $iLogFileErr
      if {$bLogMsg} {puts \"\\n...SpinnerAgent processing finished - log file generated: $sLogFilePath\"}
      set bLogMsg TRUE
      if {$sLogFileMsg != \"\"} {break}
   }
}
" 1 0 0 0 0 0 0 0 0 0 0 0 "" 0 0
 0 3
 SpinnerAgent NULL noname "3/27/2017 3:41:28 PM" 0
 build NULL noname "2013.02.05 Rev7" 0
 version NULL noname V6R2013 0
"12/6/2015 11:42:57 PM" "3/14/2018 3:57:25 PM"
15
 0 1 "12/6/2015 11:42:57 PM" creator "add program emxSpinnerAgent.tcl mql execute immediate !needsbusinessobject !downloadable !pipe !pooled nothidden file ./Business/SourceFiles/emxSpinnerAgent.tcl"
 0 2 "12/6/2015 11:42:57 PM" creator "mod program emxSpinnerAgent.tcl description ''"
 0 2 "12/6/2015 11:42:58 PM" creator "add property SpinnerAgent on program emxSpinnerAgent.tcl value '12/6/2015 11:42:57 PM'"
 0 2 "12/8/2015 9:27:29 PM" creator "  modify program emxSpinnerAgent.tcl !pipe code \"#########################################################################*10.90 tcl; mql verb off eval { if {[info host] == \"mostermant43\" } { source \"c:/Program Files/TclPro1.3/win32-ix86/bin/prodebug.tcl\" set cmd \"debugger_eval\" set xxx [debugger_init] } else { set cmd \"eval\" } } $cmd { set sSpinnerPath [mql get env 1] set sArg1 [string tolower $sSpinnerPath] set sSpinnerSetting [mql get env 2] set sArg2 [string tolower $sSpinnerSetting] set sArg3 [string tolower [mql get env 3]] set bScan FALSE set bReset FALSE if {$sArg3 == \"scan\"} { set bScan TRUE } elseif {$sArg3 == \"reset\" || $sArg3 == \"force\"} { set bReset TRUE } elseif {$sArg2 == \"scan\"} { set bScan TRUE set sSpinnerSetting \"\" } elseif {$sArg2 == \"reset\" || $sArg2 == \"force\"} { set bReset TRUE set sSpinnerSetting \"\" } elseif {$sArg1 == \"scan\"} { set bScan TRUE set sSpinnerPath \"\" set sSpinnerSetting \"\" } elseif {$sArg1 == \"reset\" || $sArg1 == \"force\"} { set bReset TRUE set sSpinnerPath \"\" set sSpinnerSetting \"\" } if {$bScan} {mql set env SPINNERSCANMODE TRUE} if {$sSpinnerPath == \"\"} { set sSpinnerPath \".\" } else { if {[catch {cd $sSpinnerPath} sMsg] != 0} { puts \"\\nERROR:  Path '$sSpinnerPath' does not exist or permission denied\" exit 1 return } } if {$sSpinnerSetting == \"\"} {set sSpinnerSetting emxSpinnerSettings.tcl} if {[catch { if {[file exists \"$sSpinnerPath/$sSpinnerSetting\"] == 1} { set iFileSet [open \"$sSpinnerPath/$sSpinnerSetting\" r] eval [read $iFileSet] close $iFileSet set sSettingLoc \"file '$sSpinnerPath/$sSpinnerSetting'\" } elseif {[mql list program $sSpinnerSetting] != \"\"} { eval [mql print program $sSpinnerSetting select code dump] set sSettingLoc \"database program '$sSpinnerSetting'\" } else { puts \"ERROR:  Spinner Settings file missing.  Load 'emxSpinnerSettings.tcl' in database or place in Spinner path\" exit 1 return } } sMsg] != 0} { puts \"\\nERROR: Problem with settings file '$sSpinnerSetting'\\n$sMsg\" exit 1 return } set lsSetting [list sParentChild bUseAssignmentField bUseA"
 0 2 "2/3/2016 5:21:01 PM" creator "mod property SpinnerAgent on program emxSpinnerAgent.tcl value '2/3/2016 5:21:01 PM'"
 0 2 "2/3/2016 5:21:01 PM" creator "mod program emxSpinnerAgent.tcl file ./Business/SourceFiles/emxSpinnerAgent.tcl"
 0 2 "2/3/2016 5:21:04 PM" creator "add property version on program emxSpinnerAgent.tcl value V6R2013"
 0 2 "2/3/2016 5:21:04 PM" creator "add property build on program emxSpinnerAgent.tcl value '2013.02.05 Rev7'"
 0 2 "3/7/2016 10:03:58 AM" creator "mod property SpinnerAgent on program emxSpinnerAgent.tcl value '3/7/2016 10:03:58 AM'"
 0 2 "3/7/2016 10:03:58 AM" creator "mod program emxSpinnerAgent.tcl file ./Business/SourceFiles/emxSpinnerAgent.tcl"
 0 2 "3/7/2016 10:03:59 AM" creator "add property build on program emxSpinnerAgent.tcl value '2013.02.05 Rev7'"
 0 2 "3/7/2016 10:03:59 AM" creator "add property version on program emxSpinnerAgent.tcl value V6R2013"
 0 2 "3/21/2017 10:07:07 AM" creator "  modify program emxSpinnerAgent.tcl !pipe code \"#########################################################################*2013 tcl; mql verb off eval { if {[info host] == \"l1509dsc\" } { source \"c:/Program Files/TclPro1.3/win32-ix86/bin/prodebug.tcl\" set cmd \"debugger_eval\" set xxx [debugger_init] } else { set cmd \"eval\" } } $cmd { set sSpinnerPath [mql get env 1] set sArg1 [string tolower $sSpinnerPath] set sSpinnerSetting [mql get env 2] set sArg2 [string tolower $sSpinnerSetting] set sArg3 [string tolower [mql get env 3]] set bScan FALSE set bReset FALSE if {$sArg3 == \"scan\"} { set bScan TRUE } elseif {$sArg3 == \"reset\" || $sArg3 == \"force\"} { set bReset TRUE } elseif {$sArg2 == \"scan\"} { set bScan TRUE set sSpinnerSetting \"\" } elseif {$sArg2 == \"reset\" || $sArg2 == \"force\"} { set bReset TRUE set sSpinnerSetting \"\" } elseif {$sArg1 == \"scan\"} { set bScan TRUE set sSpinnerPath \"\" set sSpinnerSetting \"\" } elseif {$sArg1 == \"reset\" || $sArg1 == \"force\"} { set bReset TRUE set sSpinnerPath \"\" set sSpinnerSetting \"\" } if {$bScan} {mql set env SPINNERSCANMODE TRUE} if {$sSpinnerPath == \"\"} { set sSpinnerPath \".\" } else { if {[catch {cd $sSpinnerPath} sMsg] != 0} { puts \"\\nERROR:  Path '$sSpinnerPath' does not exist or permission denied\" exit 1 return } } if {$sSpinnerSetting == \"\"} {set sSpinnerSetting emxSpinnerSettings.tcl} if {[catch { if {[file exists \"$sSpinnerPath/$sSpinnerSetting\"] == 1} { set iFileSet [open \"$sSpinnerPath/$sSpinnerSetting\" r] eval [read $iFileSet] close $iFileSet set sSettingLoc \"file '$sSpinnerPath/$sSpinnerSetting'\" } elseif {[mql list program $sSpinnerSetting] != \"\"} { eval [mql print program $sSpinnerSetting select code dump] set sSettingLoc \"database program '$sSpinnerSetting'\" } else { puts \"ERROR:  Spinner Settings file missing.  Load 'emxSpinnerSettings.tcl' in database or place in Spinner path\" exit 1 return } } sMsg] != 0} { puts \"\\nERROR: Problem with settings file '$sSpinnerSetting'\\n$sMsg\" exit 1 return } set lsSetting [list sParentChild bUseAssignmentField bUseAccess"
 0 2 "3/27/2017 3:41:28 PM" creator "mod property SpinnerAgent on program emxSpinnerAgent.tcl value '3/27/2017 3:41:28 PM'"
 0 2 "3/27/2017 3:41:28 PM" creator "mod program emxSpinnerAgent.tcl file ./Business/SourceFiles/emxSpinnerAgent.tcl"

!MTRX!END

!MTRX!AD! program emxSpinnerProgram.tcl "3DEXPERIENCE R2015x(24.0.0.0)"
emxSpinnerProgram.tcl 0 "" "#########################################################################*10.59
#
# @progdoc      emxSpinnerProgram.tcl vM10.59 (Build 5.5.25)
#
# @Description: Procedures for running in Programs
#
# @Parameters:  Returns 0 if successful, 1 if not
#
# @Usage:       Utilized by emxSpinnerAgent.tcl
#
# @progdoc      Copyright (c) MatrixOne Inc. 2005
#
#########################################################################
#
# @Modifications: FirstName LastName MM/DD/YYYY - Modification
#
#########################################################################

# Procedure to analyze programs
proc pAnalyzeProgram {} {
   global aCol aDat bOverlay bAdd sCode sCodeActual sCodeTrim sMxVersion sSpinDir bJPO sProgramFile sProgramFilePlan bOut
   if {$bAdd != \"TRUE\" && $bOverlay && $aCol(3) == \"\"} {
   } elseif {[string tolower $aCol(3)] != \"java\" && [string tolower $aCol(3)] != \"external\"} {
      set aCol(3) mql
   } elseif {[string tolower $aCol(3)] != \"external\"} {
      set aCol(3) java
   } else {
      set aCol(3) external
   }
   set aCol(4) [pCompareAttr $aCol(4) immediate deferred deferred true]
   set aCol(5) [pCompareAttr $aCol(5) !needsbusinessobject needsbusinessobject true true]
   set aCol(6) [pCompareAttr $aCol(6) !downloadable downloadable true true]
   set aCol(7) [pCompareAttr $aCol(7) !pipe pipe true true]
   set aCol(8) [pCompareAttr $aCol(8) !pooled pooled true true]
   set lsSpecChar [list \"/\" \":\" \"<\" \">\" \"\\134\\174\"]
   array set aSpecChar [list \"/\" SLASH \":\" COLON \"<\" LTHAN \">\" GTHAN \"\\134\\174\" PYPE]
   set sProgramFile $aCol(0)
   foreach sSpecChar $lsSpecChar {
      regsub -all \"$sSpecChar\" $sProgramFile \"$aSpecChar($sSpecChar)\" sProgramFile
   }
   set bFail FALSE
   set bJPO FALSE
   if {[catch {set iSourceFile [open \"$sSpinDir/Business/SourceFiles/$sProgramFile\" r]} sMsg] != 0} {
   	set bFail TRUE
   	set sErrorMsg \"Source file '$sSpinDir/Business/SourceFiles/$sProgramFile' is not present\"
   	if {$aCol(3) == \"java\"} {
   	   set sProgramFilePlan [glob -nocomplain \"$sSpinDir/Business/SourceFiles/$sProgramFile\\_mxJPO*.java\"]
           if {$sProgramFilePlan == \"\"} {
              set sErrorMsg \"Source file '$sProgramFile' or JPO '$sProgramFile\\_mxJPO\\133*\\135.java' in directory '$sSpinDir/Business/SourceFiles' is not present\"
           } elseif {[llength $sProgramFilePlan] > 1} {
              set sErrorMsg \"Too many versions of source file '$sSpinDir/Business/SourceFiles/$sProgramFile\\_mxJPO\\133*\\135.java' are present\"
           } else {
              set bFail FALSE
              set bJPO TRUE
              set sProgramFilePlan [ lindex $sProgramFilePlan 0 ]
              set iSourceFile [open $sProgramFilePlan r]
           }
       }
   } elseif {$aCol(3) == \"java\" && [glob -nocomplain \"$sSpinDir/Business/SourceFiles/$sProgramFile\\_mxJPO*.java\"] != \"\"} {
   	set sWarningMsg \"WARNING: Both files '$sProgramFile' and '$sProgramFile\\_mxJPO\\133*\\135.java' are present: '$sProgramFile\\_mxJPO\\133*\\135.java' will be ignored.\"
        pWriteWarningMsg \"\\n$sWarningMsg\"
   	set bJPO FALSE
   }
   if {$bFail} {
      pWriteErrorMsg \"\\nERROR: $sErrorMsg\"
      exit 1
      return
   } else {
      set sCode [read $iSourceFile]
      if {$bJPO} {regsub -all \"_mxJPO(\\133a-z\\135|\\133A-Z\\135|\\1330-9\\135)*\" $sCode \"_mxJPO\" sCode}
      set sCodeTrim [string trim $sCode]
      close $iSourceFile
   }
   if {$bAdd != \"TRUE\"} {
      set aDat(3) \"\"
      set bProgType \"\"
      if {[catch {set bProgType [mql print program $aCol(0) select isjavaprogram dump]} sMsg] == 0} {
         if {$bProgType} {
            set aDat(3) java
         } elseif {[mql print program $aCol(0) select ismqlprogram dump] == \"TRUE\"} {
            set aDat(3) mql
         } else {
            set aDat(3) external
         }
      }
      set aDat(4) [pPrintQuery \"\" execute \"\" \"\"]
      set bNeedBusObj [pPrintQuery \"\" doesneedcontext \"\" \"\"]
      set aDat(5) [pCompareAttr $bNeedBusObj !needsbusinessobject needsbusinessobject true false]
      set bDownload [pPrintQuery \"\" downloadable \"\" \"\"]
      set aDat(6) [pCompareAttr $bDownload !downloadable downloadable true false]
      set aDat(7) \"!pipe\"
      set aDat(8) \"!pooled\"
      set lsPrint [split [pQuery \"\" \"print program \\042$aCol(0)\\042\"] \\n]
      foreach sPipePool $lsPrint {
         set sPipePool [string trim $sPipePool]
         if {[string first \"code\" $sPipePool] == 0} {
            break
         } elseif {$sPipePool == \"pooled\"} {
            set aDat(8) pooled
         } elseif {$sPipePool == \"pipe\"} {
            set aDat(7) pipe
         }
      }
      if {$sMxVersion >= 10.5} {set aDat(10) [pPrintQuery \"\" user \"\" \"\"]}
      set sCodeActual \"\"
      if {$bJPO} {
         if {[catch {set sJPOPath \"$env(MATRIXHOME)\\/java/custom\"} sMsg] == 0} {
            regsub -all \"\\134\\134\" $sJPOPath \"/\" sJPOPath
            set sProgTime [clock seconds]
            if {[catch {mql extract program $aCol(0)} sMsg] == 0} {
               set lsProgramFileActual [glob -nocomplain \"$sJPOPath/$sProgramFile\\_mxJPO*.java\"]
               foreach sProgramFileActual $lsProgramFileActual {if {[file mtime $sProgramFileActual] >= $sProgTime} {break}}
               if {$sProgramFileActual != \"\"} {
                  set iCodeActual [open $sProgramFileActual r]
                  set sCodeActual [string trim [read $iCodeActual]]
                  regsub -all \"_mxJPO(\\133a-z\\135|\\133A-Z\\135|\\1330-9\\135)*\" $sCodeActual \"_mxJPO\" sCodeActual
                  close $iCodeActual
                  catch {file delete $sProgramFileActual -force} sMsg
               }
            }
         }
      } else {
         set sCodeActual [pPrintQuery \"\" code \"\" \"\"]
      }
   }
   if {$bOverlay} {pOverlay [list 3 4 5 6 7 8]}
   if {$bOverlay && $sMxVersion >= 10.5} {pOverlay [list 10]}
}

# Procedure to process programs
proc pProcessProgram {} {
   global aCol aDat bAdd sCode sCodeActual sCodeTrim sSpinDir sHidden sHiddenActual sMxVersion bJPO sProgramFile sProgramFilePlan bAEF
   set bModProg FALSE
   if {$bAdd} {
      pMqlCmd \"add program \\042$aCol(0)\\042 $aCol(3) execute $aCol(4) $aCol(5) $aCol(6) $aCol(7) $aCol(8) $sHidden\"
      if {$aCol(0) == \"eServiceSchemaVariableMapping.tcl\"} {set bAEF TRUE}
      if {$sMxVersion >= 10.5} {pMqlCmd \"mod program \\042$aCol(0)\\042 execute user \\042$aCol(10)\\042\"}
   } else {
      if {$aCol(3) != $aDat(3) || $aCol(4) != $aDat(4) || $aCol(5) != $aDat(5) || $aCol(6) != $aDat(6) || $aCol(7) != $aDat(7) || $aCol(8) != $aDat(8) || $sHidden != $sHiddenActual} {pMqlCmd \"mod program \\042$aCol(0)\\042 $aCol(3) execute $aCol(4) $aCol(5) $aCol(6) $aCol(7) $aCol(8) $sHidden\"}
      if {$sMxVersion >= 10.5 && $aCol(10) != $aDat(10)} {pMqlCmd \"mod program \\042$aCol(0)\\042 execute user \\042$aCol(10)\\042\"}
      if {[string first $sCodeActual $sCode] == -1 && $sCodeTrim != $sCodeActual} {set bModProg TRUE}
   }
   if {$bAdd || $bModProg} {
      if {$bJPO} {
         pMqlCmd \"insert prog \\042$sProgramFilePlan\\042\"
      } else {
         pMqlCmd \"mod program \\042$aCol(0)\\042 file \\042$sSpinDir/Business/SourceFiles/$sProgramFile\\042\"
      }
   }
   return 0
}" 1 0 0 0 0 0 0 0 0 0 0 0 "" 0 0
 0 1
 SpinnerAgent NULL noname "3/27/2017 3:41:28 PM" 0
"12/6/2015 11:42:58 PM" "3/14/2018 3:57:25 PM"
7
 0 1 "12/6/2015 11:42:58 PM" creator "add program emxSpinnerProgram.tcl mql execute immediate !needsbusinessobject !downloadable !pipe !pooled nothidden file ./Business/SourceFiles/emxSpinnerProgram.tcl"
 0 2 "12/6/2015 11:42:58 PM" creator "add property SpinnerAgent on program emxSpinnerProgram.tcl value '12/6/2015 11:42:58 PM'"
 0 2 "12/6/2015 11:42:58 PM" creator "mod program emxSpinnerProgram.tcl description ''"
 0 2 "2/3/2016 5:21:01 PM" creator "mod property SpinnerAgent on program emxSpinnerProgram.tcl value '2/3/2016 5:21:01 PM'"
 0 2 "2/3/2016 5:21:01 PM" creator "mod program emxSpinnerProgram.tcl file ./Business/SourceFiles/emxSpinnerProgram.tcl"
 0 2 "3/27/2017 3:41:28 PM" creator "mod property SpinnerAgent on program emxSpinnerProgram.tcl value '3/27/2017 3:41:28 PM'"
 0 2 "3/27/2017 3:41:28 PM" creator "mod program emxSpinnerProgram.tcl file ./Business/SourceFiles/emxSpinnerProgram.tcl"

!MTRX!END

!MTRX!AD! program emxSpinnerUser.tcl "3DEXPERIENCE R2015x(24.0.0.0)"
emxSpinnerUser.tcl 0 "" "#########################################################################*10.61
#
# @progdoc      emxSpinnerUser.tcl vM10.58 (Build 6.10.12)
#
# @Description: Procedures for running in Roles, Groups and Associations
#
# @Parameters:  Returns 0 if successful, 1 if not
#
# @Usage:       Utilized by emxSpinnerAgent.tcl
#
# @progdoc      Copyright (c) MatrixOne Inc. 2005
#
#########################################################################
#
# @Modifications: FirstName LastName MM/DD/YYYY - Modification
#
#########################################################################

# Procedure to add or remove role/group parent or site
proc pAddDelParentSite {sSchemaType sSchemaName sParentSite sParentSiteName sGroupRoleSite iRange} {
   if {$sParentSiteName != \"\"} {
      pMqlCmd \"mod $sSchemaType \\042$sSchemaName\\042 $sParentSite \\042$sParentSiteName\\042\"
   } else {
      set lsSelect [split [pQuery \"\" \"print $sSchemaType \\042$sSchemaName\\042\"] \\n]
      foreach sSelect $lsSelect {
         set sSelect [string trim $sSelect]
         if {[string range $sSelect 0 $iRange] == $sParentSite} {
            pMqlCmd \"add $sGroupRoleSite DeleteThisElement\"
            pMqlCmd \"mod $sSchemaType \\042$sSchemaName\\042 $sParentSite DeleteThisElement\"
            pMqlCmd \"delete $sGroupRoleSite DeleteThisElement\"
            break
         }
      }
   }
}

# Procedure to analyze roles and groups
proc pAnalyzeUser {} {
   global aCol aDat bOverlay bAdd lsParentRolePlan lsParentRoleActual slsParentRoleActual lsChildRolePlan lsChildRoleActual lsAssignmentPlan lsAssignmentActual sSchemaType bUseAssignmentField sParentChild
   set lsParentRolePlan [lsort [pTrimList $aCol(3)]]
   set aCol(3) [join $lsParentRolePlan \",\"]
   set lsChildRolePlan [pTrimList $aCol(4)]
   set lsChildRolePlan [pCheckNameChange $lsChildRolePlan $sSchemaType]
   set lsAssignmentPlan [pTrimList $aCol(5)]
   set slsParentRoleActual \"\" 
   set lsChildRoleActual [list ]
   set lsAssignmentActual [list ]
   if {$bAdd != \"TRUE\"} {
      set aDat(6) \"\"
      set lsSiteActualTemp [split [pQuery \"\" \"print $sSchemaType \\042$aCol(0)\\042\"] \\n]
      foreach sSiteTemp $lsSiteActualTemp {
         set sSiteTemp [string trim $sSiteTemp]
         if {[string first \"site\" $sSiteTemp] == 0} {
            regsub \"site \" $sSiteTemp \"\" aDat(6)
            break
         }
      }
      set lsParentRoleActual [lsort [pPrintQuery \"\" parent | spl]]
      set slsParentRoleActual [join $lsParentRoleActual \",\"]
      set lsChildRoleActual [pPrintQuery \"\" child | spl]
      set lsAssignmentActual [list ]
      if {$bUseAssignmentField} {
         set lsAssignmentTemp [pPrintQuery \"\" assignment | spl]
         regsub -all \"\\134\\050\" $aCol(0) \"\\134\\050\" sTestName
         regsub -all \"\\134\\051\" $sTestName \"\\134\\051\" sTestName
         foreach sAssignment $lsAssignmentTemp {
            regsub \"$sTestName\\ \" $sAssignment \"\" sAssignment
            lappend lsAssignmentActual [string trim $sAssignment]
         }
      }
   }
   if {$bOverlay} {
      set aCol(3) [pOverlayList $aCol(3) $slsParentRoleActual]
      set lsChildRolePlan [pOverlayList $lsChildRolePlan $lsChildRoleActual]
      set lsAssignmentPlan [pOverlayList $lsAssignmentPlan $lsAssignmentActual]
   }
}

# Procedure to process roles and groups
proc pProcessUser {} {
   global aCol aDat bAdd lsParentRolePlan lsParentRoleActual slsParentRoleActual lsChildRolePlan lsChildRoleActual lsAssignmentPlan lsAssignmentActual sHidden sHiddenActual bUseAssignmentField sParentChild sSchemaType
   if {$bAdd} {
      pMqlCmd \"add $sSchemaType \\042$aCol(0)\\042 $sHidden\"
      if {$aCol(3) != \"\" && $sParentChild == \"parent\"} {pMqlCmd \"mod $sSchemaType \\042$aCol(0)\\042 parent \\042$aCol(3)\\042\"}
      if {$aCol(6) != \"\"} {pMqlCmd \"mod $sSchemaType \\042$aCol(0)\\042 site \\042$aCol(6)\\042\"}
      if {$sParentChild != \"parent\"} {pPlanAdd $lsChildRolePlan $sSchemaType $aCol(0) \"child\" \"\"}
      if {$bUseAssignmentField} {pPlanAdd $lsAssignmentPlan $sSchemaType $aCol(0) \"assign person\" \"\"}
   } else {
      if {$sHidden != $sHiddenActual} {pMqlCmd \"mod $sSchemaType \\042$aCol(0)\\042 $sHidden\"}
      if {$aCol(3) != $slsParentRoleActual && $sParentChild == \"parent\"} {pAddDelParentSite $sSchemaType $aCol(0) parent $aCol(3) $sSchemaType 5}
      if {$aCol(6) != $aDat(6)} {pAddDelParentSite $sSchemaType $aCol(0) site $aCol(3) site 3}
      if {$bUseAssignmentField} {pPlanActualAddDel $lsAssignmentActual \"\" $lsAssignmentPlan $sSchemaType \"\" $aCol(0) \"remove assign person\" \"assign person\" \"\"}
      if {$sParentChild != \"parent\"} {pPlanActualAddDel $lsChildRoleActual \"\" $lsChildRolePlan $sSchemaType \"\" $aCol(0) \"remove child\" \"child\" \"\"}
   }
   return 0
}

# Procedure to analyze associations
proc pAnalyzeAssociation {} {
   global aCol aDat bAdd sDefinition sDefinitionTest sDefinitionActual sHiddenActual sDescriptionActual
   set lsDefinition [split $aCol(3) |]
   set sDefinition \"\"
   set sDefinitionTest \"\"
   foreach sDefinitionTemp $lsDefinition {
      set bAndOr FALSE
      set sDefinitionTemp [string trim $sDefinitionTemp]
      if {[string tolower $sDefinitionTemp] == \"or\"} {
         set sDefinitionTemp \" || \"
         set bAndOr TRUE
      } elseif {[string tolower $sDefinitionTemp] == \"and\"} {
         set sDefinitionTemp \" && \"
         set bAndOr TRUE
      }
      if {$bAndOr} {
         append sDefinition $sDefinitionTemp
         append sDefinitionTest $sDefinitionTemp
      } else {
         append sDefinition \"\\042$sDefinitionTemp\\042\"
         append sDefinitionTest $sDefinitionTemp
      }
   }
   regsub -all \"\\042\" $sDefinitionTest \"\" sDefinitionTest
   regsub -all \"\\042\" $sDefinition \"\\134\\042\" sDefinition
   if {$bAdd != \"TRUE\"} {
      set sDefinitionActual \"\"
      set sHiddenActual \"\"
      set lsPrint [split [pQuery \"\" \"print association \\042$aCol(0)\\042\"] \\n]
      foreach sPrint $lsPrint {
         set sPrint [string trim $sPrint]
         if {[string first \"description\" $sPrint] == 0} {
            regsub \"description\" $sPrint \"\" sDescriptionActual
            set sDescriptionActual [string trim $sDescriptionActual]
         } elseif {[string first \"definition\" $sPrint] == 0} {
            regsub \"definition\" $sPrint \"\" sDefinitionActual
            regsub -all \"\\042\" $sDefinitionActual \"\" sDefinitionActual
            set sDefinitionActual [string trim $sDefinitionActual]
         } elseif {$sPrint == \"hidden\"} {
            set sHiddenActual hidden
         } elseif {$sPrint == \"nothidden\"} {
            set sHiddenActual nothidden
         }
      }
   }
}                                       

# Procedure to process associations
proc pProcessAssociation {} {
   global aCol bAdd sDefinition sDefinitionTest sDefinitionActual sHidden sHiddenActual
   if {$bAdd} {
      pMqlCmd \"add association \\042$aCol(0)\\042 definition '$sDefinition' $sHidden\"
   } elseif {$sDefinitionTest != $sDefinitionActual || $sHidden != $sHiddenActual} {
      pMqlCmd \"escape mod association \\042$aCol(0)\\042 definition '$sDefinition' $sHidden\"
   }
   return 0
}
" 1 0 0 0 0 0 0 0 0 0 0 0 "" 0 0
 0 1
 SpinnerAgent NULL noname "3/27/2017 3:41:28 PM" 0
"12/6/2015 11:42:58 PM" "3/14/2018 3:57:25 PM"
7
 0 1 "12/6/2015 11:42:58 PM" creator "add program emxSpinnerUser.tcl mql execute immediate !needsbusinessobject !downloadable !pipe !pooled nothidden file ./Business/SourceFiles/emxSpinnerUser.tcl"
 0 2 "12/6/2015 11:42:58 PM" creator "add property SpinnerAgent on program emxSpinnerUser.tcl value '12/6/2015 11:42:58 PM'"
 0 2 "12/6/2015 11:42:58 PM" creator "mod program emxSpinnerUser.tcl description ''"
 0 2 "2/3/2016 5:21:01 PM" creator "mod property SpinnerAgent on program emxSpinnerUser.tcl value '2/3/2016 5:21:01 PM'"
 0 2 "2/3/2016 5:21:01 PM" creator "mod program emxSpinnerUser.tcl file ./Business/SourceFiles/emxSpinnerUser.tcl"
 0 2 "3/27/2017 3:41:28 PM" creator "mod property SpinnerAgent on program emxSpinnerUser.tcl value '3/27/2017 3:41:28 PM'"
 0 2 "3/27/2017 3:41:28 PM" creator "mod program emxSpinnerUser.tcl file ./Business/SourceFiles/emxSpinnerUser.tcl"

!MTRX!END

!MTRX!AD! program emxSpinnerAttribute.tcl "3DEXPERIENCE R2015x(24.0.0.0)"
emxSpinnerAttribute.tcl 0 "" "#########################################################################*10.80
#
# @progdoc      emxSpinnerAttribute.tcl vM10.80 (Build 8.3.31)
#
# @Description: Procedures for running in Attributes
#
# @Parameters:  Returns 0 if successful, 1 if not
#
# @Usage:       Utilized by emxSpinnerAgent.tcl
#
# @progdoc      Copyright (c) MatrixOne Inc. 2005
#
#########################################################################
#
# @Modifications: FirstName LastName MM/DD/YYYY - Modification
#
#########################################################################

# Procedure to reverse range order for input
   proc pRevOrderRange {} {
      global aCol lsRangePlan lsRangeValuePlan
      set lsRangePlanReverse [list ]
      set lsRangeValuePlanReverse [list ]
      for {set i [expr [llength $lsRangeValuePlan] -1]} {$i >= 0} {incr i -1} {
         lappend lsRangePlanReverse [lindex $lsRangePlan $i]
         lappend lsRangeValuePlanReverse [lindex $lsRangeValuePlan $i]
      }
      set lsRangePlan $lsRangePlanReverse
      set lsRangeValuePlan $lsRangeValuePlanReverse
   }

# Procedure to add and remove range values
   proc pAddDelAttrRange {sRange sRangeValue sAddMod} {
      global sAppendRange sVal1 sIncExc1 sVal2 sIncExc2
      if {[string first \"program\" $sRange] != \"-1\"} {
         regsub \"program \" $sRange \"\" sProgRange
         set sInput \"\"
         set iWith [string first \"with input\" $sProgRange]
         if {$iWith != \"-1\"} {
            set iProgEnd [expr $iWith -2]
            set sInput [string range $sProgRange $iWith end]
            regsub \"with input \" $sInput \"\" sInput
            set sInput [pRegSubEvalEscape $sInput]
            set sInput [string trim $sInput]
            set sProgRange [string range $sProgRange 0 $iProgEnd]
         }
         append sAppendRange \" $sAddMod program \\042$sProgRange\\042\"
         if {$sAddMod == \"add\"} {append sAppendRange \" input \\042$sInput\\042\"}
      } elseif {$sRangeValue == \"between\"} {
         set lsBetween [split $sRange \" \"]
         set sVal1 [lindex $lsBetween 0]
         set sIncExc1 [lindex $lsBetween 1]
         set sVal2 [lindex $lsBetween 2]
         set sIncExc2 [lindex $lsBetween 3]
         append sAppendRange \" $sAddMod range $sRangeValue \\042$sVal1\\042 $sIncExc1 \\042$sVal2\\042 $sIncExc2\"
      } else {
         set sRange [pRegSubEvalEscape $sRange]
# Bug fix 313705
         # regsub -all \"\\134\\042\" $sRange \"\\134\\134\\134\\042\" sRange
         append sAppendRange \" $sAddMod range $sRangeValue \\042$sRange\\042\"
      }
   }

# Procedure to analyze attributes
proc pAnalyzeAttribute {} {
   global aCol aDat bOverlay bAdd sRangeDelim lsRangeValue lsRangePlan lsRangeValuePlan lsRangeActual lsRangeValueActual sMxVersion
   set aCol(2) [string tolower $aCol(2)]
   if {[string first \"date\" $aCol(2)] >= 0} {set aCol(2) timestamp} 
   if {[string tolower $aCol(4)] == \"'true\" || [string tolower $aCol(4)] == \"'false\"} {regsub -all \"\\047\" $aCol(4) \"\" aCol(4)}
   regsub -all \"<SPACE>\" $aCol(4) \" \" aCol(4)
   set lsRangePlan [list ]
   set lsRangeValuePlan [list ]
   set sSplit $sRangeDelim
   if {[string first \"uses prog\" $aCol(5)] >= 0 || [string first \"uses <<prog\" $aCol(5)] >= 0} {
      regsub -all \" \\134| \" $aCol(5) \" ~ \" aCol(5)
      set sSplit \"~\"
   }
   set lsRangePlanTemp [split $aCol(5) $sSplit]
   foreach sRangePlan $lsRangePlanTemp {
      set sRangePlan [string trim $sRangePlan]
      set bFoundValue FALSE
      set bNull FALSE
      set bLeftTag FALSE
      if {[string first \"<<\" $sRangePlan] == 0} {
         regsub \"<<\" $sRangePlan \"\" sRangePlan
         set sRangePlan [string trim $sRangePlan]
         set bLeftTag TRUE
      }
      regsub -all \"  \" $sRangePlan \" \" sRangePlan
      regsub -all \"<SPACE>\" $sRangePlan \" \" sRangePlan
      if {[regsub -all \"<NULL>\" $sRangePlan \"\" sRangePlan]} {set bNull TRUE}
      foreach sRangeValue $lsRangeValue {
         if {[string first $sRangeValue $sRangePlan] == 0} {
            regsub \"$sRangeValue\" $sRangePlan \"\" sRangePlan
            set sRangePlan [string trim $sRangePlan]
            lappend lsRangeValuePlan $sRangeValue
            set bFoundValue TRUE
            break
         }
      }
      if {$bFoundValue == \"FALSE\"} {lappend lsRangeValuePlan \"=\"}
      if {$bLeftTag} {set sRangePlan \"<<$sRangePlan\"}
      lappend lsRangePlan $sRangePlan
   }
   set aCol(6) [pCompareAttr [string tolower $aCol(6)] notmultiline multiline true true]
   set lsRangeValueActual [list ]
   set lsRangeActual [list ]
   if {$bAdd != \"TRUE\"} {
      set aDat(2) [pPrintQuery \"\" type \"\" \"\"]
      set bMultilineActual [pPrintQuery FALSE multiline \"\" \"\"]
      set aDat(4) [pPrintQuery \"\" default \"\" \"\"]
      set aDat(6) [pCompareAttr $bMultilineActual notmultiline multiline true false]
      set lsRangeActualTemp [split [mql print attr $aCol(0)] \\n]
      foreach sRangeActual $lsRangeActualTemp {
         if {[string first \"  range \" $sRangeActual] == 0} {
            regsub \"  range \" $sRangeActual \"\" sRangeActual
            foreach sRangeValue $lsRangeValue {
               if {[string first $sRangeValue $sRangeActual] == 0} {
                  regsub \"$sRangeValue\" $sRangeActual \"\" sRangeActual
                  if {$sRangeActual == \"  \"} {
                     set sRangeActual \" \"
                  } else {
                     set sRangeActual [string trim $sRangeActual]
                  }
                  lappend lsRangeValueActual $sRangeValue
                  break
               }
            }
            lappend lsRangeActual $sRangeActual
         }
      }
      if {$sMxVersion >= 10.8} {set aDat(8) [pPrintQuery \"\" dimension \"\" \"\"]} 
   }
   if {$bOverlay} {
      if {$sMxVersion >= 10.8} { 
         pOverlay [list 2 4 6 8]
      } else {
         pOverlay [list 2 4 6]
      }
      if {$lsRangePlan == \"\\{\\}\" && $bNull} {
         set lsRangeValuePlan [list ]
         set lsRangePlan [list ]
      } elseif {$lsRangePlan == \"\"} {
         set lsRangePlan $lsRangeActual
         set lsRangeValuePlan $lsRangeValueActual
      } elseif {[lsort $lsRangePlan] == [lsort $lsRangeActual] && [lsort $lsRangeValuePlan] == [lsort $lsRangeValueActual]} {
      } else {
      	 set lsPlanTest [list ]
      	 set lsActualTest [list ]
         foreach sRangeValuePlan $lsRangeValuePlan sRangePlan $lsRangePlan {lappend lsPlanTest \"$sRangeValuePlan\\^$sRangePlan\"}
         foreach sRangeValueActual $lsRangeValueActual sRangeActual $lsRangeActual {lappend lsActualTest \"$sRangeValueActual\\^$sRangeActual\"}
            set lsPlanTest [lindex [pMergeList $lsPlanTest \"\" $lsActualTest \"\" ATTR] 0]
            set lsRangeValuePlan [list ]
            set lsRangePlan [list ]
         foreach sPlan $lsPlanTest {
            set lsPlan [split $sPlan ^]
            lappend lsRangeValuePlan [lindex $lsPlan 0]
            lappend lsRangePlan [lindex $lsPlan 1]
         }
      }
   }
}

# Procedure to process attributes
proc pProcessAttribute {} {
   global aCol aDat bAdd lsRangePlan lsRangeValuePlan lsRangeActual lsRangeValueActual sHidden sHiddenActual sAppendRange sVal1 sIncExc1 sVal2 sIncExc2 bRegister sModName bChangeAttrType bOut bDelAddAttr sMxVersion
   set iExit 0
   set bDelFlag FALSE
   set bWarnAttr FALSE
   if {$bAdd != \"TRUE\"} {
      if {$bDelAddAttr && [pPrintQuery \"\" \"property\\134\\133SpinnerDelAddAttr\\134\\135.value\" \"\" \"\"] != \"TRUE\"} {
         set bDelFlag TRUE
      } elseif {$bChangeAttrType && $aCol(2) != $aDat(2)} {
         set bDelFlag TRUE
      } elseif {$aCol(2) != $aDat(2)} {
         set bWarnAttr TRUE
      }
   }
   if {$bDelFlag} {
      pMqlCmd \"delete attr \\042$aCol(0)\\042\"
      set bAdd TRUE
      if {$aCol(1) != \"\" && $aCol(1) != \"<NULL>\"} {
      	 if {$sModName != $aCol(0)} {set aCol(0) $sModName}
         set bRegister TRUE
      } else {
      	 set bRegister FALSE
      }
   } elseif {$bWarnAttr} {
   	  set sWarningMsg \"WARNING: Attribute '$aCol(0)' type '$aCol(2)' cannot be changed to '$aDat(2)' as program setting 'bChangeAttrType' is set to 'FALSE'\"
      pWriteWarningMsg \"\\n$sWarningMsg\"
   }   
   set sAppendRange \"\"
   if {$bAdd} {
      set aCol(4) [pRegSubEvalEscape $aCol(4)]
      pMqlCmd \"escape add attr \\042$aCol(0)\\042 type $aCol(2) default \\042$aCol(4)\\042 $aCol(6) $sHidden\"
      if {$lsRangePlan != \"\"} {
         pRevOrderRange
         foreach sRange $lsRangePlan sRangeValue $lsRangeValuePlan {pAddDelAttrRange $sRange $sRangeValue add}
         if {$sAppendRange != \"\"} {pMqlCmd \"escape mod attribute \\042$aCol(0)\\042$sAppendRange\"}
      }
      if {$sMxVersion >= 10.8 && $aCol(8) != \"\"} {pMqlCmd \"mod attr \\042$aCol(0)\\042 add dimension \\042$aCol(8)\\042\"}
      if {$bDelAddAttr} {pMqlCmd \"add property SpinnerDelAddAttr on attribute \\042$aCol(0)\\042 value TRUE\"}
   } else {
      if {$aCol(4) != $aDat(4) || $aCol(6) != $aDat(6) || $sHidden != $sHiddenActual} {
         set aCol(4) [pRegSubEvalEscape $aCol(4)]
         pMqlCmd \"escape mod attr \\042$aCol(0)\\042 default \\042$aCol(4)\\042 $aCol(6) $sHidden\"
      }
      if {$lsRangePlan != $lsRangeActual || $lsRangeValuePlan != $lsRangeValueActual} {
         if {$lsRangeActual != \"\"} {foreach sRangeA $lsRangeActual sRangeValueA $lsRangeValueActual {pAddDelAttrRange $sRangeA $sRangeValueA remove}}
         if {$lsRangePlan != \"\"} {
            pRevOrderRange
            foreach sRange $lsRangePlan sRangeValue $lsRangeValuePlan {pAddDelAttrRange $sRange $sRangeValue add}
         }
         if {$sAppendRange != \"\"} {pMqlCmd \"escape mod attribute \\042$aCol(0)\\042$sAppendRange\"}
      }
      if {$sMxVersion >= 10.8 && $aCol(8) != $aDat(8)} {
         if {$aCol(8) == \"\"} {
            pMqlCmd \"mod attr \\042$aCol(0)\\042 remove dimension \\042$aDat(8)\\042\"
         } else {
            pMqlCmd \"mod attr \\042$aCol(0)\\042 dimension \\042$aCol(8)\\042\"
         }
      }
   }
   return $iExit
}
" 1 0 0 0 0 0 0 0 0 0 0 0 "" 0 0
 0 1
 SpinnerAgent NULL noname "3/27/2017 3:41:28 PM" 0
"12/6/2015 11:42:58 PM" "3/14/2018 3:57:25 PM"
7
 0 1 "12/6/2015 11:42:58 PM" creator "add program emxSpinnerAttribute.tcl mql execute immediate !needsbusinessobject !downloadable !pipe !pooled nothidden file ./Business/SourceFiles/emxSpinnerAttribute.tcl"
 0 2 "12/6/2015 11:42:58 PM" creator "add property SpinnerAgent on program emxSpinnerAttribute.tcl value '12/6/2015 11:42:58 PM'"
 0 2 "12/6/2015 11:42:58 PM" creator "mod program emxSpinnerAttribute.tcl description ''"
 0 2 "2/3/2016 5:21:01 PM" creator "mod property SpinnerAgent on program emxSpinnerAttribute.tcl value '2/3/2016 5:21:01 PM'"
 0 2 "2/3/2016 5:21:01 PM" creator "mod program emxSpinnerAttribute.tcl file ./Business/SourceFiles/emxSpinnerAttribute.tcl"
 0 2 "3/27/2017 3:41:28 PM" creator "mod property SpinnerAgent on program emxSpinnerAttribute.tcl value '3/27/2017 3:41:28 PM'"
 0 2 "3/27/2017 3:41:28 PM" creator "mod program emxSpinnerAttribute.tcl file ./Business/SourceFiles/emxSpinnerAttribute.tcl"

!MTRX!END

!MTRX!AD! program emxSpinnerType.tcl "3DEXPERIENCE R2015x(24.0.0.0)"
emxSpinnerType.tcl 0 "" "#########################################################################*10.58
#
# @progdoc      emxSpinnerType.tcl vM10.58 (Build 5.1.12)
#
# @Description: Procedures for running in Types
#
# @Parameters:  Returns 0 if successful, 1 if not
#
# @Usage:       Utilized by emxSpinnerAgent.tcl
#
# @progdoc      Copyright (c) MatrixOne Inc. 2005
#
#########################################################################
#
# @Modifications: FirstName LastName MM/DD/YYYY - Modification
#
#########################################################################

# Procedure to check for and remove same methods on derivative types
   proc pDeleteMethod {sSchName sMethod} {
      set sDerived [pQuery \"\" \"print type \\042$sSchName\\042 select derived dump\"]
      if {$sDerived != \"\" && [lsearch [split [pQuery \"\" \"print type \\042$sDerived\\042 select method dump |\"] |] $sMethod] > -1} {
         pMqlCmd \"mod type \\042$sSchName\\042 remove method \\042$sMethod\\042\"
      } else {
         set lsDerivative [split [pQuery \"\" \"print type \\042$sSchName\\042 select derivative dump |\"] |]
         foreach sDerivative $lsDerivative {
            set slsMethodTest [pQuery \"\" \"print type \\042$sDerivative\\042 select method dump |\"]
            if {[regsub -all \"$sMethod\" $slsMethodTest \"\" slsMethodTest] > 1} {pMqlCmd \"mod type \\042$sDerivative\\042 remove method \\042$sMethod\\042\"}
         }
      }
   }

# Procedure to analyze types
proc pAnalyzeType {} {
   global aCol aDat lsSchemaType lsAttributePlan lsAttributeActual lsAttrImmediate lsMethodPlan lsMethodActual lsMethodDerivative bOverlay bAdd
   if {$aCol(2) != \"\"} {set aCol(2) [pCheckNameChange $aCol(2) type]}
   set aCol(3) [pCompareAttr $aCol(3) false true abstract true]
   set lsAttributePlan [pTrimList $aCol(5)]
   if {[lsearch $lsSchemaType attribute] >= 0} {set lsAttributePlan [pCheckNameChange $lsAttributePlan attribute]}
   set lsMethodPlan [pTrimList $aCol(6)]
   set aCol(8) [pCompareAttr $aCol(8) false true sparse true]
   set lsMethodActual [list ]
   set lsAttributeActual [list ]
   if {$bAdd != \"TRUE\"} {
      set aDat(8) [pPrintQuery \"\" sparse \"\" str]
      set aDat(8) [pCompareAttr $aDat(8) false true true false]
      set lsPrint [split [pQuery \"\" \"print type \\042$aCol(0)\\042\"] \\n]
      set aDat(3) false
      foreach sPrint $lsPrint {
         set sPrint [string trim $sPrint]
         if {[string range $sPrint 0 7] == \"abstract\"} {
            regsub \"abstract \" $sPrint \"\" aDat(3)
            set aDat(3) [string tolower $aDat(3)]
            break
         }
      }
      set aDat(2) [pPrintQuery \"\" derived \"\" \"\"]
      set lsAttributeActual [pPrintQuery \"\" attribute | spl]
# Begin fix to check for change of derived type retaining attributes from previous type  - MJO 1/30/2007 
      if {$aCol(2) != \"\" && $aCol(2) != $aDat(2) && [string tolower $aCol(2)] != \"<null>\"} {
         if {$lsAttributePlan != {}} {
            foreach sAttributePlan $lsAttributePlan {
               if {[string first \"<<\" $sAttributePlan] < 0 && [string tolower $sAttributePlan] != \"<null>\"} {
                  if {[lsearch $lsAttributeActual $sAttributePlan] < 0} {
                     continue
                  } else {
                     if {[mql list type $aCol(2)] != \"\"} {
                        set lsAttributeActual [split [mql print type \"$aCol(2)\" select attribute dump |] |]
                     }
                     break
                  }
               }
            }
         }
      }
# End fix
      set lsAttrImmediate [pPrintQuery \"\" immediateattribute | spl]
      set lsMethodActual [pPrintQuery \"\" method | spl]
      if {$aDat(2) != \"\"} {
         set lsMethodDerived [split [pQuery \"\" \"print type \\042$aDat(2)\\042 select method dump |\"] |]
         set lsMethodDerivative [list ]
         foreach sMethod $lsMethodActual {if {[lsearch $lsMethodDerived $sMethod] < 0} {lappend lsMethodDerivative $sMethod}}
      } else {
         set lsMethodDerivative $lsMethodActual
      }
   }
   if {$bOverlay} {
      pOverlay [list 2 3 8]
      set lsMethodPlan [pOverlayList $lsMethodPlan $lsMethodActual]
      set lsAttributePlan [pOverlayList $lsAttributePlan $lsAttributeActual]
   }
}

# Procedure to process types
proc pProcessType {} {
   global aCol aDat bAdd lsAttributePlan lsAttributeActual lsAttrImmediate lsMethodPlan lsMethodActual lsMethodDerivative bSkipElement resultappend sHidden sHiddenActual bUpdate bSkipElement bReg
   set iExit 0
   if {$bAdd} {
      regsub -all \" \" $aCol(2) \"\" sDeleteTest
      if {[string tolower $sDeleteTest] != \"deletethistype\"} {
         pMqlCmd \"add type \\042$aCol(0)\\042 abstract $aCol(3) $sHidden sparse $aCol(8)\"
         if {$aCol(2) != \"\"} {pMqlCmd \"mod type \\042$aCol(0)\\042 derived \\042$aCol(2)\\042\"}
         set sAppend \"\"
         foreach sAttr $lsAttributePlan {if {[pPrintQuery FALSE \"attribute\\133$sAttr\\135\" \"\" \"\"] == \"FALSE\"} {append sAppend \" add attribute \\042$sAttr\\042\"}}
         if {$sAppend != \"\"} {pMqlCmd \"mod type \\042$aCol(0)\\042$sAppend\"}
         pPlanAdd $lsMethodPlan type $aCol(0) \"add method\" \"\"
         foreach sMethodP $lsMethodPlan {pDeleteMethod $aCol(0) $sMethodP}
      } else {
         pAppend \"# add type \\042$aCol(0)\\042 skipped as the parent is \\042$aCol(2)\\042\" FALSE
         set bUpdate FALSE
         set bReg FALSE
         set bSkipElement TRUE
      }
   } else {
      if {$aCol(3) != $aDat(3) || $sHidden != $sHiddenActual || $aCol(8) != $aDat(8)} {pMqlCmd \"escape mod type \\042$aCol(0)\\042 abstract $aCol(3) $sHidden sparse $aCol(8)\"}
      regsub -all \" \" $aCol(2) \"\" sTopLevelTest
      if {[string tolower $sTopLevelTest] == \"toplevelplaceholder\" && $aDat(2) == \"\"} {
         set bReg FALSE
         set bSkipElement TRUE
      } elseif {$aCol(2) != \"\" && $aCol(2) != $aDat(2)} {
         pMqlCmd \"mod type \\042$aCol(0)\\042 derived \\042$aCol(2)\\042\"
      } elseif {$aCol(2) == \"\" && $aDat(2) != \"\"} {
         set resultappend \"ERROR: Type '$aCol(0)' derived type '$aDat(2)' may not be set back to <null> !\\nTo disassociate '$aCol(0)' from '$aDat(2)', set derived type to 'Top Level Placeholder'\"
         set iExit 1
         return $iExit
      }
      pPlanActualAddDel $lsAttrImmediate $lsAttributeActual $lsAttributePlan type \"\" $aCol(0) \"remove attribute\" \"add attribute\" \"\"
      pPlanActualAddDel $lsMethodDerivative $lsMethodActual $lsMethodPlan type \"\" $aCol(0) \"remove method\" \"add method\" \"\"
   }
   return $iExit
}" 1 0 0 0 0 0 0 0 0 0 0 0 "" 0 0
 0 1
 SpinnerAgent NULL noname "3/27/2017 3:41:28 PM" 0
"12/6/2015 11:42:58 PM" "3/14/2018 3:57:25 PM"
7
 0 1 "12/6/2015 11:42:58 PM" creator "add program emxSpinnerType.tcl mql execute immediate !needsbusinessobject !downloadable !pipe !pooled nothidden file ./Business/SourceFiles/emxSpinnerType.tcl"
 0 2 "12/6/2015 11:42:58 PM" creator "add property SpinnerAgent on program emxSpinnerType.tcl value '12/6/2015 11:42:58 PM'"
 0 2 "12/6/2015 11:42:58 PM" creator "mod program emxSpinnerType.tcl description ''"
 0 2 "2/3/2016 5:21:01 PM" creator "mod property SpinnerAgent on program emxSpinnerType.tcl value '2/3/2016 5:21:01 PM'"
 0 2 "2/3/2016 5:21:01 PM" creator "mod program emxSpinnerType.tcl file ./Business/SourceFiles/emxSpinnerType.tcl"
 0 2 "3/27/2017 3:41:28 PM" creator "mod property SpinnerAgent on program emxSpinnerType.tcl value '3/27/2017 3:41:28 PM'"
 0 2 "3/27/2017 3:41:28 PM" creator "mod program emxSpinnerType.tcl file ./Business/SourceFiles/emxSpinnerType.tcl"

!MTRX!END

!MTRX!AD! program emxSpinnerRelationship.tcl "3DEXPERIENCE R2015x(24.0.0.0)"
emxSpinnerRelationship.tcl 0 "" "#########################################################################*10.80
#
# @progdoc      emxSpinnerRelationship.tcl vM10.80 (Build 8.3.31)
#
# @Description: Procedures for running in Relationships
#
# @Parameters:  Returns 0 if successful, 1 if not
#
# @Usage:       Utilized by emxSpinnerAgent.tcl
#
# @progdoc      Copyright (c) MatrixOne Inc. 2005
#
#########################################################################
#
# @Modifications: FirstName LastName MM/DD/YYYY - Modification
#
#########################################################################

# Procedure to analyze relationships
proc pAnalyzeRelationship {} {
   global aCol aDat bOverlay bAdd sMxVersion lsAttributePlan lsAttributeActual lsFromTypePlan lsFromTypeActual lsFromRelPlan lsFromRelActual lsToTypePlan lsToTypeActual lsToRelPlan lsToRelActual lsSchemaType
   set lsAttributePlan [pTrimList $aCol(3)]
   if {[lsearch $lsSchemaType attribute] >= 0} {set lsAttributePlan [pCheckNameChange $lsAttributePlan attribute]}
   set aCol(4) [pCompareAttr $aCol(4) false true sparse true]
   set aCol(6) [pCompareAttr $aCol(6) !preventduplicates preventduplicates true true]
   foreach iFromTo [list 9 10 15 16] {
   	if {$bOverlay && $aCol($iFromTo) == \"\"} {
      } elseif {[string tolower $aCol($iFromTo)] == \"none\" || ( [string tolower $aCol($iFromTo)] != \"float\" && [string tolower $aCol($iFromTo)] != \"replicate\" ) } {
         set aCol($iFromTo) none
      } elseif {[string tolower $aCol($iFromTo)] == \"float\"} {
         set aCol($iFromTo) float
      } else {
         set aCol($iFromTo) replicate
      }
   }
   foreach iCol [list 11 17] {set aCol($iCol) [pCompareAttr $aCol($iCol) n 1 one true]}
   foreach iCol [list 12 18] {set aCol($iCol) [pCompareAttr $aCol($iCol) notpropagatemodify propagatemodify true true]}
   set lsFromTypePlan [pTrimList $aCol(7)]
   set lsToTypePlan [pTrimList $aCol(13)]
   if {$sMxVersion >= 10.8} { 
      set lsFromRelPlan [pTrimList $aCol(8)]
      set lsToRelPlan [pTrimList $aCol(14)]
   }
   if {[lsearch $lsSchemaType type] >= 0} {
      set lsFromTypePlan [pCheckNameChange $lsFromTypePlan type]
      set lsToTypePlan [pCheckNameChange $lsToTypePlan type]
   }
   if {$sMxVersion >= 10.8} {
      set lsFromRelPlan [pCheckNameChange $lsFromRelPlan relationship]
      set lsToRelPlan [pCheckNameChange $lsToRelPlan relationship]
   }   
   if {$sMxVersion >= 10.5} {foreach iCol [list 19 20] {set aCol($iCol) [pCompareAttr $aCol($iCol) propagateconnection notpropagateconnection false true]}}
   set lsFromTypeActual [list ]
   set lsToTypeActual [list ]
   set lsFromRelActual [list ]
   set lsToRelActual [list ]
   set lsAttributeActual [list ]
   if {$bAdd != \"TRUE\"} {
      set aDat(4) [pPrintQuery false sparse \"\" str]
      set aDat(6) [pPrintQuery false preventduplicates \"\" str]
      set aDat(6) [pCompareAttr $aDat(6) !preventduplicates preventduplicates true false]
      if {$sMxVersion >= 10.8} {
         foreach sDat [list 9 10 11 15 16 17] sPQ1 [list none none n none none n] sPQ2 [list fromreviseaction fromcloneaction fromcardinality toreviseaction tocloneaction tocardinality] {set aDat($sDat) [pPrintQuery $sPQ1 $sPQ2 \"\" \"\"]}
      } else {
         foreach sDat [list 8 9 10 11 14 15 16 17] sPQ1 [list \"\" none none n \"\" none none n] sPQ2 [list frommeaning fromreviseaction fromcloneaction fromcardinality tomeaning toreviseaction tocloneaction tocardinality] {set aDat($sDat) [pPrintQuery $sPQ1 $sPQ2 \"\" \"\"]}
      }
      foreach iDat [list 11 17] {set aDat($iDat) [pCompareAttr $aDat($iDat) n 1 one false]}
      set bFromPropModActual false
      set bToPropModActual] false
      if {[catch {set lsRel [split [mql print rel $aCol(0)] \\n]} sMsg] == 0} {
         set iCounter1 0
         foreach sRel $lsRel {
            set sRel [string trim $sRel]
            if {[string first \"propagate modify\" $sRel] == 0} {
               incr iCounter1
               set lslsRel [split $sRel \" \"]
               if {$iCounter1 == 1} {
                  set bFromPropModActual [lindex $lslsRel 2]
               } else {
                  set bToPropModActual [lindex $lslsRel 2]
               }
            }
            if {$iCounter1 > 1} {break}
         }
      }
      foreach iDat [list 12 18] {set aDat($iDat) [pCompareAttr $bFromPropModActual notpropagatemodify propagatemodify true false]}
      if {$sMxVersion >= 10.5} {
         foreach iCol [list 19 20] {set aCol($iCol) [pCompareAttr $aCol($iCol) propagateconnection notpropagateconnection false true]}
         set aDat(19) [pPrintQuery true frompropagateconnection \"\" str]
         set aDat(20) [pPrintQuery true topropagateconnection \"\" str]
         foreach iDat [list 19 20] {set aDat($iDat) [pCompareAttr $aDat($iDat) propagateconnection notpropagateconnection false false]}
      }
      set lsAttributeActual [pPrintQuery \"\" attribute | spl]
      set lsFromTypeActual [pPrintQuery \"\" fromtype | spl]
      set lsToTypeActual [pPrintQuery \"\" totype | spl]
      if {$sMxVersion >= 10.8} {
         set lsFromRelActual [pPrintQuery \"\" fromrel | spl]
         set lsToRelActual [pPrintQuery \"\" torel | spl]
      }
   }
   if {$bOverlay} {
      if {$sMxVersion >= 10.8} {
         pOverlay [list 4 6 9 10 11 12 15 16 17 18]
         set lsFromRelPlan [pOverlayList $lsFromRelPlan $lsFromRelActual]
         set lsToRelPlan [pOverlayList $lsToRelPlan $lsToRelActual]
      } else {
         pOverlay [list 4 6 8 9 10 11 12 14 15 16 17 18]
      }
      set lsFromTypePlan [pOverlayList $lsFromTypePlan $lsFromTypeActual]
      set lsToTypePlan [pOverlayList $lsToTypePlan $lsToTypeActual]
      set lsAttributePlan [pOverlayList $lsAttributePlan $lsAttributeActual]
      if {$sMxVersion >= 10.5} {pOverlay [list 19 20]}
   }
}

# Procedure to process relationships
proc pProcessRelationship {} {
   global aCol aDat bAdd lsAttributePlan lsAttributeActual lsFromTypePlan lsFromTypeActual lsToTypePlan lsToTypeActual lsFromRelPlan lsFromRelActual lsToRelPlan lsToRelActual sHidden sHiddenActual sMxVersion
   if {$bAdd} {
      pMqlCmd \"add relationship \\042$aCol(0)\\042 $sHidden $aCol(6) sparse $aCol(4) from cardinality $aCol(11) revision $aCol(9) clone $aCol(10) $aCol(12) to cardinality $aCol(17) revision $aCol(15) clone $aCol(16) $aCol(18)\"
      if {$sMxVersion < 10.8} {pMqlCmd \"mod relationship \\042$aCol(0)\\042 from meaning \\042$aCol(8)\\042 to meaning \\042$aCol(14)\\042\"}
      if {$sMxVersion >= 10.5} {pMqlCmd \"mod relationship \\042$aCol(0)\\042 from $aCol(19) to $aCol(20)\"}
      pPlanAdd $lsAttributePlan relationship $aCol(0) \"add attribute\" \"\"
      pPlanAdd $lsFromTypePlan relationship $aCol(0) \"from add type\" \"\"
      pPlanAdd $lsToTypePlan relationship $aCol(0) \"to add type\" \"\"
      if {$sMxVersion >= 10.8} { 
         pPlanAdd $lsFromRelPlan relationship $aCol(0) \"from add rel\" \"\"
         pPlanAdd $lsToRelPlan relationship $aCol(0) \"to add rel\" \"\"
      }
   } else {
      if {$sHidden != $sHiddenActual || $aCol(6) != $aDat(6) || $aCol(4) != $aDat(4) || $aCol(11) != $aDat(11) || $aCol(9) != $aDat(9) || $aCol(10) != $aDat(10) || $aCol(12) != $aDat(12) || $aCol(17) != $aDat(17) || $aCol(15) != $aDat(15) || $aCol(16) != $aDat(16) || $aCol(18) != $aDat(18)} {pMqlCmd \"mod relationship \\042$aCol(0)\\042 $sHidden $aCol(6) sparse $aCol(4) from cardinality $aCol(11) revision $aCol(9) clone $aCol(10) $aCol(12) to cardinality $aCol(17) revision $aCol(15) clone $aCol(16) $aCol(18)\"}
      if {$sMxVersion < 10.8 && ($aCol(8) != $aDat(8) || $aCol(14) != $aDat(14))} {pMqlCmd \"mod relationship \\042$aCol(0)\\042 from meaning \\042$aCol(8)\\042 to meaning \\042$aCol(14)\\042\"}
      if {$sMxVersion >= 10.5 && ($aCol(19) != $aDat(19) || $aCol(20) != $aDat(20))} {pMqlCmd \"mod relationship \\042$aCol(0)\\042 from $aCol(19) to $aCol(20)\"}
      pPlanActualAddDel $lsAttributeActual \"\" $lsAttributePlan relationship \"\" $aCol(0) \"remove attribute\" \"add attribute\" \"\"
      pPlanActualAddDel $lsFromTypeActual \"\" $lsFromTypePlan relationship \"\" $aCol(0) \"from remove type\" \"from add type\" \"\"
      pPlanActualAddDel $lsToTypeActual \"\" $lsToTypePlan relationship \"\" $aCol(0) \"to remove type\" \"to add type\" \"\"
      if {$sMxVersion >= 10.8} { 
         pPlanActualAddDel $lsFromRelActual \"\" $lsFromRelPlan relationship \"\" $aCol(0) \"from remove rel\" \"from add rel\" \"\"
         pPlanActualAddDel $lsToRelActual \"\" $lsToRelPlan relationship \"\" $aCol(0) \"to remove rel\" \"to add rel\" \"\"
      }
   }
   return 0
}
" 1 0 0 0 0 0 0 0 0 0 0 0 "" 0 0
 0 1
 SpinnerAgent NULL noname "3/27/2017 3:41:28 PM" 0
"12/6/2015 11:42:58 PM" "3/14/2018 3:57:25 PM"
7
 0 1 "12/6/2015 11:42:58 PM" creator "add program emxSpinnerRelationship.tcl mql execute immediate !needsbusinessobject !downloadable !pipe !pooled nothidden file ./Business/SourceFiles/emxSpinnerRelationship.tcl"
 0 2 "12/6/2015 11:42:58 PM" creator "add property SpinnerAgent on program emxSpinnerRelationship.tcl value '12/6/2015 11:42:58 PM'"
 0 2 "12/6/2015 11:42:58 PM" creator "mod program emxSpinnerRelationship.tcl description ''"
 0 2 "2/3/2016 5:21:01 PM" creator "mod property SpinnerAgent on program emxSpinnerRelationship.tcl value '2/3/2016 5:21:01 PM'"
 0 2 "2/3/2016 5:21:01 PM" creator "mod program emxSpinnerRelationship.tcl file ./Business/SourceFiles/emxSpinnerRelationship.tcl"
 0 2 "3/27/2017 3:41:28 PM" creator "mod property SpinnerAgent on program emxSpinnerRelationship.tcl value '3/27/2017 3:41:28 PM'"
 0 2 "3/27/2017 3:41:28 PM" creator "mod program emxSpinnerRelationship.tcl file ./Business/SourceFiles/emxSpinnerRelationship.tcl"

!MTRX!END

!MTRX!AD! program emxSpinnerFormat.tcl "3DEXPERIENCE R2015x(24.0.0.0)"
emxSpinnerFormat.tcl 0 "" "#########################################################################*10.58
#
# @progdoc      emxSpinnerFormat.tcl vM10.58 (Build 5.1.12)
#
# @Description: Procedures for running in Formats
#
# @Parameters:  Returns 0 if successful, 1 if not
#
# @Usage:       Utilized by emxSpinnerAgent.tcl
#
# @progdoc      Copyright (c) MatrixOne Inc. 2005
#
#########################################################################
#
# @Modifications: FirstName LastName MM/DD/YYYY - Modification
#
#########################################################################

# Procedure to analyze formats
proc pAnalyzeFormat {} {
   global aCol aDat bOverlay bAdd
   if {$bAdd != \"TRUE\"} {
      foreach sDat [list 3 4 7 8 9] sPQ2 [list version filesuffix view edit print] {set aDat($sDat) [pPrintQuery \"\" $sPQ2 \"\" \"\"]}
      set aDat(5) \"\"
      set aDat(6) \"\"
      set aDat(10) \"\"
      set lsPrint [split [pQuery \"\" \"print format \\042$aCol(0)\\042\"] \\n]
      foreach sPrint $lsPrint {
         set sPrint [string trim $sPrint]
         if {[string first \"type\" $sPrint] == 0} {
            regsub \"type\" $sPrint \"\" aDat(6)
            set aDat(6) [string trim $aDat(6)]
            set aDat(5) $aDat(6)
         } elseif {[string first \"mime\" $sPrint] == 0} {
            regsub \"mime\" $sPrint \"\" aDat(10)
            set aDat(10) [string trim $aDat(10)]
         }
      }
   }
   if {$bOverlay} {pOverlay [list 3 4 5 6 7 8 9 10]}
}

# Procedure to process formats
proc pProcessFormat {} {
   global aCol aDat bAdd sSchemaType
   if {$bAdd} {
      pMqlCmd \"add format \\042$aCol(0)\\042 version \\042$aCol(3)\\042 suffix \\042$aCol(4)\\042 creator \\042$aCol(5)\\042 type \\042$aCol(6)\\042 view \\042$aCol(7)\\042 edit \\042$aCol(8)\\042 print \\042$aCol(9)\\042 mime \\042$aCol(10)\\042\"
   } elseif {$aCol(3) != $aDat(3) || $aCol(4) != $aDat(4) || $aCol(5) != $aDat(5) || $aCol(6) != $aDat(6) || $aCol(7) != $aDat(7) || $aCol(8) != $aDat(8) || $aCol(7) != $aDat(7) || $aCol(9) != $aDat(9) || $aCol(10) != $aDat(10)} {
      pMqlCmd \"mod format \\042$aCol(0)\\042 version \\042$aCol(3)\\042 suffix \\042$aCol(4)\\042 creator \\042$aCol(5)\\042 type \\042$aCol(6)\\042 view \\042$aCol(7)\\042 edit \\042$aCol(8)\\042 print \\042$aCol(9)\\042 mime \\042$aCol(10)\\042\"
   }
   return 0
}                                          
                                      
" 1 0 0 0 0 0 0 0 0 0 0 0 "" 0 0
 0 1
 SpinnerAgent NULL noname "3/27/2017 3:41:28 PM" 0
"12/6/2015 11:42:58 PM" "3/14/2018 3:57:25 PM"
7
 0 1 "12/6/2015 11:42:58 PM" creator "add program emxSpinnerFormat.tcl mql execute immediate !needsbusinessobject !downloadable !pipe !pooled nothidden file ./Business/SourceFiles/emxSpinnerFormat.tcl"
 0 2 "12/6/2015 11:42:58 PM" creator "add property SpinnerAgent on program emxSpinnerFormat.tcl value '12/6/2015 11:42:58 PM'"
 0 2 "12/6/2015 11:42:58 PM" creator "mod program emxSpinnerFormat.tcl description ''"
 0 2 "2/3/2016 5:21:01 PM" creator "mod property SpinnerAgent on program emxSpinnerFormat.tcl value '2/3/2016 5:21:01 PM'"
 0 2 "2/3/2016 5:21:01 PM" creator "mod program emxSpinnerFormat.tcl file ./Business/SourceFiles/emxSpinnerFormat.tcl"
 0 2 "3/27/2017 3:41:28 PM" creator "mod property SpinnerAgent on program emxSpinnerFormat.tcl value '3/27/2017 3:41:28 PM'"
 0 2 "3/27/2017 3:41:28 PM" creator "mod program emxSpinnerFormat.tcl file ./Business/SourceFiles/emxSpinnerFormat.tcl"

!MTRX!END

!MTRX!AD! program emxSpinnerPolicy.tcl "3DEXPERIENCE R2015x(24.0.0.0)"
emxSpinnerPolicy.tcl 0 "" "#########################################################################*10.80
#
# @progdoc      emxSpinnerPolicy.tcl vM10.80 (Build 8.3.31)
#
# @Description: Procedures for running in Policies
#
# @Parameters:  Returns 0 if successful, 1 if not
#
# @Usage:       Utilized by emxSpinnerAgent.tcl
#
# @progdoc      Copyright (c) MatrixOne Inc. 2005
#
#########################################################################
#
# @Modifications: MJ Osterman 03/31/2008 - added allstate parameter
#
#########################################################################

# Procedure to analyze policies
proc pAnalyzePolicy {} {
   global aCol aDat aSymbolicRef bOverlay bAdd lsTypePlan lsTypeActual lsTypeRetain slsTypeRetain lsFormatPlan lsFormatActual lsStatePlan lsStateActual lsStateRef lsSymbolicPlan lsSymbolicActual lsSymbolicRef lsSchemaType bRetainBusObject bScan sMxVersion
   regsub -all \"continue\" $aCol(3) \"...\" aCol(3)
   set lsTypePlan [pTrimList $aCol(6)]
   if {[lsearch $lsSchemaType type] >= 0} {set lsTypePlan [pCheckNameChange $lsTypePlan type]}
   set lsFormatPlan [pTrimList $aCol(7)]
   if {[lsearch $lsSchemaType format] >= 0} {set lsFormatPlan [pCheckNameChange $lsFormatPlan format]}
   if {$aCol(8) != \"\"} {set aCol(8) [pCheckNameChange $aCol(8) format]}
   set aCol(9) [pCompareAttr $aCol(9) notenforce enforce true true]
   set lsStatePlan [pTrimList $aCol(10)]
   set lsStateOrig [pTrimList $aCol(11)]
   set lsSymbolicPlan \"\"
   foreach sStateOrig $lsStateOrig {
      regsub -all \" \" $sStateOrig \"\" sStateOrig
      if {$sStateOrig == \"\"} {
         lappend lsSymbolicPlan \"\"
      } else {
         set sSymbolicPlan \"state_$sStateOrig\"
         lappend lsSymbolicPlan $sSymbolicPlan
      }
   }
   foreach sValue [list lsTypeActual lsFormatActual lsStateActual lsSymbolicActual lsStateRef lsSymbolicRef lsTypeRetain] {
      set \"$sValue\" [list ]
   }
   if {$bAdd != \"TRUE\"} {
      foreach iDat [list 3 4 8] sProperty [list revision store defaultformat] {set aDat($iDat) [pPrintQuery \"\" $sProperty \"\" \"\"]}
      set bEnforceActual [pPrintQuery \"\" islockingenforced \"\" \"\"]
      set aDat(9) [pCompareAttr $bEnforceActual notenforce enforce true false]
      set lsTypeActual [pPrintQuery \"\" type | spl]
      set lsFormatActual [pPrintQuery \"\" format | spl]
      set lsStateActual [pPrintQuery \"\" state | spl]
      set lsStateRef [pPrintQuery \"\" property.value | spl]
      set lsSymbolicRef [pPrintQuery \"\" property.name | spl]
      foreach sStateRef $lsStateRef sSymbolicRef $lsSymbolicRef {
         if {[string range $sSymbolicRef 0 5] == \"state_\"} {
      	     set aSymbolicRef($sSymbolicRef) $sStateRef
      	     set aRevSymbolicRef($sStateRef) $sSymbolicRef
      	  }
      }
      foreach sStateActual $lsStateActual {
      	  set iState [lsearch $lsStateRef $sStateActual]
      	  if {$iState >= 0 && [string range [lindex $lsSymbolicRef $iState] 0 5] == \"state_\"} {
      	     lappend lsSymbolicActual [lindex $lsSymbolicRef $iState]
      	  } else {
      	     lappend lsSymbolicActual \"\"
      	  }
      }
      if {$sMxVersion >= 10.8} {set aDat(12) [pPrintQuery \"FALSE\" allstate \"\" \"\"]}
   }
   if {$bOverlay} {
      if {$sMxVersion >= 10.8} {
         pOverlay [list 3 4 8 9 12]
      } else {
         pOverlay [list 3 4 8 9]
      }
      set lsTypePlan [pOverlayList $lsTypePlan $lsTypeActual]
      set lsFormatPlan [pOverlayList $lsFormatPlan $lsFormatActual]
      if {$lsStatePlan == \"<NULL>\"} {
         set lsStatePlan [list ]
         set lsSymbolicPlan [list ]
      } elseif {$bAdd != \"TRUE\" && $lsStatePlan == \"\"} {
         set lsStatePlan $lsStateActual
         set lsSymbolicPlan $lsSymbolicActual
      } else {
               set lsTemp [pMergeList $lsStatePlan $lsSymbolicPlan $lsStateActual $lsSymbolicActual STATE]
               set lsStatePlan [lindex $lsTemp 0]
               set lsSymbolicPlan [lindex $lsTemp 1]
      }
   }
   if {$bAdd != \"TRUE\" && $bRetainBusObject && $bScan != \"TRUE\"} {
      foreach sTypeActual $lsTypeActual {if {[lsearch $lsTypePlan $sTypeActual] > -1} {lappend lsTypeRetain $sTypeActual}}
      set slsTypeRetain [join $lsTypeRetain ,]
   }
}                                       

# Procedure to process policies
proc pProcessPolicy {} {
   global aCol aDat aSymbolicRef bAdd lsTypePlan lsTypeActual lsTypeRetain slsTypeRetain lsFormatPlan lsFormatActual lsStatePlan lsStateActual lsStateRef lsSymbolicPlan lsSymbolicActual lsSymbolicRef sHidden sHiddenActual lsSchemaType sSpinDir aSchemaTitle bRetainBusObject iBusObjCommit bScan slsVault sLogFileDir bOut sMxVersion
   if {$bAdd} {
      set aCol(3) [pRegSubEvalEscape $aCol(3)]
      pMqlCmd \"escape add policy \\042$aCol(0)\\042 sequence '$aCol(3)' $sHidden $aCol(9)\"
      pPlanAdd $lsTypePlan policy $aCol(0) \"add type\" \"\"
      pPlanAdd $lsFormatPlan policy $aCol(0) \"add format\" \"\"
      pPlanAdd $lsStatePlan policy $aCol(0) \"add state\" \"\"
      if {$aCol(8) != \"\"} {pMqlCmd \"mod policy \\042$aCol(0)\\042 defaultformat \\042$aCol(8)\\042\"}
      if {$aCol(4) != \"\"} {pMqlCmd \"mod policy \\042$aCol(0)\\042 store \\042$aCol(4)\\042\"}
      if {$sMxVersion >= 10.8 && $aCol(12) == \"TRUE\"} {pMqlCmd \"mod policy \\042$aCol(0)\\042 add allstate\"}
      foreach sSymbolicPlan $lsSymbolicPlan sState $lsStatePlan {if {$sSymbolicPlan != \"\"} {pMqlCmd \"add property \\042$sSymbolicPlan\\042 on policy \\042$aCol(0)\\042 value \\042$sState\\042\"}}
   } else {
      if {$aCol(3) != $aDat(3) || $sHidden != $sHiddenActual || $aCol(9) != $aDat(9)} {
         set aCol(3) [pRegSubEvalEscape $aCol(3)]
         pMqlCmd \"escape mod policy \\042$aCol(0)\\042 sequence '$aCol(3)' $sHidden $aCol(9)\"
      }
      if {$aCol(4) == \"\" && $aDat(4) != \"\"} {
         set resultappend \"ERROR: Policy '$aCol(0)' store '$aDat(4)' may not be changed back to <null> once set!\"
         return 1
      } elseif {$aCol(4) != $aDat(4)} {
         pMqlCmd \"mod policy \\042$aCol(0)\\042 store \\042$aCol(4)\\042\"
      }
      pPlanActualAddDel $lsTypeActual \"\" $lsTypePlan policy \"\" $aCol(0) \"remove type\" \"add type\" \"\"
      pPlanActualAddDel $lsFormatActual \"\" $lsFormatPlan policy \"\" $aCol(0) \"remove format\" \"add format\" \"\"
      if {$aCol(8) == \"\" && $aDat(8) != \"\"} {
         set resultappend \"ERROR: Policy '$aCol(0)' default format '$aDat(8)' may not be set to <null> once set!\"
         return 1
      } elseif {$aCol(8) != $aDat(8)} {
         pMqlCmd \"mod policy \\042$aCol(0)\\042 defaultformat \\042$aCol(8)\\042\"
      }
      if {$sMxVersion >= 10.8 && $aCol(12) != \"\" && $aCol(12) != $aDat(12)} {
         if {$aCol(12) == \"TRUE\"} {
            pMqlCmd \"mod policy \\042$aCol(0)\\042 add allstate\"
         } else {
            pMqlCmd \"mod policy \\042$aCol(0)\\042 remove allstate\"
         }
      }
      set bChange FALSE
      set bRename FALSE
# Rename states
      foreach sStatePlan $lsStatePlan sSymbolicPlan $lsSymbolicPlan {
         if {[catch {
            if {$sStatePlan != $aSymbolicRef($sSymbolicPlan)} {
               set sTemp \"\"
               if {[lsearch $lsStateActual $sStatePlan] >= 0} {
                  set sTemp \"TEMP_\"
                  set bRename TRUE
               }
               pMqlCmd \"mod policy \\042$aCol(0)\\042 state \\042$aSymbolicRef($sSymbolicPlan)\\042 name \\042$sTemp$sStatePlan\\042\"
            }
         } sMsg]== 0 } {
            set bChange TRUE
         }
      }
      if {$bRename} {
         set lsStateActual [pPrintQuery \"\" state | spl]
         foreach sStateA $lsStateActual {
         	if {[string first \"TEMP_\" $sStateA] == 0} {
         	   regsub \"TEMP_\" $sStateA \"\" sRename
               pMqlCmd \"mod policy \\042$aCol(0)\\042 state \\042$sStateA\\042 name \\042$sRename\\042\"
            }
         }
      }                                         	   
      if {$bChange} {set lsStateActual [pPrintQuery \"\" state | spl]}
# Remove states not in plan sequence and retain bus objects with states reordered
      set lsStateReorder \"\"
      set bQuery TRUE
      set iCtrA 0
      for {set iCtrP 0} {$iCtrP < [llength $lsStatePlan]} {incr iCtrP} {
         set sStateP [lindex $lsStatePlan $iCtrP]
         set sStateA [lindex $lsStateActual $iCtrA]
         if {$sStateA != \"\"} {
            if {$sStateP != $sStateA} {
               if {[lsearch $lsStatePlan $sStateA] < 0} {
                  pMqlCmd \"mod policy \\042$aCol(0)\\042 remove state \\042$sStateA\\042\"
                  incr iCtrP -1
               } elseif {[lsearch $lsStateActual $sStateP] >= 0} {
                  if {$bRetainBusObject && $bScan != \"TRUE\"} {
                     set aBusObject($sStateP) \"\"
                     if {$bQuery} {
                        puts -nonewline \"\\nRetain bus object current state option activated: querying database...\"
                        mql temp query bus \"$slsTypeRetain\" * * vault \"$slsVault\" select id current policy dump | output \"$sLogFileDir/BusObjectQuery.txt\"
                        set bQuery FALSE
                     }
                     set iBOQuery [open \"$sLogFileDir/BusObjectQuery.txt\" r]
                     set slsBusObject [gets $iBOQuery]
                     set iBOCounter 0
                     while {$slsBusObject != \"\"} {
                        incr iBOCounter
                        set lslsBusObject [split $slsBusObject |]
                        if {[lindex $lslsBusObject 4] == $sStateP && [lindex $lslsBusObject 5] == $aCol(0)} {lappend aBusObject($sStateP) [lindex $lslsBusObject 3]}
                        set slsBusObject [gets $iBOQuery]
                     }
                     close $iBOQuery
                     if {$aBusObject($sStateP) != \"\"} {lappend lsStateReorder $sStateP}
                  }
                  pMqlCmd \"mod policy \\042$aCol(0)\\042 remove state \\042$sStateP\\042\"
                  pMqlCmd \"mod policy \\042$aCol(0)\\042 add state \\042$sStateP\\042 before \\042$sStateA\\042\"
                  incr iCtrA
               } else {
                  pMqlCmd \"mod policy \\042$aCol(0)\\042 add state \\042$sStateP\\042 before \\042$sStateA\\042\"
                  incr iCtrA
               }
               set lsStateActual [pPrintQuery \"\" state | spl]
            } else {
               incr iCtrA
            }
         } else {
            pMqlCmd \"mod policy \\042$aCol(0)\\042 add state \\042$sStateP\\042\"               
         }
      }
      for {} {$iCtrA < [llength $lsStateActual]} {incr iCtrA} {pMqlCmd \"mod policy \\042$aCol(0)\\042 remove state \\042[lindex $lsStateActual $iCtrA]\\042\"}
      
      if {$bQuery == \"FALSE\"} {
      	 puts \"$iBOCounter bus object(s) found\"
         file delete -force \"$sLogFileDir/BusObjectQuery.txt\"
      }
# Reset Bus Object states if reordered
      foreach sStateReorder $lsStateReorder {
         mql trigger off
         set bPromote FALSE
         set iCommit 0
         foreach oID $aBusObject($sStateReorder) {
            while {[pQuery \"\" \"print bus $oID select current dump\"] != \"$sStateReorder\"} {
               if {$bPromote == \"FALSE\"} {
                  puts \"Resetting [llength $aBusObject($sStateReorder)] bus object(s) back to state '$sStateReorder'\"
                  pAppend \"# Promote [llength $aBusObject($sStateReorder)] business objects back to state: $sStateReorder\" FALSE
                  set bPromote TRUE
               }
               set sCurrent [pQuery \"\" \"print bus $oID select current dump\"]
               if {[catch {
                  mql override bus $oID state \\042$sCurrent\\042
               	  mql promote bus $oID
               } sMsg] != 0} {
                  pWriteWarningMsg \"\\nWARNING: Bus Object [pQuery \"$oID\" \"print bus $oID select type name revision dump \\042 \\042\"] promote error:\\n$sMsg\"
                  break
               } else {
                  incr iCommit
                  if {$iCommit > $iBusObjCommit} {
                     mql commit transaction
                     mql start transaction update
                     pAppend \"# Committed $iCommit business object promotions\" FALSE
                     set iCommit 0
                  }
               }
            }
         }
         mql trigger on
      }
# For state resequence, run state, signature, trigger and policyaccess files
      set lsSchemaElement \"\"
      foreach sElement [list state signature policyaccess trigger] {
         if {[lsearch $lsSchemaType $sElement] < 0} {
            if {[file exists \"$sSpinDir/Business/*$aSchemaTitle($sElement)Data*.*\"] == 1 || ($sElement == \"policyaccess\" && [file exists \"$sSpinDir/Business/Policy\"] == 1)} {
               set bProcess TRUE
               lappend lsSchemaElement $sElement
            }
         }
      }
# Sync state properties
      foreach sSymbolicPlan $lsSymbolicPlan sState $lsStatePlan {
         if {$sSymbolicPlan != \"\"} {
            set iState [lsearch $lsSymbolicRef $sSymbolicPlan]
            if {$iState < 0} {
         	   pMqlCmd \"add property \\042$sSymbolicPlan\\042 on policy \\042$aCol(0)\\042 value \\042$sState\\042\"
            } elseif {$sState != [lindex $lsStateRef $iState]} {
               pMqlCmd \"mod property \\042$sSymbolicPlan\\042 on policy \\042$aCol(0)\\042 value \\042$sState\\042\"
            }
         }
      }
      foreach sSymbolicRef $lsSymbolicRef {
         if {[lrange $sSymbolicRef 0 5] == \"state_\" && [lsearch $lsSymbolicPlan $sSymbolicRef] < 0} {pMqlCmd \"delete property \\042$sSymbolicRef\\042 on policy \\042$aCol(0)\\042\"}
      }
   }
   return 0
}

# Procedure to analyze policy states
proc pAnalyzeState {} {
   global aCol aDat bOverlay bAdd lsAccessPlan lsAccessActual lsNotifyPlan lsNotifyActual lsSignaturePlan lsSignatureActual bUseAccessField
   foreach iCol [list 2 3 5] {set aCol($iCol) [pCompareAttr $aCol($iCol) false true true true]}
   set aCol(4) [pCompareAttr $aCol(4) true false false true]
   set lsAccessPlan  [pTrimList $aCol(6)]
   set lsNotifyPlan [pTrimList $aCol(7)]
   set lsSignaturePlan [pTrimList $aCol(11)]
   foreach iDat [list 2 3 4 5] sProperty [list revisionable versionable autopromote checkouthistory] {set aDat($iDat) [pPrintQuery \"\" \"state\\134\\133$aCol(1)\\134\\135.$sProperty\" \"\" str]}
   set aDat(8) [pPrintQuery \"\" \"state\\134\\133$aCol(1)\\134\\135.notify\" \"\" \"\"]
   set aDat(10) [pPrintQuery \"\" \"state\\134\\133$aCol(1)\\134\\135.route\" \"\" \"\"]
   set lsSignatureActual [pPrintQuery \"\" \"state\\134\\133$aCol(1)\\134\\135.signature\" | spl]
   set lsAccessActual [list ]
   set lsNotifyActual [list ]
   set aDat(9) \"\"
   if {$bUseAccessField} {set lsAccessActual [pQueryAccess policy $aCol(0) \"state\\134\\133$aCol(1)\\134\\135.access\"]}
   set lsPrint [split [pQuery \"\" \"print policy \\042$aCol(0)\\042\"] \\n]
   set bTrip \"FALSE\"
   foreach sPrint $lsPrint {
      set sPrint [string trim $sPrint]
      if {$sPrint == \"state $aCol(1)\"} {
         set bTrip TRUE
      } elseif {$bTrip && [string range $sPrint 0 4] == \"state\"} {
         break
      } elseif {$bTrip} {
         if {[string range $sPrint 0 5] == \"notify\"} {
            regsub \"notify \" $sPrint \"\" sPrint
            regsub -all \"'\" $sPrint \"\" sPrint
            if {$aDat(8) != \"\"} {regsub \" $aDat(8)\" $sPrint \"\" sPrint}
            set sPrint [string trim $sPrint]
            set lsNotifyActual [split $sPrint \",\"]
         } elseif {[string range $sPrint 0 4] == \"route\"} {
            regsub \"route \" $sPrint \"\" sPrint
            regsub -all \"'\" $sPrint \"\" sPrint
            if {$aDat(10) != \"\"} {regsub \" $aDat(10)\" $sPrint \"\" sPrint}
            set aDat(9) [string trim $sPrint]
         }
      }
   }
   pSetAction \"Modify policy $aCol(0) state $aCol(1)\"
   if {$bOverlay} {
      pOverlay [list 2 3 4 5 8 9 10]
      set lsAccessPlan [pOverlayList $lsAccessPlan $lsAccessActual]
      set lsNotifyPlan [pOverlayList $lsNotifyPlan $lsNotifyActual]
      set lsSignaturePlan [pOverlayList $lsSignaturePlan $lsSignatureActual]
   }
}                                       

# Procedure to process policy states
proc pProcessState {} {
   global aCol aDat lsAccessPlan lsAccessActual lsNotifyPlan lsNotifyActual lsSignaturePlan lsSignatureActual bUseAccessField sIcon bScan
   pPlanActualAddDel $lsSignatureActual \"\" $lsSignaturePlan policy \"\\042$aCol(0)\\042 state\" $aCol(1) \"remove signature\" \"add signature\" \" approve \\042User Agent\\042\"
   if {$aCol(2) != $aDat(2) || $aCol(3) != $aDat(3) || $aCol(4) != $aDat(4) || $aCol(5) != $aDat(5) || $aCol(8) != $aDat(8) || $aCol(10) != $aDat(10)} {pMqlCmd \"mod policy \\042$aCol(0)\\042 state \\042$aCol(1)\\042 revision $aCol(2) version $aCol(3) promote $aCol(4) checkouthistory $aCol(5) notify message \\042$aCol(8)\\042 route message \\042$aCol(10)\\042\"}
   if {$bUseAccessField} {pPlanActualAddDel $lsAccessActual \"\" $lsAccessPlan policy \"\\042$aCol(0)\\042 state\" $aCol(1) \"remove user\" \"add user\" \"\"}
   pPlanActualAddDel $lsNotifyActual \"\" $lsNotifyPlan policy \"\\042$aCol(0)\\042 state\" $aCol(1) \"remove notify\" \"add notify\" \"\"
   if {$aDat(9) != \"\" && $aDat(9) != $aCol(9)} {pMqlCmd \"mod policy \\042$aCol(0)\\042 state \\042$aCol(1)\\042 remove route\"}
   if {$aCol(9) != \"\" && $aCol(9) != $aDat(9)} {pMqlCmd \"mod policy \\042$aCol(0)\\042 state \\042$aCol(1)\\042 add route \\042$aCol(9)\\042\"}
   if {$sIcon != \"\" && $bScan != \"TRUE\"} {mql mod policy $aCol(0) state $aCol(1) icon \"$sSpinDir/Pix/$sIcon\"}
   return 0
}

# Procedure to analyze policy state signatures
proc pAnalyzeSignature {} {
   global aCol aDat bOverlay bAdd lsApprovePlan lsApproveActual lsRejectPlan lsRejectActual lsIgnorePlan lsIgnoreActual
   set lsApprovePlan [pTrimList $aCol(3)]
   set lsRejectPlan [pTrimList $aCol(4)]
   set lsIgnorePlan [pTrimList $aCol(5)]
   set lsApproveActual [pPrintQuery \"\" \"state\\134\\133$aCol(1)\\134\\135.signature\\134\\133$aCol(2)\\134\\135.approve\" | spl]
   set lsRejectActual [pPrintQuery \"\" \"state\\134\\133$aCol(1)\\134\\135.signature\\134\\133$aCol(2)\\134\\135.reject\" | spl]
   set lsIgnoreActual [pPrintQuery \"\" \"state\\134\\133$aCol(1)\\134\\135.signature\\134\\133$aCol(2)\\134\\135.ignore\" | spl]
   set sCatchStringOne \"state $aCol(1)\"
   set aDat(6) \"\"
   set aDat(7) \"\"
   set sCatchStringTwo \"\"
   set bPass false
   set bTrip1 false
   set bTrip2 false
   set lsPrint [split [pQuery \"\" \"print policy \\042$aCol(0)\\042\"] \\n]
   foreach sPrint $lsPrint {
      set sPrint [string trim $sPrint]
      if {$sCatchStringTwo == \"\"} {
         if {[string first $sCatchStringOne $sPrint] == 0} {set sCatchStringTwo \"state\"}
      } elseif {[string first $sCatchStringTwo $sPrint] == 0} {
         break
      }
      if {$sCatchStringTwo != \"\"} {
         if {[string first \"signature $aCol(2)\" $sPrint] == 0} {
            set bPass true
         } elseif {$bPass} {
            if {[string first \"branch\" $sPrint] == 0} {
               set bTrip1 \"true\"
               regsub \"branch \" $sPrint \"\" aDat(6)
               set aDat(6) [string trim $aDat(6)]
            }
            if {[string first \"filter\" $sPrint] == 0} {
               set bTrip2 \"true\"
               regsub \"filter \" $sPrint \"\" aDat(7)
               set aDat(7) [string trim $aDat(7)]
            }
            if {$bTrip1 && $bTrip2} {break}
         }
      }
   }
   pSetAction \"Modify policy $aCol(0) state $aCol(1) signature $aCol(2)\"
   if {$bOverlay} {
      pOverlay [list 6 7]
      set lsApprovePlan [pOverlayList $lsApprovePlan $lsApproveActual]
      set lsRejectPlan [pOverlayList $lsRejectPlan $lsRejectActual]
      set lsIgnorePlan [pOverlayList $lsIgnorePlan $lsIgnoreActual]
   }
}

# Procedure to process policy state signatures
proc pProcessSignature {} {
   global aCol aDat lsApprovePlan lsApproveActual lsRejectPlan lsRejectActual lsIgnorePlan lsIgnoreActual
   if {$aCol(7) != $aDat(7)} {
      set aCol(7) [pRegSubEvalEscape $aCol(7)]
      pMqlCmd \"mod policy \\042$aCol(0)\\042 state \\042$aCol(1)\\042 signature \\042$aCol(2)\\042 filter \\042$aCol(7)\\042\"
   }
   pPlanActualAddDel $lsApproveActual \"\" $lsApprovePlan policy \"\\042$aCol(0)\\042 state \\042$aCol(1)\\042 signature\" $aCol(2) \"remove approve\" \"add approve\" \"\"
   pPlanActualAddDel $lsRejectActual \"\" $lsRejectPlan policy \"\\042$aCol(0)\\042 state \\042$aCol(1)\\042 signature\" $aCol(2) \"remove reject\" \"add reject\" \"\"
   pPlanActualAddDel $lsIgnoreActual \"\" $lsIgnorePlan policy \"\\042$aCol(0)\\042 state \\042$aCol(1)\\042 signature\" $aCol(2) \"remove ignore\" \"add ignore\" \"\"
   if {$aCol(6) != $aDat(6)} {
      if {$aCol(6) == \"\" && $aDat(6) != \"\"} {
         pMqlCmd \"mod policy \\042$aCol(0)\\042 state \\042$aCol(1)\\042 signature \\042$aCol(2)\\042 remove branch\"
      } else {
         pMqlCmd \"mod policy \\042$aCol(0)\\042 state \\042$aCol(1)\\042 signature \\042$aCol(2)\\042 add branch \\042$aCol(6)\\042\"
      }
   }
   return 0
}
" 1 0 0 0 0 0 0 0 0 0 0 0 "" 0 0
 0 1
 SpinnerAgent NULL noname "3/27/2017 3:41:28 PM" 0
"12/6/2015 11:42:58 PM" "3/14/2018 3:57:25 PM"
7
 0 1 "12/6/2015 11:42:58 PM" creator "add program emxSpinnerPolicy.tcl mql execute immediate !needsbusinessobject !downloadable !pipe !pooled nothidden file ./Business/SourceFiles/emxSpinnerPolicy.tcl"
 0 2 "12/6/2015 11:42:58 PM" creator "add property SpinnerAgent on program emxSpinnerPolicy.tcl value '12/6/2015 11:42:58 PM'"
 0 2 "12/6/2015 11:42:58 PM" creator "mod program emxSpinnerPolicy.tcl description ''"
 0 2 "2/3/2016 5:21:01 PM" creator "mod property SpinnerAgent on program emxSpinnerPolicy.tcl value '2/3/2016 5:21:01 PM'"
 0 2 "2/3/2016 5:21:01 PM" creator "mod program emxSpinnerPolicy.tcl file ./Business/SourceFiles/emxSpinnerPolicy.tcl"
 0 2 "3/27/2017 3:41:28 PM" creator "mod property SpinnerAgent on program emxSpinnerPolicy.tcl value '3/27/2017 3:41:28 PM'"
 0 2 "3/27/2017 3:41:28 PM" creator "mod program emxSpinnerPolicy.tcl file ./Business/SourceFiles/emxSpinnerPolicy.tcl"

!MTRX!END

!MTRX!AD! program emxSpinnerWebComp.tcl "3DEXPERIENCE R2015x(24.0.0.0)"
emxSpinnerWebComp.tcl 0 "" "#########################################################################*10.8
#
# @progdoc      emxSpinnerWebComp.tcl vM10.80 (Build 8.4.10)
#
# @Description: Procedures for running in Web Components
#               (Command, Menu, Channel, Portal, Inquiry, Table, WebForm)
#
# @Parameters:  Returns 0 if successful, 1 if not
#
# @Usage:       Utilized by emxSpinnerAgent.tcl
#
# @progdoc      Copyright (c) ENOVIA Inc. 2005
#
#########################################################################
#
# @Modifications: FirstName LastName MM/DD/YYYY - Modification
#
#########################################################################

# Procedure to pass tcl-type variables in mql commands
   proc pRegSubMqlEscape {sEscape} {
      regsub -all \"\\134$\" $sEscape \"\\$\" sEscape
      regsub -all \"\\134{\" $sEscape \"\\173\" sEscape
      regsub -all \"\\134}\" $sEscape \"\\175\" sEscape
      regsub -all \"\\134\\133\" $sEscape \"\\133\" sEscape
      regsub -all \"\\134\\135\" $sEscape \"\\135\" sEscape
      regsub -all \"\\042\" $sEscape \"\\042\" sEscape
      regsub -all \"\\047\" $sEscape \"\\047\" sEscape
      return $sEscape
   }

# Procedure to set setting names and values
   proc pSetSetting {sSchType sSchName slsStgName slsStgValue sMidCommand sStgArgument} {
      global lsStgNamePlan lsStgValuePlan lsStgNameActual lsStgValueActual aStgPlan aStgActual sRangeDelim sColumnField aCol sLogFileError bOverlay bAdd lsDel
      set lsStgNamePlan [pTrimList $slsStgName]
      regsub -all \"\\134\\174\\134\\174\" $slsStgValue \"<OR>\" slsStgValue
      regsub -all \"&&\" $slsStgValue \"<AND>\" slsStgValue
      if {$sSchType == \"form\"} {
         regsub -all \" \\134\\174 \" $slsStgValue \"<SPLIT>\" slsStgValue
         regsub -all \"\\134\\174\" $slsStgValue \"<PIPE>\" slsStgValue
         regsub -all \"<SPLIT>\" $slsStgValue \"|\" slsStgValue
      }
      set lsStgValuePlanTemp [split $slsStgValue $sRangeDelim]
      set lsStgValuePlan \"\"
      foreach sStgValue $lsStgValuePlanTemp {
      	 regsub -all \"<OR>\" $sStgValue \"\\174\\174\" sStgValue
      	 regsub -all \"<AND>\" $sStgValue \"\\134\\&\\134\\&\" sStgValue
         regsub -all \"<PIPE>\" $sStgValue \"|\" sStgValue
         regsub -all \"<NULL>\" $sStgValue \"\" sStgValue
         lappend lsStgValuePlan [string trim $sStgValue]
      }
      set lsStgNameActual [split [pQuery \"\" \"print $sSchType \\042$sSchName\\042 $sMidCommand$sStgArgument.name dump |\"] |]
      set lsStgValueActual [split [pQuery \"\" \"print $sSchType \\042$sSchName\\042 $sMidCommand$sStgArgument.value dump ^\"] ^]
      foreach sStgNameActual $lsStgNameActual sStgValueActual $lsStgValueActual {array set aStgActual [list $sStgNameActual $sStgValueActual]}
      if {[llength $lsStgNamePlan] != [llength $lsStgValuePlan]} {
         set sAppend \"\"
         if {$sSchType == \"form\" || $sSchType == \"table\"} {set sAppend \" $sColumnField '$aCol(1)'\"}
         set iLogFileErr [open $sLogFileError a+]
         puts $iLogFileErr \"\\nERROR: '$sSchType' '$sSchName'$sAppend setting name and value lists are not the same length\"
         close $iLogFileErr
         if {[llength $lsStgNamePlan] > [llength $lsStgValuePlan] && [string first \"<OR>\" $slsStgValue] > -1} {
            set iLogFileErr [open $sLogFileError a+]
            puts $iLogFileErr \"Be sure to leave a space between '|'s if null values are intended vs. double '|'s\"
            close $iLogFileErr
         }
         return 1
      }
      if {$bOverlay} {
      	 if {$lsStgNamePlan == \"<NULL>\"} {
      	    set lsStgNamePlan [list ]
      	    set lsStgValuePlan [list ]
      	 } elseif {$bAdd != \"TRUE\" && $lsStgNamePlan == \"\"} {
      	    set lsStgNamePlan $lsStgNameActual
      	    set lsStgValuePlan $lsStgValueActual
      	 } else {
      	    set lsTemp [pMergeList $lsStgNamePlan $lsStgValuePlan $lsStgNameActual $lsStgValueActual \"\"]
      	    set lsStgNamePlan [lindex $lsTemp 0]
      	    set lsStgValuePlan [lindex $lsTemp 1]
      	 }
      }
      foreach sStgNamePlan $lsStgNamePlan sStgValuePlan $lsStgValuePlan {array set aStgPlan [list $sStgNamePlan $sStgValuePlan]}
      return 0
   }

# Procedure to process setting names and values
   proc pSetting {sSchType sSchName sMidCommand sStgArgument} {
      global lsStgNameActual lsStgValueActual lsStgNamePlan lsStgValuePlan aStgActual aStgPlan
      foreach sStgNameA $lsStgNameActual sStgValueA $lsStgValueActual sStgNameP $lsStgNamePlan sStgValueP $lsStgValuePlan {
         if {$sStgNameA != \"\"} {
            if {[lsearch $lsStgNamePlan $sStgNameA] < 0} {
               pMqlCmd \"escape mod $sSchType \\042$sSchName\\042 $sMidCommand remove $sStgArgument \\042$sStgNameA\\042\"
            } elseif {$aStgPlan($sStgNameA) != $sStgValueA} {
               set sModSettingValue [pRegSubEvalEscape $aStgPlan($sStgNameA)]
               if {[string first \"\\047\" $sModSettingValue] < 0 && [string first \"javascript\" [string tolower $sModSettingValue]] < 0} {
                  pMqlCmd \"escape mod $sSchType \\042$sSchName\\042 $sMidCommand add $sStgArgument \\042$sStgNameA\\042 '$sModSettingValue'\"
               } else {
                  pMqlCmd \"escape mod $sSchType \\042$sSchName\\042 $sMidCommand add $sStgArgument \\042$sStgNameA\\042 \\042$sModSettingValue\\042\"
               }
               array set aStgActual [list $sStgNameA $aStgPlan($sStgNameA)]
            }
         }
         if {$sStgNameP != \"\"} {
            if {[lsearch $lsStgNameActual $sStgNameP] < 0} {
               set sModSettingValue [pRegSubEvalEscape $sStgValueP]
               if {[string first \"\\047\" $sModSettingValue] < 0 && [string first \"javascript\" [string tolower $sModSettingValue]] < 0} {
                  pMqlCmd \"escape mod $sSchType \\042$sSchName\\042 $sMidCommand add $sStgArgument \\042$sStgNameP\\042 '$sModSettingValue'\"
               } else {
                  pMqlCmd \"escape mod $sSchType \\042$sSchName\\042 $sMidCommand add $sStgArgument \\042$sStgNameP\\042 \\042$sModSettingValue\\042\"
               }
            } elseif {$aStgActual($sStgNameP) != $sStgValueP} {
               set sModSettingValue [pRegSubEvalEscape $sStgValueP]
               if {[string first \"\\047\" $sModSettingValue] < 0 && [string first \"javascript\" [string tolower $sModSettingValue]] < 0} {
                  pMqlCmd \"escape mod $sSchType \\042$sSchName\\042 $sMidCommand add $sStgArgument \\042$sStgNameP\\042 '$sModSettingValue'\"
               } else {
                  pMqlCmd \"escape mod $sSchType \\042$sSchName\\042 $sMidCommand add $sStgArgument \\042$sStgNameP\\042 \\042$sModSettingValue\\042\"
               }
               array set aStgActual [list $sStgNameP $sStgValueP]
            }
         }
      }
   }

# Procedure to set up portal channel append string
   proc pPortalChannel {lsChannel} {
      set sAppend \"\"
      foreach sChannel $lsChannel {
         set lsChannelItem [split $sChannel ,]
         set lsChannelRow \"\"
         foreach sChannelItem $lsChannelItem {lappend lsChannelRow \"'[string trim $sChannelItem]'\"}
         append sAppend \" channel [join $lsChannelRow ,]\"
      }
      return $sAppend
   }

# Procedure to analyze web components
proc pAnalyzeWebComp {} {
   global aCol aDat bOverlay bAdd bUserAll sSchemaType lsSchemaType aSchemaElement lsCommandPlan lsCommandActual lsChannelPlan lsChannelActual lsUserPlan lsUserActual lsCmdMenuPlan lsCmdMenuActual aCmdMenuPlan aCmdMenuActual lsColumnNamePlan lsColumnNameActual lsTypePlan lsTypeActual sColumnField sSystem sMxVersion sNumberActual lsStgNamePlan lsStgValuePlan lsStgNameActual lsStgValueActual aStgPlan aStgActual sRangeDelim sLogFileError lsDel bRepeat
   switch $sSchemaType {
      command - menu - channel - portal {
         set bReturn [pSetSetting $sSchemaType $aCol(0) $aCol(6) $aCol(7) \"select \" setting]
         if {$bReturn} {
            puts \"\\nError - Review log file '$sLogFileError', correct problem(s) and restart\"
            return 1
         }
         set lsCommandPlan [pTrimList $aCol(8)]
         if {$bAdd != \"TRUE\"} {
            set aDat(3) [pPrintQuery \"\" label \"\" \"\"]
            set aDat(4) [pPrintQuery \"\" href \"\" \"\"]
            set aDat(5) [pPrintQuery \"\" alt \"\" \"\"]
         }
         if {$bOverlay} {pOverlay [list 3 4 5]}
         switch $sSchemaType {
            command {
               set lsUserPlan $lsCommandPlan
               set lsUserActual \"\"
               if {$bAdd != \"TRUE\"} {
                  set lsUserActual [pPrintQuery \"\" user | spl]
                  set aDat(10) [pPrintQuery \"\" code \"\" \"\"]
                  set bUserAll [pPrintQuery \"\" property\\134\\133UserAll\\134\\135.value \"\" \"\"]
               }
               if {$bOverlay} {
                  pOverlay [list 10]
                  set lsUserPlan [pOverlayList $lsUserPlan $lsUserActual]
               }
            } menu {
               set lsCmdMenuPlan $lsCommandPlan
               set lsCmdMenuActual \"\"
               if {$bAdd != \"TRUE\"} {
                  set lsCmdMenuActual [pPrintQuery \"\" child | spl]
                  foreach sCmdMenuActual $lsCmdMenuActual {set aCmdMenuActual($sCmdMenuActual) [pPrintQuery \"menu\" \"child\\134\\133$sCmdMenuActual\\134\\135.type\" \"\" \"\"]}
               }
               if {$bOverlay} {set lsCmdMenuPlan [pOverlayList $lsCmdMenuPlan $lsCmdMenuActual]}
               if {!$bRepeat && [llength [lsort -unique $lsCmdMenuPlan]] != [llength $lsCmdMenuPlan]} {
                  set lsTest [lsort $lsCmdMenuPlan]
                  set sPrevTest \"\"
                  foreach sTest $lsTest {
                     if {$sTest == $sPrevTest} {
                        puts \"\\nERROR: Duplicate item '$sTest' in command/menu list for menu '$aCol(0)'\"
                        break
                     } else {
                        set sPrevTest $sTest
                     }
                  }
               }
               foreach sCmdMenuPlan $lsCmdMenuPlan {
                  if {[pQuery \"\" \"list command \\042$sCmdMenuPlan\\042\"] == \"\"} {
                     set aCmdMenuPlan($sCmdMenuPlan) menu
                  } else {
                     set aCmdMenuPlan($sCmdMenuPlan) command
                  }
               }
            } channel {
               if {[lsearch $lsSchemaType command] >= 0} {set lsCommandPlan [pCheckNameChange $lsCommandPlan command]}
               if {$aCol(9) == \"\" && ($bOverlay != \"TRUE\" || $bAdd)} {set aCol(9) 0}
               set lsCommandActual \"\"
               if {$bAdd != \"TRUE\"} {
                  set aDat(9) [pPrintQuery \"0\" height \"\" \"\"]
                  set lsCommandActual [pPrintQuery \"\" command | spl]
               }
               if {$bOverlay} {
                  pOverlay [list 9]
                  set lsCommandPlan [pOverlayList $lsCommandPlan $lsCommandActual]
               }
            } portal {
               set lsChannelPlan $lsCommandPlan
               set lsChannelActual \"\"
      	       if {$bAdd != \"TRUE\"} {
                  set lsPrint [split [pQuery \"\" \"print portal \\042$aCol(0)\\042\"] \\n]
                  foreach sPrint $lsPrint {
                     set sPrint [string trim $sPrint]
                     if {[string first \"channel\" $sPrint] == 0} {
                        regsub \"channel \" $sPrint \"\" sPrint
                        lappend lsChannelActual $sPrint
                     }
                  }
      	       }
               if {$bOverlay} {set lsChannelPlan [pOverlayList $lsChannelPlan $lsChannelActual]}
            }
         }
      } inquiry {
         set bReturn [pSetSetting inquiry $aCol(0) $aCol(5) $aCol(6) \"select \" argument]
         if {$bReturn} {
            puts \"\\nError - Review log file '$sLogFileError', correct problem(s) and restart\"
            return 1
         }
         regsub -all \"<NEWLINE>\" $aCol(7) \"\\n\" aCol(7)
         if {$bAdd != \"TRUE\"} {
            set aDat(3) [pPrintQuery \"\" pattern \"\" \"\"]
            set aDat(4) [pPrintQuery \"\" format \"\" \"\"]
            set aDat(7) [pPrintQuery \"\" code \"\" \"\"]
         }
         if {$bOverlay} {pOverlay [list 3 4 7]}
      } table - webform {
         set lsColumnNamePlan [pTrimList $aCol(3)]
         set lsColumnNameActual \"\"
         if {$bAdd != \"TRUE\"} {set lsColumnNameActual [split [pQuery \"\" \"print $aSchemaElement($sSchemaType) \\042$aCol(0)\\042 $sSystem select $sColumnField.name dump |\"] |]}
         if {$bOverlay} {
            if {$sSchemaType == \"webform\" && [lsort $lsColumnNamePlan] != [lsort -unique $lsColumnNamePlan]} {
               if {$bAdd != \"TRUE\"} {
                  pWriteWarningMsg \"\\nWARNING: '$sSchemaType' '$aCol(0)' references duplicate field names - these cannot be processed safely.\\nAll field additions, removals or re-ordering actions will be skipped.\"
                  set lsColumnNamePlan $lsColumnNameActual
               }
            } else {
               set lsColumnNamePlan [pOverlayList $lsColumnNamePlan $lsColumnNameActual]
            }
         }
         if {$sSchemaType == \"webform\"} {
            set lsTypePlan [pTrimList $aCol(5)]
            set lsTypeActual [split [pQuery \"\" \"print form \\042$aCol(0)\\042 select type dump |\"] |]
            if {$bOverlay} {set lsTypePlan [pOverlayList $lsTypePlan $lsTypeActual]}
         }
      } column - field {
         if {$aCol(4) != \"\" && [string range [string tolower $aCol(4)] 0 2] != \"bus\"} {
            if {[string range [string tolower $aCol(4)] 0 2] != \"rel\"} {
               set aCol(4) set
            } else {
               set aCol(4) rel
            }
         } elseif {$bOverlay && $aCol(4) == \"\"} {
         } else {   
            set aCol(4) bus
         }
         regsub -all \"\\042\" $aCol(6) \"\" aCol(6)
         set bReturn [pSetSetting $aSchemaElement($sSchemaType) $aCol(0) $aCol(7) $aCol(8) \"$sSystem select $sColumnField\\134\\133$aCol(1)\\134\\135.\" setting]
         if {$bReturn} {
            puts \"\\nError - Review log file '$sLogFileError', correct problem(s) and restart\"
            return 1
         }
         set lsUserPlan [pTrimList $aCol(9)]
         if {$sSchemaType == \"column\"} {
            foreach iDat [list 2 3 4 5 6] sProperty [list label description expressiontype expression href] {set aDat($iDat) [pQuery \"\" \"print $aSchemaElement($sSchemaType) \\042$aCol(0)\\042 $sSystem select $sColumnField\\134\\133$aCol(1)\\134\\135.$sProperty dump\"]}
            set aDat(4) [string range $aDat(4) 0 2]
            set sNumberActual [pQuery \"\" \"print $aSchemaElement($sSchemaType) \\042$aCol(0)\\042 $sSystem select $sColumnField\\134\\133$aCol(1)\\134\\135.number dump\"]
            if {$bOverlay} {pOverlay [list 2 3 4 5 6]}
            if { 1 == 1 } {
               set lsUserActual [split [pQuery \"\" \"print $aSchemaElement($sSchemaType) \\042$aCol(0)\\042 $sSystem select $sColumnField\\134\\133$aCol(1)\\134\\135.user dump |\"] |]
               foreach iDat [list 10 11 12] sProperty [list alt range update] {set aDat($iDat) [pQuery \"\" \"print $aSchemaElement($sSchemaType) \\042$aCol(0)\\042 $sSystem select $sColumnField\\134\\133$aCol(1)\\134\\135.$sProperty dump\"]}
               set sSortType [string range [string tolower $aCol(13)] 0 2]
               switch $sSortType {
                  alp {
                     set aCol(13) alpha
                  } num {
                     set aCol(13) numeric
                  } oth {
                     set aCol(13) other
                  } default {
                  	 if {$bOverlay && $aCol(13) == \"\"} {
                     } else {
                        set aCol(13) none
                     }
                  }
               }
               set aDat(13) \"none\"
               set lsPrint [split [pQuery \"\" \"print table \\042$aCol(0)\\042 system\"] \\n]
               set bTrip \"FALSE\"
               foreach sPrint $lsPrint {
                  set sPrint [string trim $sPrint]
                  if {[string range $sPrint 0 3] == \"name\" && [string first $aCol(1) $sPrint] > 3} {
                     set bTrip TRUE
                  } elseif {$bTrip && [string range $sPrint 0 3] == \"name\"} {
                     break
                  } elseif {$bTrip} {
                     if {[string range $sPrint 0 7] == \"sorttype\"} {
                        regsub \"sorttype\" $sPrint \"\" sPrint
                        set aDat(13) [string trim $sPrint]
                        break
                     }
                  }
               }
               if {$bOverlay} {
                  pOverlay [list 10 11 12]
                  if {$sSchemaType == \"column\"} {pOverlay [list 13]}
                  set lsUserPlan [pOverlayList $lsUserPlan $lsUserActual]
               }
            }
         } else {
            set lsFieldActual [pPrintQuery \"\" \"field.name\" | spl]
            set lsFieldNumber [pPrintQuery \"\" \"field.number\" | spl]
            set sFieldTest \"|[join [lsort $lsFieldActual ] |]|\"
            if {[string first \"|$aCol(1)|$aCol(1)|\" $sFieldTest] >= 0 } {
               if {$aCol(13) == \"\"} {
                  pWriteErrorMsg \"\\nERROR: WebForm '$aCol(0)' field name '$aCol(1)' is duplicated in the database and needs the field order specified.\"
                  return 1
               } elseif {[lindex $lsFieldActual [expr $aCol(13) - 1]] != $aCol(1)} {
                  pWriteErrorMsg \"\\nERROR: WebForm '$aCol(0)' field name '$aCol(1)' order number '$aCol(13)' does not match the database.\\nThis field uses a duplicated name cannot be processed without the correct field order specified.\"
                  return 1
               } else {
                  set iLindex [expr $aCol(13) - 1]
                  set sNumberActual [lindex $lsFieldNumber $iLindex]
               } 
            } else {
	           # Fix spinner bug for can't import webform whoes filed name is empty, modified by mike, Nov. 12 2008
	           if {[string trim $aCol(1)] != \"\"} {
                   set iLindex [lsearch [split [pQuery \"\" \"print form \\042$aCol(0)\\042 select field.name dump |\"] |] $aCol(1) ]
                   if {$iLindex < 0} {
                      pWriteErrorMsg \"\\nERROR: WebForm '$aCol(0)' field '$aCol(1)' definition missing in 'SpinnerWebFormData*.xls'.\"
                      return 1
                   }
                   set sNumberActual [lindex [split [pQuery \"\" \"print form \\042$aCol(0)\\042 select field.number dump |\"] |] $iLindex]
               } else {
	               set iLindex [expr $aCol(13) - 1]
                   set sNumberActual [lindex [pPrintQuery \"\" \"field.number\" | spl] $iLindex]
	           }
               # Ended  by mike.
            }
            foreach iDat [list 2 3 4 5 6 10 11 12] sProperty [list label description expressiontype expression href alt range update] {set aDat($iDat) [lindex [pPrintQuery \"\" \"field.$sProperty\" | spl] $iLindex]}
            set aDat(4) [string range $aDat(4) 0 2]
            set lsStgNameActual [list ]
            set lsStgValueActual [list ]
            set lsUserActual [list ]
            set lsPrint [split [pQuery \"\" \"print form \\042$aCol(0)\\042\"] \\n]
            set bFoundField FALSE
            foreach sPrint $lsPrint {
               set sPrint [string trim $sPrint]
               if {[string first \"field# $sNumberActual\" $sPrint] == 0} {
      	           set bFoundField TRUE
      	        } elseif {$bFoundField} {
                  if {[string first \"setting\" $sPrint] == 0} {
                     regsub \"setting\" $sPrint \"\" sPrint
                     set sPrint [string trim $sPrint]
                     regsub \" value \" $sPrint \"^\" lsPrint
                     lappend lsStgNameActual [lindex [split $lsPrint ^] 0]                 	    
                     lappend lsStgValueActual [lindex [split $lsPrint ^] 1]
                  } elseif {[string first \"user\" $sPrint] == 0} {
                     regsub \"user\" $sPrint \"\" sPrint
                     lappend lsUserActual [string trim $sPrint]
                  } elseif {[string first \"field\" $sPrint] == 0} {
                     break
                  }
               }
            }
            foreach sStgNameActual $lsStgNameActual sStgValueActual $lsStgValueActual {array set aStgActual [list $sStgNameActual $sStgValueActual]}
            if {$bOverlay} {
               if {$aCol(5) == \"\" && $aDat(5) == \"dummy\"} {set aCol(5) \"<NULL>\"}
               pOverlay [list 2 3 4 5 6 10 11 12]
               set lsUserPlan [pOverlayList $lsUserPlan $lsUserActual]
            }
         }
         pSetAction \"Modify $aSchemaElement($sSchemaType) $aCol(0) $sColumnField $aCol(1)\"
      }
   }
   return 0
}

# Procedure to process web components
proc pProcessWebComp {} {
   global aCol aDat bOverlay bAdd bUserAll sHidden sHiddenActual sSchemaType lsSchemaType aSchemaElement lsCommandPlan lsCommandActual lsChannelPlan lsChannelActual lsUserPlan lsUserActual lsCmdMenuPlan lsCmdMenuActual aCmdMenuPlan aCmdMenuActual lsColumnNamePlan lsColumnNameActual lsTypePlan lsTypeActual sColumnField bEscQuote bScan sMxVersion sNumberActual lsStgNamePlan lsStgValuePlan lsStgNameActual lsStgValueActual aStgActual aStgPlan sSpinStamp
   switch $sSchemaType {
      command - menu - channel - portal {
         if {$bAdd} {
            foreach iCol [list 3 4 5] {set aCol($iCol) [pRegSubEvalEscape $aCol($iCol)]}
            set sAppend \"\"
            if {$sSchemaType == \"portal\"} {set sAppend [pPortalChannel $lsChannelPlan]}
            if {$bEscQuote} {
               pMqlCmd \"escape add $sSchemaType \\042$aCol(0)\\042 label '$aCol(3)' Alt '$aCol(5)' $sHidden $sAppend\"
            } else {
               pMqlCmd \"add $sSchemaType \\042$aCol(0)\\042 label \\042$aCol(3)\\042 Alt \\042$aCol(5)\\042 href \\\"$aCol(4)\\\" $sHidden $sAppend\"
            }	
            foreach sStgName $lsStgNamePlan sStgValue $lsStgValuePlan {
               set sStgValue [pRegSubEvalEscape $sStgValue]
               pMqlCmd \"escape mod $sSchemaType \\042$aCol(0)\\042 add setting \\042$sStgName\\042 '$sStgValue'\"
            }
            switch $sSchemaType {
               command {
                  set aCol(10) [pRegSubEvalEscape $aCol(10)]
                  pMqlCmd \"escape mod command \\042$aCol(0)\\042 code '$aCol(10)'\"
                  if {$lsUserPlan != \"\" && [string tolower $lsUserPlan] != \"all\"} {
                     set lsUserActual \"all\"
                     pMqlCmd \"add property UserAll on command \\042$aCol(0)\\042 value TRUE\"
                     pPlanActualAddDel $lsUserActual \"\" $lsUserPlan command \"\" $aCol(0) \"remove user\" \"add user\" \"\"
                  }
               } menu {
                  pPlanAdd $lsCmdMenuPlan menu $aCol(0) \"add\" \"\"
               } channel {
                  pMqlCmd \"mod channel \\042$aCol(0)\\042 height $aCol(9)\"
                  pPlanAdd $lsCommandPlan channel $aCol(0) \"place\" \"after \\042\\042\"
               }
            }
         } else {
            switch $sSchemaType {
               command - menu - channel {
                  if {$sHidden != $sHiddenActual || $aCol(3) != $aDat(3) || $aCol(5) != $aDat(5) || $aCol(4) != $aDat(4)} {
                     foreach iCol [list 3 4 5] {set aCol($iCol) [pRegSubEvalEscape $aCol($iCol)]}
                     if {$bEscQuote} {
                        pMqlCmd \"escape mod $sSchemaType \\042$aCol(0)\\042 label '$aCol(3)' Alt '$aCol(5)' $sHidden\"
                        if {$aCol(4) == $aDat(4)} {set bEscQuote FALSE}
                     } else {
                        pMqlCmd \"mod $sSchemaType \\042$aCol(0)\\042 label \\042$aCol(3)\\042 Alt \\042$aCol(5)\\042 href \\\"$aCol(4)\\\" $sHidden\"
                        set bEscQuote FALSE
                     }
                  }
                  pSetting $sSchemaType $aCol(0) \"\" setting
                  switch $sSchemaType {
                     command {
                        if {$aCol(10) != $aDat(10)} {
                           set aCol($iCol) [pRegSubEvalEscape $aCol($iCol)]
                           pMqlCmd \"escape mod command \\042$aCol(0)\\042 code '$aCol(10)'\"
                        }
                        if {($lsUserPlan == \"\" || [string tolower $lsUserPlan] == \"all\") && $bUserAll != \"\"} {
                           pMqlCmd \"delete property UserAll on command \\042$aCol(0)\\042\"
                        } elseif {$lsUserPlan != \"\" && $bUserAll == \"\"} {
                           set lsUserActual \"all\"
                           pMqlCmd \"add property UserAll on command \\042$aCol(0)\\042 value TRUE\"
                        }
                        pPlanActualAddDel $lsUserActual \"\" $lsUserPlan command \"\" $aCol(0) \"remove user\" \"add user\" \"\"
                     } menu {
                        pPlanActualAddDel $lsCmdMenuActual \"\" $lsCmdMenuPlan menu \"\" $aCol(0) \"remove\" \"add\" \"\"
                        if {$aCol(0) != \"Tree\" && $lsCmdMenuPlan != $lsCmdMenuActual} {
                           set iIndex 1
                           foreach sCmdMenuPlan $lsCmdMenuPlan {
                              pMqlCmd \"mod menu \\042$aCol(0)\\042 order $aCmdMenuPlan($sCmdMenuPlan) \\042$sCmdMenuPlan\\042 $iIndex\"
                              incr iIndex
                           }
                        }
                     } channel {
                        if {$aCol(9) != $aDat(9)} {pMqlCmd \"mod channel \\042$aCol(0)\\042 height $aCol(9)\"}
                        if {$lsCommandPlan != $lsCommandActual} {
                           pPlanAdd $lsCommandActual channel $aCol(0) \"remove command\" \"\"
                           pPlanAdd $lsCommandPlan channel $aCol(0) \"place\" \"after \\042\\042\"
                        }
                     }
                  }
               } portal {
                  if {$lsChannelPlan != $lsChannelActual} {
                     set sAppend [pPortalChannel $lsChannelPlan]
                     pMqlCmd \"delete portal \\042$aCol(0)\\042\"
                     pMqlCmd \"escape add portal \\042$aCol(0)\\042 label '$aCol(3)' Alt '$aCol(5)' href '$aCol(4)' $sHidden $sAppend\"
                     set sSpinStamp \"\"
                  } elseif {$sHidden != $sHiddenActual || $aCol(3) != $aDat(3) || $aCol(5) != $aDat(5) || $aCol(4) != $aDat(4)} {
                     foreach iCol [list 3 4 5] {set aCol($iCol) [pRegSubEvalEscape $aCol($iCol)]}
                     pMqlCmd \"escape mod portal \\042$aCol(0)\\042 label '$aCol(3)' Alt '$aCol(5)' href '$aCol(4)' $sHidden\"
                  }
                  pSetting portal $aCol(0) \"\" setting
               }
            }
         }
         if {$bEscQuote && $bScan != \"TRUE\"} {
            pAppend \"mql mod $sSchemaType $aCol(0) href \\\"$aCol(4)\\\"\" FALSE
            mql mod $sSchemaType $aCol(0) href \"$aCol(4)\"
         }
      } inquiry {
         if {$bAdd} {
            foreach iCol [list 3 4] {set aCol($iCol) [pRegSubEvalEscape $aCol($iCol)]}
            pMqlCmd \"escape add inquiry \\042$aCol(0)\\042 pattern '$aCol(3)' format '$aCol(4)' $sHidden\"
            set aCol(7) [pRegSubMqlEscape $aCol(7)]
            pAppend \"mql mod inquiry $aCol(0) code \\042$aCol(7)\\042\" FALSE
            if {$bScan != \"TRUE\"} {mql escape mod inquiry $aCol(0) code $aCol(7)}
            foreach sStgName $lsStgNamePlan sStgValue $lsStgValuePlan {
               set sStgValue [pRegSubEvalEscape $sStgValue]
               pMqlCmd \"escape mod inquiry \\042$aCol(0)\\042 add argument \\042$sStgName\\042 '$sStgValue'\"
            }
         } else {
            if {$sHidden != $sHiddenActual || $aCol(3) != $aDat(3) || $aCol(4) != $aDat(4) || $aCol(7) != $aDat(7)} {
               foreach iCol [list 3 4] {set aCol($iCol) [pRegSubEvalEscape $aCol($iCol)]}
               pMqlCmd \"escape mod inquiry \\042$aCol(0)\\042 pattern '$aCol(3)' format '$aCol(4)' $sHidden\"
               set aCol(7) [pRegSubMqlEscape $aCol(7)]
               pAppend \"mql escape mod inquiry $aCol(0) code \\042$aCol(7)\\042\" FALSE
               if {$bScan != \"TRUE\"} {mql escape mod inquiry $aCol(0) code $aCol(7)}
               set bUpdate TRUE
            }
            pSetting inquiry $aCol(0) \"\" argument
         }
      } table {
         if {$bAdd} {
            pMqlCmd \"add table \\042$aCol(0)\\042 system $sHidden\"
            pPlanAdd $lsColumnNamePlan $sSchemaType $aCol(0) \"column name\" \"\"
         } else {
            pPlanActualAddDel $lsColumnNameActual \"\" $lsColumnNamePlan $sSchemaType \"\" $aCol(0) \"column delete name\" \"column name\" \"\"
            if {$sHidden != $sHiddenActual} {pMqlCmd \"escape mod table \\042$aCol(0)\\042 system $sHidden\"}
            set lsColumnNameActual [pPrintQuery \"\" \"column.name\" | spl]
            if {$lsColumnNameActual != $lsColumnNamePlan} {
               foreach sColumnNameP $lsColumnNamePlan {pMqlCmd \"mod table \\042$aCol(0)\\042 system column mod name \\042$sColumnNameP\\042 order [expr [lsearch $lsColumnNamePlan $sColumnNameP] + 1]\"}
            }
         }
      } column {
         if {$aCol(2) != $aDat(2)} {
            set aCol(2) [pRegSubEvalEscape $aCol(2)]
            pMqlCmd \"mod table \\042$aCol(0)\\042 system column mod name \\042$aCol(1)\\042 label \\042$aCol(2)\\042\"
         }
         if {$aCol(4) != $aDat(4) || $aCol(5) != $aDat(5)} {
            set aCol(5) [pRegSubEvalEscape $aCol(5)]
            if {$aCol(4) == \"bus\" && $aCol(5) == \"\"} {set aCol(5) \"dummy\"}
	    #Modified below for 359584 to handle single quote issue - start
            pMqlCmd \"escape mod table \\042$aCol(0)\\042 system column mod name \\042$aCol(1)\\042 $aCol(4) \\042$aCol(5)\\042\"
   	    #Modified below for 359584 to handle single quote issue - end
         }
         if {$aCol(6) != $aDat(6)} {
            set aCol(6) [pRegSubEvalEscape $aCol(6)]
            pMqlCmd \"mod table \\042$aCol(0)\\042 system column mod name \\042$aCol(1)\\042 href '$aCol(6)'\"
         }
         pSetting table $aCol(0) \"system column mod name \\134\\042$aCol(1)\\134\\042\" setting
		 
         if { 1 == 1 } {
            pPlanActualAddDel $lsUserActual \"\" $lsUserPlan table \"\" $aCol(0) \"column mod name \\042$aCol(1)\\042 remove user\" \"column mod name \\042$aCol(1)\\042 add user\" \"\"
            foreach sFld [list 10 11 12 13] sLink [list alt range update sorttype] {
               if {$aCol($sFld) != $aDat($sFld)} {
                  set aCol($sFld) [pRegSubEvalEscape $aCol($sFld)]
                  if {[string first \"\\047\" $aCol($sFld)] < 0 && [string first \"javascript\" [string tolower $aCol($sFld)]] < 0} {
                     pMqlCmd \"escape mod table \\042$aCol(0)\\042 system column mod name \\042$aCol(1)\\042 $sLink '$aCol($sFld)'\"
                  } else {
                     pMqlCmd \"escape mod table \\042$aCol(0)\\042 system column mod name \\042$aCol(1)\\042 $sLink \\042$aCol($sFld)\\042\"
                  }
               }
            }
            
            #Allow hidden column parameter
            set sFld 14
            set sFldValue $aCol($sFld)
            if { $sFldValue != \"\" } {
              pMqlCmd \"escape mod table \\042$aCol(0)\\042 system column mod name \\042$aCol(1)\\042 $sFldValue\"
            }
            
            
         } else {
            pPlanAdd \"all\" table $aCol(0) \"column mod name \\042$aCol(1)\\042 remove user\" \"\"
            pPlanAdd $lsUserPlan table $aCol(0) \"column mod name \\042$aCol(1)\\042 add user\" \"\"
         }
      } webform {
         if {$bAdd} {
            pMqlCmd \"add form \\042$aCol(0)\\042 web $sHidden\"
            pPlanAdd $lsTypePlan form $aCol(0) \"type\" \"\"
            pPlanAdd $lsColumnNamePlan form $aCol(0) \"field bus dummy name\" \"\"
         } else {
            if {$sHidden != $sHiddenActual} {pMqlCmd \"mod form \\042$aCol(0)\\042 $sHidden\"}
            pPlanActualAddDel $lsTypeActual \"\" $lsTypePlan form \"\" $aCol(0) \"type delete\" \"type\" \"\"
            if {$lsColumnNamePlan != $lsColumnNameActual} {
               pPlanActualAddDel $lsColumnNameActual \"\" $lsColumnNamePlan form \"\" $aCol(0) \"field delete name\" \"field name\" \"\"
               set lsColumnNameActual [pPrintQuery \"\" \"field.name\" | spl]
               if {$lsColumnNameActual != $lsColumnNamePlan} {
                  foreach sColumnNameP $lsColumnNamePlan {
                     pMqlCmd \"mod form \\042$aCol(0)\\042 field mod name \\042$sColumnNameP\\042 order [expr [lsearch $lsColumnNamePlan $sColumnNameP] + 1]\"
                  }
               }
            }
         }
      } field {
#         set sModifier \"$sNumberActual\"
#         if {[catch {mql mod form $aCol(0) field mod $sNumberActual} sMsg] != 0} {
            set sModifier \"name \\042$aCol(1)\\042\"
#         }
         if {$aCol(4) != $aDat(4) || $aCol(5) != $aDat(5)} {
            set aCol(5) [pRegSubEvalEscape $aCol(5)]
	    #Modified below for 359584 to handle single quote issue - start
            pMqlCmd \"escape mod form \\042$aCol(0)\\042 field mod $sModifier $aCol(4) \\042$aCol(5)\\042\"
	    #Modified below for 359584 to handle single quote issue - end
         }
         if {$aCol(2) != $aDat(2)} {pMqlCmd \"mod form \\042$aCol(0)\\042 field mod $sModifier label \\042$aCol(2)\\042\"}
         foreach sFld [list 6 10 11 12] sLink [list href alt range update] {
            if {$aCol($sFld) != $aDat($sFld)} {
               set aCol($sFld) [pRegSubEvalEscape $aCol($sFld)]
               if {[string first \"\\047\" $aCol($sFld)] < 0 && [string first \"javascript\" [string tolower $aCol($sFld)]] < 0} {
                  pMqlCmd \"escape mod form \\042$aCol(0)\\042 field mod $sModifier $sLink '$aCol($sFld)'\"
               } else {
                  pMqlCmd \"escape mod form \\042$aCol(0)\\042 field mod $sModifier $sLink \\042$aCol($sFld)\\042\"
               }
            }
         }
         pSetting form $aCol(0) \"field mod $sModifier\" setting
         pPlanActualAddDel $lsUserActual \"\" $lsUserPlan form \"\" $aCol(0) \"field mod $sModifier remove user\" \"field mod $sModifier add user\" \"\"
      }
   }
   return 0
}
" 1 0 0 0 0 0 0 0 0 0 0 0 "" 0 0
 0 1
 SpinnerAgent NULL noname "3/27/2017 3:41:28 PM" 0
"12/6/2015 11:42:58 PM" "3/14/2018 3:57:25 PM"
7
 0 1 "12/6/2015 11:42:58 PM" creator "add program emxSpinnerWebComp.tcl mql execute immediate !needsbusinessobject !downloadable !pipe !pooled nothidden file ./Business/SourceFiles/emxSpinnerWebComp.tcl"
 0 2 "12/6/2015 11:42:58 PM" creator "add property SpinnerAgent on program emxSpinnerWebComp.tcl value '12/6/2015 11:42:58 PM'"
 0 2 "12/6/2015 11:42:58 PM" creator "mod program emxSpinnerWebComp.tcl description ''"
 0 2 "2/3/2016 5:21:01 PM" creator "mod property SpinnerAgent on program emxSpinnerWebComp.tcl value '2/3/2016 5:21:01 PM'"
 0 2 "2/3/2016 5:21:01 PM" creator "mod program emxSpinnerWebComp.tcl file ./Business/SourceFiles/emxSpinnerWebComp.tcl"
 0 2 "3/27/2017 3:41:28 PM" creator "mod property SpinnerAgent on program emxSpinnerWebComp.tcl value '3/27/2017 3:41:28 PM'"
 0 2 "3/27/2017 3:41:28 PM" creator "mod program emxSpinnerWebComp.tcl file ./Business/SourceFiles/emxSpinnerWebComp.tcl"

!MTRX!END

!MTRX!AD! program emxSpinnerTrigger.tcl "3DEXPERIENCE R2015x(24.0.0.0)"
emxSpinnerTrigger.tcl 0 "" "#########################################################################*10.58
#
# @progdoc      emxSpinnerTrigger.tcl vM10.58 (Build 5.1.12)
#
# @Description: Procedures for running in Triggers
#
# @Parameters:  Returns 0 if successful, 1 if not
#
# @Usage:       Utilized by emxSpinnerAgent.tcl
#
# @progdoc      Copyright (c) MatrixOne Inc. 2005
#
#########################################################################
#
# @Modifications: FirstName LastName MM/DD/YYYY - Modification
#
#########################################################################

# Procedure to analyze triggers
proc pAnalyzeTrigger {} {
   global aCol aDat bOut
   set sTrigTypePlan [string tolower \"$aCol(3)$aCol(4)\"]
   if {$sTrigTypePlan == \"check\" || $sTrigTypePlan == \"action\" || $sTrigTypePlan == \"eventcheck\" || $sTrigTypePlan == \"eventaction\" } {
      if {[string first \"event\" $sTrigTypePlan] == 0 && $aCol(5) == \"\" && $aCol(6) != \"\"} {
         pWriteWarningMsg \"\\nWARNING: Field 'Program' is blank while field 'Input' is not blank for '$aCol(0) $aCol(1)' trigger '$sTrigTypePlan'.\\nThis trigger will be removed if one is in place\"
      }
      set lsCatchTest [list action check]
      regsub \"event\" $sTrigTypePlan \"\" sTrigTypePlan
   } else {
      set lsCatchTest trigger
   }
   if {[string tolower $aCol(0)] == \"policy\"} {
      set sCatchStringOne [string tolower \"state $aCol(2)\"]
      set bPass false
   } else {
      set sCatchStringOne \"\"
      set bPass true
   }
   set sCatchStringTwo \"\"
   set aDat(5) \"\"
   set aDat(6) \"\"
   set lsPrint [split [pQuery \"\" \"print $aCol(0) \\042$aCol(1)\\042\"] \\n]
   foreach sPrint $lsPrint {
      set sPrint [string trim $sPrint]
      if {$sCatchStringOne != \"\"} {
         if {[string first $sCatchStringOne [string tolower $sPrint]] == 0} {
            set bPass true
            set sCatchStringOne \"\"
            set sCatchStringTwo \"state\"
         }
      } elseif {$sCatchStringTwo != \"\"} {
         if {[string first $sCatchStringTwo $sPrint] == 0} {break}
      }
      if {$bPass} {
         set bCatchTest false
         foreach sCatchTest $lsCatchTest {
            if {[string first \"$sCatchTest \" $sPrint] == 0} {
               if {$sTrigTypePlan == \"action\" || $sTrigTypePlan == \"check\"} {
                  if {$sCatchTest == $sTrigTypePlan} {
                     set bCatchTest true
                     break
                  }
               } else {
                  set bCatchTest true
                  break
               }
            }
         }
         if {$bCatchTest} {
            regsub \"$sCatchTest \" $sPrint \"\" sPrint
            if {$sCatchTest == \"trigger\"} {
               set lsTrig [split $sPrint \",\"]
               foreach sTrig $lsTrig {
                  regsub \":\" $sTrig \"|\" sTrig
                  set lslsTrig [split $sTrig |]
                  set sTrigTypeActual [string tolower [lindex $lslsTrig 0]]
                  if {$sTrigTypePlan == $sTrigTypeActual} {
                     set slsTrigProg [lindex $lslsTrig 1]
                     regsub \"\\134(\" $slsTrigProg \"|\" slsTrigProg
                     set lslsTrigProg [split $slsTrigProg |]
                     set aDat(5) [lindex $lslsTrigProg 0]
                     set aDat(6) [lindex $lslsTrigProg 1]
                     regsub \"\\134)\" $aDat(6) \"\" aDat(6)
                     break
                  }
               }
            } else {
               set sTrigTypeActual $sCatchTest
               if {$sTrigTypePlan == $sTrigTypeActual} {
                  regsub \" input \" $sPrint \"|\" sPrint
                  set lsTrig [split $sPrint |]
                  set aDat(5) [string trim [lindex $lsTrig 0]]
                  regsub -all \"'\" $aDat(5) \"\" aDat(5)
                  set aDat(6) [string trim [lindex $lsTrig 1]]
                  regsub -all \"'\" $aDat(6) \"\" aDat(6)
               }
            }
            break
         }
      }
   }
   pSetAction \"Modify $aCol(0) $aCol(1) $aCol(2) trigger $aCol(3)$aCol(4)\"
}

# Procedure to process triggers
proc pProcessTrigger {} {
   global aCol aDat
   if {$aCol(2) != \"\" && ( [string tolower $aCol(3)] == \"\" || [string tolower $aCol(3)] == \"event\" ) } {
      if {$aCol(5) != $aDat(5) || $aCol(6) != $aDat(6)} {
         pMqlCmd \"escape mod $aCol(0) \\042$aCol(1)\\042 state \\042$aCol(2)\\042 $aCol(4) \\042$aCol(5)\\042 input '$aCol(6)'\"
      }
   } else {
      set sStateName \"\"
      if {$aCol(2) != \"\"} {set sStateName \"state \\134\\042$aCol(2)\\134\\042\"}
      if {$aCol(5) != \"\"} {
         if {$aCol(5) != $aDat(5) || $aCol(6) != $aDat(6)} {
            set aCol(6) [pRegSubEvalEscape $aCol(6)]
            pMqlCmd \"escape mod $aCol(0) \\042$aCol(1)\\042 $sStateName add trigger $aCol(3) $aCol(4) \\042$aCol(5)\\042 input '$aCol(6)'\"
         }
      } elseif {$aDat(5) != \"\"} {
         pMqlCmd \"mod $aCol(0) \\042$aCol(1)\\042 $sStateName remove trigger $aCol(3) $aCol(4)\"
      }
   }
   return 0
}                                          
" 1 0 0 0 0 0 0 0 0 0 0 0 "" 0 0
 0 1
 SpinnerAgent NULL noname "3/27/2017 3:41:28 PM" 0
"12/6/2015 11:42:58 PM" "3/14/2018 3:57:25 PM"
7
 0 1 "12/6/2015 11:42:58 PM" creator "add program emxSpinnerTrigger.tcl mql execute immediate !needsbusinessobject !downloadable !pipe !pooled nothidden file ./Business/SourceFiles/emxSpinnerTrigger.tcl"
 0 2 "12/6/2015 11:42:58 PM" creator "add property SpinnerAgent on program emxSpinnerTrigger.tcl value '12/6/2015 11:42:58 PM'"
 0 2 "12/6/2015 11:42:58 PM" creator "mod program emxSpinnerTrigger.tcl description ''"
 0 2 "2/3/2016 5:21:01 PM" creator "mod property SpinnerAgent on program emxSpinnerTrigger.tcl value '2/3/2016 5:21:01 PM'"
 0 2 "2/3/2016 5:21:01 PM" creator "mod program emxSpinnerTrigger.tcl file ./Business/SourceFiles/emxSpinnerTrigger.tcl"
 0 2 "3/27/2017 3:41:28 PM" creator "mod property SpinnerAgent on program emxSpinnerTrigger.tcl value '3/27/2017 3:41:28 PM'"
 0 2 "3/27/2017 3:41:28 PM" creator "mod program emxSpinnerTrigger.tcl file ./Business/SourceFiles/emxSpinnerTrigger.tcl"

!MTRX!END

!MTRX!AD! program emxSpinnerProperty.tcl "3DEXPERIENCE R2015x(24.0.0.0)"
emxSpinnerProperty.tcl 0 "" "#########################################################################*10.62
#
# @progdoc      emxSpinnerProperty.tcl vM10.62 (Build 6.10.19)
#
# @Description: Procedures for running in Properties
#
# @Parameters:  Returns 0 if successful, 1 if not
#
# @Usage:       Utilized by emxSpinnerAgent.tcl
#
# @progdoc      Copyright (c) MatrixOne Inc. 2005
#
#########################################################################
#
# @Modifications: FirstName LastName MM/DD/YYYY - Modification
#
#########################################################################

# Procedure to analyze properties
proc pAnalyzeProperty {} {
   global aCol aDat lsPropertyValueActual lsToTypeNameActual sSystem sPropertyValueActual
   if {$aCol(2) == \"\"} {
      mql notice \"\\nERROR: Spinner file '*PropertyData*.*' field 'Property Name' is blank for '$aCol(0) $aCol(1)'\"
      return 1
   } elseif {( $aCol(4) == \"\" && $aCol(5) != \"\" ) || ( $aCol(4) != \"\" && $aCol(5) == \"\" ) } {
      mql notice \"\\nERROR: Spinner file '*PropertyData*.*' property '$aCol(2)' field 'To Type' or 'To Name' is blank.\\nBoth fields must have a value or both fields must be blank\"
      return 1
   }
   set sPropertyValueActual \"\"
   set lsPropertyValueActual [list ]
   set lsToTypeNameActual [list ]
   set aDat(4) \"\"
   set aDat(5) \"\"
   if {$aCol(0) != \"association\"} {
      set lsPropertyValueActual [split [pQuery \"\" \"print $aCol(0) \\042$aCol(1)\\042 $sSystem select property\\134\\133$aCol(2)\\134\\135.value dump |\"] |]
      set lsToTypeNameActual [split [pQuery \"\" \"print $aCol(0) \\042$aCol(1)\\042 $sSystem select property\\134\\133$aCol(2)\\134\\135.to dump |\"] |]
   } else {
      set lsPrint [split [pQuery \"\" \"print $aCol(0) \\042$aCol(1)\\042\"] \\n]
      foreach sPrint $lsPrint {
         if {[string first \"property\" $sPrint] == 0 && [string first $aCol(2) $sPrint] == 9} {
            if {[string first \" value \" $sPrint] > -1} {
               regsub \" value \" $sPrint \"|\" sPrint
               lappend lsPropertyValueActual [lindex [split $sPrint |] 1]
               set sPrint [lindex [split $sPrint |] 0]
            }
            if {[string first \" to \" $sPrint] > -1} {
               regsub \" to \" $sPrint \"|\" sPrint
               lappend lsToTypeNameActual [lindex [split $sPrint |] 1]
            }
         }
      }
   }
   foreach sPropertyValueActual $lsPropertyValueActual sToTypeNameActual $lsToTypeNameActual {
      if {$aCol(4) != \"\"} {
         regsub \" \" $sToTypeNameActual \"|\" slsToTypeNameActual
         set aDat(4) [lindex [split $slsToTypeNameActual |] 0]
         set aDat(5) [lindex [split $slsToTypeNameActual |] 1]
         if {$aCol(4) == $aDat(4) && $aCol(5) == $aDat(5)} {
            break
         } else {
            set aDat(4) \"\"
            set aDat(5) \"\"
            set sPropertyValueActual \"\"
         }
      } elseif {$sToTypeNameActual == \"\"} {
         break
      } else {
         set sPropertyValueActual \"\"
      }
   }
   pSetAction \"Modify $aCol(0) $aCol(1) property $aCol(2)\"
   return 0
}                                       

# Procedure to process properties
proc pProcessProperty {} {
   global aCol aDat bUpdate sSystem lsPropertyValueActual lsToTypeNameActual sPropertyValueActual bOut
   set bUpdate FALSE
   set sAddModify FALSE
   set sToSystem \"\"
   if {$aCol(4) == \"table\"} {set sToSystem system}
   if {$aCol(3) == \"\" && $aCol(4) == \"\" && $aCol(5) == \"\"} {
      foreach sPropertyValueActual $lsPropertyValueActual sToTypeNameActual $lsToTypeNameActual {
         regsub \" \" $sToTypeNameActual \"|\" slsToTypeNameActual
         set aDat(4) [lindex [split $slsToTypeNameActual |] 0]
         set aDat(5) [lindex [split $slsToTypeNameActual |] 1]
         set sCommand \"delete property \\042$aCol(2)\\042 on $aCol(0) \\042$aCol(1)\\042 $sSystem\"
         if {$aDat(4) != \"\"} {append sCommand \" to $aDat(4) \\042$aDat(5)\\042 $sToSystem\"}
         pMqlCmd $sCommand
      }
   } elseif {$aCol(3) == $sPropertyValueActual && $aCol(4) == $aDat(4) && $aCol(5) == $aDat(5)} {
   } elseif {$aCol(2) == \"SpinnerAgent\"} {
   } elseif {$aCol(0) == \"program\" && $aCol(1) == \"eServiceSchemaVariableMapping.tcl\" && $aCol(4) != \"\"} {
      set sTypeReplace $aCol(4)
      if {$aCol(4) == \"attribute\"} {set sTypeReplace \"att\"}
      if {[catch {set sSymbolicTest $aSymbolic($sTypeReplace|$aCol(5))} sMsg] == 0} {
         if {$sSymbolicTest != $aCol(2)} {pWriteWarningMsg \"\\nWARNING: Schema element `$aCol(4) $aCol(5)` symbolic name `$sSymbolicTest` is being changed to `$aCol(2)`\"}
         if {$aSymbolic($sTypeReplace|$aCol(5)) != \"\"} {pMqlCmd \"delete property \\042$aSymbolic($sTypeReplace|$aCol(5))\\042 on $aCol(0) \\042$aCol(1)\\042 to $sTypeReplace \\042$aCol(5)\\042 $sToSystem\"}
      }
      set sAddModify add
   } elseif {$sPropertyValueActual == \"\" && $aDat(4) == \"\"} {
      set sAddModify add
   } elseif {$aCol(3) != $sPropertyValueActual} {
      set sAddModify mod
   }
   if {$sAddModify != \"FALSE\"} {
      set aCol(3) [pRegSubEvalEscape $aCol(3)]
      if {$aCol(4) == \"\"} {
         pMqlCmd \"$sAddModify property \\042$aCol(2)\\042 on $aCol(0) \\042$aCol(1)\\042 $sSystem value \\042$aCol(3)\\042\"
      } elseif {$aCol(3) == \"\"} {
         pMqlCmd \"$sAddModify property \\042$aCol(2)\\042 on $aCol(0) \\042$aCol(1)\\042 $sSystem to $aCol(4) \\042$aCol(5)\\042 $sToSystem\"
      } else {
         pMqlCmd \"$sAddModify property $aCol(2) on $aCol(0) \\042$aCol(1)\\042 $sSystem to $aCol(4) \\042$aCol(5)\\042 $sToSystem value \\042$aCol(3)\\042\"
      }
   }
   return 0
}                                          
" 1 0 0 0 0 0 0 0 0 0 0 0 "" 0 0
 0 1
 SpinnerAgent NULL noname "3/27/2017 3:41:28 PM" 0
"12/6/2015 11:42:58 PM" "3/14/2018 3:57:25 PM"
7
 0 1 "12/6/2015 11:42:58 PM" creator "add program emxSpinnerProperty.tcl mql execute immediate !needsbusinessobject !downloadable !pipe !pooled nothidden file ./Business/SourceFiles/emxSpinnerProperty.tcl"
 0 2 "12/6/2015 11:42:58 PM" creator "add property SpinnerAgent on program emxSpinnerProperty.tcl value '12/6/2015 11:42:58 PM'"
 0 2 "12/6/2015 11:42:58 PM" creator "mod program emxSpinnerProperty.tcl description ''"
 0 2 "2/3/2016 5:21:01 PM" creator "mod property SpinnerAgent on program emxSpinnerProperty.tcl value '2/3/2016 5:21:01 PM'"
 0 2 "2/3/2016 5:21:01 PM" creator "mod program emxSpinnerProperty.tcl file ./Business/SourceFiles/emxSpinnerProperty.tcl"
 0 2 "3/27/2017 3:41:28 PM" creator "mod property SpinnerAgent on program emxSpinnerProperty.tcl value '3/27/2017 3:41:28 PM'"
 0 2 "3/27/2017 3:41:28 PM" creator "mod program emxSpinnerProperty.tcl file ./Business/SourceFiles/emxSpinnerProperty.tcl"

!MTRX!END

!MTRX!AD! program emxSpinnerRule.tcl "3DEXPERIENCE R2015x(24.0.0.0)"
emxSpinnerRule.tcl 0 "" "#########################################################################*10.58
#
# @progdoc      emxSpinnerRule.tcl vM10.58 (Build 5.1.12)
#
# @Description: Procedures for running in Rules
#
# @Parameters:  Returns 0 if successful, 1 if not
#
# @Usage:       Utilized by emxSpinnerAgent.tcl
#
# @progdoc      Copyright (c) MatrixOne Inc. 2005
#
#########################################################################
#
# @Modifications: FirstName LastName MM/DD/YYYY - Modification
#
#########################################################################

# Procedure to analyze rules
proc pAnalyzeRule {} {
   global aCol aDat bOverlay bAdd lsProgramPlan lsProgramActual lsAttributePlan lsAttributeActual lsRelationshipPlan lsRelationshipActual lsFormPlan lsFormActual lsAccessPlan lsAccessActual bUseAccessField lsSchemaType
   set lsProgramPlan [pTrimList $aCol(3)]
   set lsAttributePlan [pTrimList $aCol(4)]
   if {[lsearch $lsSchemaType attribute] >= 0} {set lsAttributePlan [pCheckNameChange $lsAttributePlan attribute]}
   set lsRelationshipPlan [pTrimList $aCol(5)]
   if {[lsearch $lsSchemaType relationship] >= 0} {set lsRelationshipPlan [pCheckNameChange $lsRelationshipPlan relationship]}
   set lsFormPlan [pTrimList $aCol(6)]
   set lsAccessPlan [pTrimList $aCol(7)]
   set lsProgramActual [list ]
   set lsAttributeActual [list ]
   set lsRelationshipActual [list ]
   set lsFormActual [list ]
   set lsAccessActual [list ]
   if {$bAdd != \"TRUE\"} {
      if {$bUseAccessField} {set lsAccessActual [pQueryAccess rule $aCol(0) access]}
      set lsPrint [split [pQuery \"\" \"print rule \\042$aCol(0)\\042\"] \\n]
      foreach sPrint $lsPrint {
         set sPrint [string trim $sPrint]
         foreach sReference [list program attribute \"Relationship Type\" form] {
            if {[string first $sReference $sPrint] == 0} {
               regsub \"$sReference\\: \" $sPrint \"\" slsReference
               regsub -all \", \" $slsReference \"|\" slsReference
               set lsReference [split $slsReference |]
               switch $sReference {
                  program {
                     set lsProgramActual $lsReference
                  } attribute {
                     set lsAttributeActual $lsReference
                  } \"Relationship Type\" {
                     set lsRelationshipActual $lsReference
                  } form {
                     set lsFormActual $lsReference
                  }
               }
            }
         }
      }
   }
   if {$bOverlay} {
      set lsProgramPlan [pOverlayList $lsProgramPlan $lsProgramActual]
      set lsAttributePlan [pOverlayList $lsAttributePlan $lsAttributeActual]
      set lsRelationshipPlan [pOverlayList $lsRelationshipPlan $lsRelationshipActual]
      set lsFormPlan [pOverlayList $lsFormPlan $lsFormActual]
      set lsAccessPlan [pOverlayList $lsAccessPlan $lsAccessActual]
   }
}                                       

# Procedure to process rules
proc pProcessRule {} {
   global aCol aDat bAdd lsSchemaType lsProgramPlan lsProgramActual lsAttributePlan lsAttributeActual lsRelationshipPlan lsRelationshipActual lsFormPlan lsFormActual lsAccessPlan lsAccessActual bUseAccessField sHidden sHiddenActual
   if {$bAdd} {
      pMqlCmd \"add rule \\042$aCol(0)\\042 $sHidden\"
      foreach sSchemaItem [list program attribute relationship form] lsRefPlan [list $lsProgramPlan $lsAttributePlan $lsRelationshipPlan $lsFormPlan] {
         foreach sRefPlan $lsRefPlan {pMqlCmd \"mod $sSchemaItem \\042$sRefPlan\\042 add rule \\042$aCol(0)\\042\"}
      }
      if {$bUseAccessField} {pPlanAdd $lsAccessPlan rule $aCol(0) \"add user\" \"\"}
   } else {
      if {$sHidden != $sHiddenActual} {pMqlCmd \"mod rule \\042$aCol(0)\\042 $sHidden\"}
      foreach sSchemaItem [list program attribute relationship form] lsRefPlan [list $lsProgramPlan $lsAttributePlan $lsRelationshipPlan $lsFormPlan] lsRefActual [list $lsProgramActual $lsAttributeActual $lsRelationshipActual $lsFormActual] {
         foreach sRefPlan $lsRefPlan sRefActual $lsRefActual {
            if {$sRefActual != \"\" && [lsearch $lsRefPlan $sRefActual] < 0} {pMqlCmd \"mod $sSchemaItem \\042$sRefActual\\042 remove rule \\042$aCol(0)\\042\"}
            if {$sRefPlan != \"\" && [lsearch $lsRefActual $sRefPlan] < 0} {pMqlCmd \"mod $sSchemaItem \\042$sRefPlan\\042 add rule \\042$aCol(0)\\042\"}
         }
      }
      if {$bUseAccessField} {pPlanActualAddDel $lsAccessActual \"\" $lsAccessPlan rule \"\" $aCol(1) \"remove user\" \"add user\" \"\"}
   }
   return 0
}                                          
" 1 0 0 0 0 0 0 0 0 0 0 0 "" 0 0
 0 1
 SpinnerAgent NULL noname "3/27/2017 3:41:28 PM" 0
"12/6/2015 11:42:58 PM" "3/14/2018 3:57:25 PM"
7
 0 1 "12/6/2015 11:42:58 PM" creator "add program emxSpinnerRule.tcl mql execute immediate !needsbusinessobject !downloadable !pipe !pooled nothidden file ./Business/SourceFiles/emxSpinnerRule.tcl"
 0 2 "12/6/2015 11:42:58 PM" creator "add property SpinnerAgent on program emxSpinnerRule.tcl value '12/6/2015 11:42:58 PM'"
 0 2 "12/6/2015 11:42:58 PM" creator "mod program emxSpinnerRule.tcl description ''"
 0 2 "2/3/2016 5:21:01 PM" creator "mod property SpinnerAgent on program emxSpinnerRule.tcl value '2/3/2016 5:21:01 PM'"
 0 2 "2/3/2016 5:21:01 PM" creator "mod program emxSpinnerRule.tcl file ./Business/SourceFiles/emxSpinnerRule.tcl"
 0 2 "3/27/2017 3:41:28 PM" creator "mod program emxSpinnerRule.tcl file ./Business/SourceFiles/emxSpinnerRule.tcl"
 0 2 "3/27/2017 3:41:29 PM" creator "mod property SpinnerAgent on program emxSpinnerRule.tcl value '3/27/2017 3:41:28 PM'"

!MTRX!END

!MTRX!AD! program emxSpinnerCompare.tcl "3DEXPERIENCE R2015x(24.0.0.0)"
emxSpinnerCompare.tcl 0 "" "#########################################################################
#
# @progdoc      emxSpinnerCompare.tcl vM10.63 (Build 7.3.1)
#
# @Description: Simple utility to compare schema metadata using spinner files.
#
# @Parameters:  See User-Defined Variables below
#
# @Usage:       Run this program for an MQL command window w/data files in directories set
#               in the User Defined Path sections.
#
# @progdoc      Copyright (c) MatrixOne Inc., October 7, 2003
#
#########################################################################
#
# @Modifications: Matt Osterman 03/01/2007 - vM10.63 Bug Fixes and Enhancements
#
#########################################################################
tcl;

eval {
   if {[info host] == \"mostermant43\" } {
      source \"c:/Program Files/TclPro1.3/win32-ix86/bin/prodebug.tcl\"
   	  set cmd \"debugger_eval\"
   	  set xxx [debugger_init]
   } else {
   	  set cmd \"eval\"
   }
}
$cmd {

   set rTcl [info tcl]
   set sPath1 [mql get env 1]
   set sPath2 [mql get env 2]
   set sMerge [string tolower [mql get env 3]]
   if {$sMerge == \"merge\"} {
      set bMerge TRUE
   } else {
      set bMerge FALSE
   }

############################################################
#                  User defined paths
############################################################

   if {$sPath1 == \"\"} {
      set sPath1 \"C:/Temp/Spinner1\"
   }
   if {$sPath2 == \"\"} {
      set sPath2 \"C:/Temp/Spinner2\"
   }

############################################################

# Procedure to pull extra quotes generated by Excel saves plus tagged dumper values
   proc pRegSubExcel {sExcel} {
     if {[string range $sExcel 0 0] == \"\\042\" && [string range $sExcel end end] == \"\\042\" && [string length $sExcel] > 2} {
   	     set iLast [expr [string length $sExcel] -2]
      	 set sExcel [string range $sExcel 1 $iLast]
      	 regsub -all \"\\042\\042\" $sExcel \"\\042\" sExcel
      	 regsub -all \"<NULL>\" $sExcel \"\" sExcel
      }
      return $sExcel
   }

# Procedure to trim list ranges
   proc pTrimList {sList sDelimiter} {
      set lsList [split $sList $sDelimiter]
      set lsListPlan \"\"
      foreach sList $lsList {
      	 set sList [pRegSubExcel $sList]
         lappend lsListPlan [string trim $sList]
      }
      return $lsListPlan
   }

# Procedure to compare program source code
   proc pProgCheck {sProgramFile1 sProgramFile2 sProgPage} {
      global sPath1 sPath2 bOK sPathA sPathB
      regsub -all \"/\" $sProgramFile1 \"SLASH\" sProgramFile1
      if {$sProgPage == \"Program\"} {
         set sProgPage \"SourceFiles\"
      } else {
         set sProgPage \"PageFiles\"
      }
      if {[catch {set iSourceFile [open \"$sPath1/Business/$sProgPage/$sProgramFile1\" r]} sMsg] != 0} {
         puts \"\\nERROR: $sProgPage file `$sPath1/Business/$sProgPage/$sProgramFile1` does not exist.\"
         exit 1
         return
      } else {
         set sCode1 [read $iSourceFile]
         set sCodeTrim1 [string trim $sCode1]
         close $iSourceFile
      }
      regsub -all \"/\" $sProgramFile2 \"SLASH\" sProgramFile2
      if {[catch {set iSourceFile [open \"$sPath2/Business/$sProgPage/$sProgramFile2\" r]} sMsg] != 0} {
         puts \"\\nERROR: $sProgPage file `$sPath2/Business/$sProgPage/$sProgramFile2` does not exist.\"
         exit 1
         return
      } else {
         set sCode2 [read $iSourceFile]
         set sCodeTrim2 [string trim $sCode2]
         close $iSourceFile
      }
      if {[string first $sCode1 $sCode2] == -1 && $sCodeTrim1 != $sCodeTrim2} {
         set bOK FALSE
         catch {file copy \"$sPath1/Business/$sProgPage/$sProgramFile1\" \"$sPathA/Business/$sProgPage/$sProgramFile1\"} sMsg
         catch {file copy \"$sPath2/Business/$sProgPage/$sProgramFile2\" \"$sPathB/Business/$sProgPage/$sProgramFile2\"} sMsg
      }
   }

# Procedure to merge plan and actual lists for bOverlay switch
   proc pMergeList {lsPlan lsValue lsActual lsTrueValue sType} {
      set lsDel \"\"
      set lsPlanTemp \"\"
      set lsValueTemp \"\"
      foreach sPlan $lsPlan sValue $lsValue {
         if {$sType == \"ATTR\" && [string first \"<>\" $sPlan] >= 0} {
            lappend lsDel \"[string range $sPlan 0 [string first \"^\" $sPlan]]\"
         } elseif {[string first \"<<\" $sPlan] >= 0 && [string first \">>\" $sPlan] == [expr [string length $sPlan] -2]} {
            if {$sType == \"ATTR\"} {
               set iRange [string first \"<<\" $sPlan]
               set sPrePlan [string range $sPlan 0 [expr $iRange - 1]]
               set sPlan [string range $sPlan $iRange end]
            }
            regsub \"<<\" $sPlan \"\" sPlan
            regsub \">>\" $sPlan \"\" sPlan
            set sPlan [string trim $sPlan]
            if {$sType == \"ATTR\"} {set sPlan \"$sPrePlan$sPlan\"}
            if {[lsearch $lsActual $sPlan] >= 0} {lappend lsDel $sPlan}
         } else {
            lappend lsPlanTemp $sPlan
            lappend lsValueTemp $sValue
         }
      }
      set lsPlan \"\"
      set lsValue \"\"
      set iCtrTemp 0
      foreach sActual $lsActual sTrueValue $lsTrueValue {
         if {$lsDel != \"\" && [lsearch $lsDel $sActual] >= 0} {
         } else {
            set iPlace [lsearch $lsPlanTemp $sActual]
            if {$sType == \"STATE\" && $sTrueValue != \"\"} {
               set iPlaceSt [lsearch $lsValueTemp $sTrueValue]
               if {$iPlaceSt >= 0} {set iPlace $iPlaceSt}
            }
            if {$iPlace >= 0} {
               for {} {$iCtrTemp <= $iPlace} {incr iCtrTemp} {
                  lappend lsPlan [lindex $lsPlanTemp $iCtrTemp]
                  lappend lsValue [lindex $lsValueTemp $iCtrTemp]
               }
            } else {
               lappend lsPlan $sActual
               lappend lsValue $sTrueValue
            }
         }
      }
      for {} {$iCtrTemp < [llength $lsPlanTemp]} {incr iCtrTemp} {
         lappend lsPlan [lindex $lsPlanTemp $iCtrTemp]
         lappend lsValue [lindex $lsValueTemp $iCtrTemp]
      }
      return [list $lsPlan $lsValue]
   }

# Main

   set sSuffix [clock format [clock seconds] -format \"%Y%m%d-%H%M\"]
   set sOS [string tolower $tcl_platform(os)]
   if { [string tolower [string range $sOS 0 5]] == \"window\" } {
      set sPath \"c:/temp/SpinCompare$sSuffix\"
   } else {
      set sPath \"/tmp/SpinCompare$sSuffix\"
   }
   file mkdir $sPath
   if {$bMerge} {
      set sPathA \"$sPath/SpinnerMergeSet_2-1\"
      set sPathB \"$sPath/SpinnerMergeSet_1-2\"
   } else {
      set sPathA \"$sPath/SpinnerDeltaSet1\"
      set sPathB \"$sPath/SpinnerDeltaSet2\"
   }
   set sPathC \"$sPath/SpinnerClash\"
   file mkdir \"$sPathA/Business\"
   file mkdir \"$sPathB/Business\"
   file mkdir \"$sPathA/Business/SourceFiles\"
   file mkdir \"$sPathB/Business/SourceFiles\"
   file mkdir \"$sPathA/Business/Policy\"
   file mkdir \"$sPathB/Business/Policy\"
   file mkdir \"$sPathA/Business/PageFiles\"
   file mkdir \"$sPathB/Business/PageFiles\"
   file mkdir \"$sPathA/System\"
   file mkdir \"$sPathB/System\"
   file mkdir \"$sPathC\"

   set iLog [open \"$sPath/SpinCompare.log\" w]
   puts $iLog \"Spinner Set #1: $sPath1\\nSpinner Set #2: $sPath2\\n\"

# Business Files

   set lsFile [list Program Role Group Person Association Attribute Type Relationship Format Policy PolicyState PolicyStateSignature Table TableColumn WebForm WebFormField \"Menu\" Command Inquiry Channel Portal Trigger Property Expression Interface Page Vault_Local Vault_Remote Vault_Foreign Store_Captured Site Location Server]
   array set aSystem [list Vault_Local Vault Vault_Remote Vault Vault_Foreign Vault Store_Captured Store Site Site Location Location Server Server]
   set lsRegister [list Role Group Association Attribute Type Relationship \"Format\" Policy Table WebForm \"Menu\" Command Inquiry Channel Portal \"Interface\" \"Expression\" Vault_Local Vault_Remote Vault_Foreign Store_Captured Site Location Server]
   array set aMulti [list Association [list ] Attribute [list 5] Channel [list 6 7 8] Command [list 6 7 8] \"Format\" [list ] Group [list 3 4 5] Inquiry [list 5 6] \"Menu\" [list 6 7 8] Person [list 10 11] Policy [list 6 7 10 11] PolicyState [list 6 7 11] PolicyStateSignature [list 3 4 5] Portal [list 6 7 8] Program [list ] Property [list ] Relationship [list 3 7 13] Role [list 3 4 5] Rule [list 3 4 5 6 7] TableColumn [list 7 8 9] Table [list 3] Trigger [list ] Type [list 5 6] WebForm [list 3] WebFormField [list 7 8 9] \"Page\" [list ] \"Expression\" [list ] \"Interface\" [list ] ]
   foreach sFile $lsFile {
      set lsSchema1 \"\"
      set lsSchema2 \"\"
      set bSystem FALSE
      if {[lsearch [list Vault_Local Vault_Remote Vault_Foreign Store_Captured Site Location Server] $sFile] >= 0} {set bSystem TRUE}
      set bRegister FALSE
      if {[lsearch $lsRegister $sFile] >= 0} {set bRegister TRUE}
      set bInFile1 FALSE
      set bInFile2 FALSE
      if {[catch {
         if {$bSystem} {
            if {[file exists \"$sPath1/System/$sFile\\.xls\"] == 1} {
               set bInFile1 TRUE
               set iFile1 [open \"$sPath1/System/$sFile\\.xls\" r]
            }
            if {[file exists \"$sPath2/System/$sFile\\.xls\"] == 1} {
               set bInFile2 TRUE
               set iFile2 [open \"$sPath2/System/$sFile\\.xls\" r]
            }
         } else {
            if {[file exists \"$sPath1/Business/Spinner$sFile\\Data.xls\"] == 1} {
               set bInFile1 TRUE
               set iFile1 [open \"$sPath1/Business/Spinner$sFile\\Data.xls\" r]
            }
            if {[file exists \"$sPath2/Business/Spinner$sFile\\Data.xls\"] == 1} {
               set bInFile2 TRUE
               set iFile2 [open \"$sPath2/Business/Spinner$sFile\\Data.xls\" r]
            }
         }
      } sMsg] != 0} {
      	 set sMessage \"Warning: Error opening files for '$sFile' so not processed.\"
         puts $sMessage
         puts $iLog $sMessage
         continue
      }
      if {!$bInFile1 && !$bInFile2} {
      	 set sMessage \"Warning: Files for '$sFile' not found in schema sets 1 and 2 so not processed.\"
         puts $sMessage
         puts $iLog $sMessage
         continue
      }
      puts \"Processing $sFile...\"
      if {$bSystem} {
         if {$bInFile1 && !$bInFile2} {
            catch {
               file copy \"$sPath1/System/$sFile.xls\" \"$sPath/$sFile\\_1Unique.xls\"
               file copy \"$sPath1/System/$sFile.xls\" \"$sPathA/System/$sFile\\.xls\"
            } sMsg
            continue
         } elseif {!$bInFile1 && $bInFile2} {
            catch {
               file copy \"$sPath2/System/$sFile.xls\" \"$sPath/$sFile\\_2Unique.xls\"
               file copy \"$sPath2/System/$sFile.xls\" \"$sPathB/System/$sFile\\.xls\"
            }
            continue
         }
         set oFile3 [open \"$sPath/$sFile\\_1Unique.xls\" w]
         set oFile5 [open \"$sPathA/System/$sFile\\.xls\" w]
         set oFile4 [open \"$sPath/$sFile\\_2Unique.xls\" w]
         set oFile6 [open \"$sPathB/System/$sFile\\.xls\" w]
         set oFile1 [open \"$sPath/$sFile\\_Match.xls\" w]
         set oFile2 [open \"$sPath/$sFile\\_Delta.xls\" w]
         set oFile7 [open \"$sPathC/$sFile\\.xls\" w]
      } else {
         if {$bInFile1 && !$bInFile2} {
            catch {
               file copy \"$sPath1/Business/Spinner$sFile\\Data.xls\" \"$sPath/Spinner$sFile\\Data_1Unique.xls\"
               file copy \"$sPath1/Business/Spinner$sFile\\Data.xls\" \"$sPathA/Business/Spinner$sFile\\Data.xls\"
               if {$sFile == \"Program\"} {
                  set lsSource [glob \"$sPath1/Business/SourceFiles/*\"]
                  foreach sSource $lsSource {
                     set sSourceFile [file tail $sSource]
                     file copy \"$sSource\" \"$sPathA/Business/SourceFiles/$sSourceFile\"
                  }
               } elseif {$sFile == \"Page\"} {
                  set lsPage [glob \"$sPath1/Business/PageFiles/*\"]
                  foreach sPage $lsPage {
                     set sPageFile [file tail $sPage]
                     file copy \"$sPage\" \"$sPathA/Business/PageFiles/$sPageFile\"
                  }
               }
            } sMsg
            continue
         } elseif {!$bInFile1 && $bInFile2} {
            catch {
               file copy \"$sPath2/Business/Spinner$sFile\\Data.xls\" \"$sPath/Spinner$sFile\\Data_2Unique.xls\"
               file copy \"$sPath2/Business/Spinner$sFile\\Data.xls\" \"$sPathB/Business/Spinner$sFile\\Data.xls\"
               if {$sFile == \"Program\"} {
                  set lsSource [glob \"$sPath2/Business/SourceFiles/*\"]
                  foreach sSource $lsSource {
                     set sSourceFile [file tail $sSource]
                     file copy \"$sSource\" \"$sPathB/Business/SourceFiles/$sSourceFile\"
                  }
               } elseif {$sFile == \"Page\"} {
                  set lsPage [glob \"$sPath2/Business/PageFiles/*\"]
                  foreach sPage $lsPage {
                     set sPageFile [file tail $sPage]
                     file copy \"$sPage\" \"$sPathB/Business/PageFiles/$sPageFile\"
                  }
               }
            }
            continue
         }
         set oFile3 [open \"$sPath/Spinner$sFile\\Data_1Unique.xls\" w]
         set oFile5 [open \"$sPathA/Business/Spinner$sFile\\Data.xls\" w]
         set oFile4 [open \"$sPath/Spinner$sFile\\Data_2Unique.xls\" w]
         set oFile6 [open \"$sPathB/Business/Spinner$sFile\\Data.xls\" w]
         set oFile1 [open \"$sPath/Spinner$sFile\\Data_Match.xls\" w]
         set oFile2 [open \"$sPath/Spinner$sFile\\Data_Delta.xls\" w]
         set oFile7 [open \"$sPathC/$sFile\\.xls\" w]
      }
      set bFile1 FALSE
      set bFile2 FALSE
      set bFile3 FALSE
      set bFile4 FALSE
      set bFile5 FALSE
      set bFile6 FALSE
      set bFile7 FALSE

      if {$bInFile1} {
         set lsData1 [split [string trim [read $iFile1]] \\n]
         set sHeader1 [string trim [lindex $lsData1 0]]
      } else {
         set lsData1 [list ]
         set sHeader1 \"\"
      }
      if {$bInFile2} {
         set lsData2 [split [string trim [read $iFile2]] \\n]
         set sHeader2 [string trim [lindex $lsData2 0]]
      } else {
         set lsData2 [list ]
         set sHeader2 \"\"
      }
      if {$rTcl > 8.29} {
         set lsData1 [lsort -unique -dictionary $lsData1]
         set lsData2 [lsort -unique -dictionary $lsData2]
      } else {
         set lsData1 [lsort -dictionary $lsData1]
         set lsData2 [lsort -dictionary $lsData2]
      }
      set iLength1 [llength $lsData1]
      set iLength2 [llength $lsData2]
      puts $oFile1 $sHeader1
      puts $oFile2 \"No.\\t$sHeader1\"
      puts $oFile3 $sHeader1
      puts $oFile4 $sHeader2
      puts $oFile5 $sHeader1
      puts $oFile6 $sHeader2
      puts $oFile7 \"No.\\t$sHeader1\"

      if {$bInFile1} {
         for {set iIndexData1 0} {$iIndexData1 < $iLength1} {incr iIndexData1} {
            set slsData1 [string trim [lindex $lsData1 $iIndexData1]]
            if {[lindex [split $slsData1 \\t] 0] != \"\"} {break}
         }
      } else {
         set slsData1 \"\"
      }
      if {$bInFile2} {
         for {set iIndexData2 0} {$iIndexData2 < $iLength2} {incr iIndexData2} {
            set slsData2 [string trim [lindex $lsData2 $iIndexData2]]
            if {[lindex [split $slsData2 \\t] 0] != \"\"} {break}
         }
      } else {
         set slsData2 \"\"
      }

      while {$slsData1 != \"\" || $slsData2 != \"\"} {
      	 set bMerge1 FALSE
      	 set bMerge2 FALSE
         set lslsData1 [pTrimList $slsData1 \"\\t\"]
         set sCol11 [lindex $lslsData1 0]
         set sCol12 [lindex $lslsData1 1]
         set sCol13 [lindex $lslsData1 2]
         set sCol14 [lindex $lslsData1 3]
         set sCol15 [lindex $lslsData1 4]
         set sCol16 [lindex $lslsData1 5]
         set lslsData2 [pTrimList $slsData2 \"\\t\"]
         set sCol21 [lindex $lslsData2 0]
         set sCol22 [lindex $lslsData2 1]
         set sCol23 [lindex $lslsData2 2]
         set sCol24 [lindex $lslsData2 3]
         set sCol25 [lindex $lslsData2 4]
         set sCol26 [lindex $lslsData2 5]

         set bSame FALSE
         if {$sCol11 != \"\" && $sCol21 != \"\"} {
            switch $sFile {
               PolicyState - TableColumn - WebFormField {
                  if {$sCol11 == $sCol21 && $sCol12 == $sCol22} {
                     set bSame TRUE
                  }
               } PolicyStateSignature {
                  if {$sCol11 == $sCol21 && $sCol12 == $sCol22 && $sCol13 == $sCol23} {
                     set bSame TRUE
                  }
               } Trigger {
                  if {$sCol11 == $sCol21 && $sCol12 == $sCol22 && $sCol13 == $sCol23 && $sCol14 == $sCol24 && $sCol15 == $sCol25} {
                     set bSame TRUE
                  }
               } Property {
                  if {$sCol11 == $sCol21 && $sCol12 == $sCol22 && $sCol13 == $sCol23 && $sCol15 == $sCol25 && $sCol16 == $sCol26} {
                     set bSame TRUE
                  }
               } default {
                  if {$sCol11 == $sCol21} {
                     set bSame TRUE
                  }
               }
            }
         }

         if {$bSame} {
            if {[join $lslsData1 |] == [join $lslsData2 |] && $slsData1 != $sHeader1 && $slsData2 != $sHeader2} {
               set bOK TRUE
               if {$sFile == \"Program\" || $sFile == \"Page\"} {
               	  pProgCheck $sCol11 $sCol21 $sFile
               	  if {$bOK != \"TRUE\"} {
                     puts $oFile2 \"1\\t$slsData1\\t\\t# SOURCE CODE DELTA\"
                     puts $oFile2 \"2\\t$slsData2\\t\\t# SOURCE CODE DELTA\"
                     puts $oFile5 $slsData1
                     puts $oFile6 $slsData2
                     set bFile2 TRUE
                     set bFile5 TRUE
                     set bFile6 TRUE
                  }
               }

               if {$bOK} {
                  puts $oFile1 $slsData1
                  set bFile1 TRUE
               }
            } elseif {$slsData1 != $sHeader1 && $slsData2 != $sHeader2} {
               set bOK TRUE
               set iCount 0
               set bProcessMerge FALSE
               set slsData3 \"\"
               set slsData4 \"\"
               foreach sData1 $lslsData1 sData2 $lslsData2 {
               	  if {$sData1 == $sData2} {
               	     incr iCount
               	     continue
               	  } elseif {$iCount == 5 && ($sFile == \"TableColumn\" || $sFile == \"WebFormField\")} {
               	     if {($sData1 == \"\" && $sData2 == \"dummy\") || ($sData1 == \"dummy\" && $sData2 == \"\")} {
               	     	incr iCount
               	     	continue
               	     }
               	  } elseif {[string tolower $sData1] == \"true\" || [string tolower $sData1] == \"false\"} {
               	     if {[string tolower $sData1] == [string tolower $sData2]} {
               	     	incr iCount
               	     	continue
               	     }
               	  } elseif {[string first \"|\" $sData1] >= 0 || ($bMerge && $bSystem != \"TRUE\" && [lsearch $aMulti($sFile) $iCount] >= 0)} {
               	     set lslslsData1 [pTrimList $sData1 |]
               	     set slslsData1 [join [lsort $lslslsData1] |]
               	     set lslslsData2 [pTrimList $sData2 |]
               	     set slslsData2 [join [lsort $lslslsData2] |]
               	     if {$slslsData1 == $slslsData2} {
               	     	incr iCount
               	     	continue
               	     } elseif {$bMerge} {
# Merge List Items
                        set bValue FALSE
                        switch $sFile {
                           Channel - Command - \"Menu\" - Portal {
                              if {$iCount == 6} {
                                 set bValue TRUE
                              } elseif {$iCount == 7} {
                              	 incr iCount
                              	 continue
                              }
               	           } TableColumn - WebFormField {
               	              if {$iCount == 7} {
               	                 set bValue TRUE
               	              } elseif {$iCount == 8} {
               	              	 incr iCount
               	             	 continue
               	              }
               	           } Policy {
               	              if {$iCount == 10} {
               	              	 set bValue TRUE
               	              } elseif {$iCount == 11} {
               	              	 incr iCount
               	             	 continue
               	              }
               	           } Inquiry {
               	              if {$iCount == 5} {
               	                 set bValue TRUE
               	              } elseif {$iCount == 6} {
               	             	 incr iCount
               	             	 continue
               	              }
               	           } default {
               	           }
               	        }
               	        if {$bValue} {
               	           set lslslsData1v [pTrimList [lindex $lslsData1 [expr $iCount + 1]] \"|\"]
               	           set lslslsData2v [pTrimList [lindex $lslsData2 [expr $iCount + 1]] \"|\"]
               	           set lsResult [pMergeList $lslslsData1 $lslslsData1v $lslslsData2 $lslslsData2v \"\"]
               	           if {$lsResult != $lslslsData1} {
               	              set bMerge1 TRUE
               	              set bOK FALSE
               	           }
               	           set sResult1 [join [lindex $lsResult 0] |]
               	           set sResult1v [join [lindex $lsResult 1] |]
               	           set lsResult [pMergeList $lslslsData2 $lslslsData2v $lslslsData1 $lslslsData1v \"\"]
               	           if {$lsResult != $lslslsData2} {
               	              set bMerge2 TRUE
               	              set bOK FALSE
               	           }
               	           set sResult2 [join [lindex $lsResult 0] |]
               	           set sResult2v [join [lindex $lsResult 1] |]
               	           set lsTemp1 \"\"
               	           set lsTemp2 \"\"
               	           for {set i 0} {$i < $iCount} {incr i} {
               	              lappend lsTemp1 [lindex $lslsData1 $i]
               	              lappend lsTemp2 [lindex $lslsData2 $i]
               	           }
               	           lappend lsTemp1 $sResult1 $sResult1v
               	           lappend lsTemp2 $sResult2 $sResult2v
               	           for {set i [expr $iCount + 2]} {$i < [llength $lslsData1]} {incr i} {
               	              lappend lsTemp1 [lindex $lslsData1 $i]
               	              lappend lsTemp2 [lindex $lslsData2 $i]
               	           }
               	           set slsData3 [join $lsTemp1 \\t]
               	           set slsData4 [join $lsTemp2 \\t]
               	           incr iCount
               	           continue
               	        } else {
                           set lsResult [pMergeList $lslslsData1 \"\" $lslslsData2 \"\" \"\"]
               	           if {$lsResult != $lslslsData1} {
               	              set bMerge1 TRUE
               	              set bOK FALSE
               	           }
               	           set sResult1 [join [lindex $lsResult 0] |]
               	           set lsResult [pMergeList $lslslsData2 \"\" $lslslsData1 \"\" \"\"]
               	           if {$lsResult != $lslslsData2} {
               	              set bMerge2 TRUE
               	              set bOK FALSE
               	           }
               	           set sResult2 [join [lindex $lsResult 0] |]
               	           set lsTemp1 \"\"
               	           set lsTemp2 \"\"
               	           for {set i 0} {$i < $iCount} {incr i} {
               	              lappend lsTemp1 [lindex $lslsData1 $i]
               	              lappend lsTemp2 [lindex $lslsData2 $i]
               	           }
               	           lappend lsTemp1 $sResult1
               	           lappend lsTemp2 $sResult2
               	           for {set i [expr $iCount + 1]} {$i < [llength $lslsData1]} {incr i} {
               	              lappend lsTemp1 [lindex $lslsData1 $i]
               	              lappend lsTemp2 [lindex $lslsData2 $i]
               	           }
               	           set slsData3 [join $lsTemp1 \\t]
               	           set slsData4 [join $lsTemp2 \\t]
               	           incr iCount
               	           continue
               	        }
               	     }
               	  }
               	  set bOK FALSE
               	  if {$bMerge} {
               	     incr iCount
               	     continue
                  } else {
               	     break
                  }
               }
               if {$bOK} {
                  if {$sFile == \"Program\" || $sFile == \"Page\"} {
                     pProgCheck $sCol11 $sCol21 $sFile
                     if {$bOK != \"TRUE\"} {
                        puts $oFile2 \"1\\t$slsData1\\t\\t# SOURCE CODE DELTA\"
                        puts $oFile2 \"2\\t$slsData2\\t\\t# SOURCE CODE DELTA\"
                        puts $oFile5 $slsData1
                        puts $oFile6 $slsData2
                        set bFile2 TRUE
                        set bFile5 TRUE
                        set bFile6 TRUE
                     }
                  }
                  if {$bOK} {
                     puts $oFile1 $slsData1
                     set bFile1 TRUE
                  }
               } else {
                  puts $oFile2 \"1\\t$slsData1\"
                  puts $oFile2 \"2\\t$slsData2\"
                  set bFile2 TRUE
# Check for registration clash
                  set bClash FALSE
                  if {$bRegister} {
                     if {$sCol12 != $sCol22} {
                        if {$sFile == \"WebForm\"} {
                	   set sSymName \"form\"
                	} elseif {$bSystem} {
                	   set sSymName [string tolower $aSystem($sFile)]
                	} else {
                	   set sSymName [string tolower $sFile]
                	}
                	if {$sCol12 == \"\"} {
                	   set sSymName1 \"\\133BLANK\\135\"
                	} else {
                	   set sSymName1 \"$sSymName\\_$sCol12\"
                	   regsub -all \" \" $sSymName1 \"\" sSymName1
                	}
                	if {$sCol22 == \"\"} {
                	   set sSymName2 \"\\133BLANK\\135\"
                	} else {
                	   set sSymName2 \"$sSymName\\_$sCol22\"
                	   regsub -all \" \" $sSymName2 \"\" sSymName2
                	}
                	set sMessage \"WARNING: The same '$sFile' name '$sCol11' use different registrations:\\n   Schema 1 '$sFile' Symbolic Name: '$sSymName1'\\n   Schema 2 '$sFile' Symbolic Name: '$sSymName2'\"
                        puts $sMessage
                        puts $iLog $sMessage
                        puts $oFile7 \"1\\t$slsData1\"
                        puts $oFile7 \"2\\t$slsData2\"
                        set bFile7 TRUE
                        set bClash TRUE
                     }
                  }
                  if {$bMerge != \"TRUE\"} {
                     puts $oFile5 $slsData1
                     puts $oFile6 $slsData2
                     set bFile5 TRUE
                     set bFile6 TRUE
                  } elseif {$bClash != \"TRUE\" && $slsData3 != \"\"} {
                     puts $oFile5 $slsData3
                     puts $oFile6 $slsData4
                  }
               }
            }
            incr iIndexData1
            incr iIndexData2
         } else {
            if {$slsData1 == $sHeader1} {
               incr iIndexData1
            } elseif {$slsData2 == $sHeader2} {
               incr iIndexData2
            } elseif {$sCol11 == \"\"} {
               if {$iIndexData1 < $iLength1} {
                  incr iIndexData1
               } else {
                  puts $oFile4 $slsData2
                  puts $oFile6 $slsData2
                  set bFile4 TRUE
                  set bFile6 TRUE
               	  incr iIndexData2
                  if {$sFile == \"Program\"} {
                     catch {file copy \"$sPath2/Business/SourceFiles/$sCol21\" \"$sPathB/Business/SourceFiles/$sCol21\"} sMsg
                  } elseif {$sFile == \"Page\"} {
                     catch {file copy \"$sPath2/Business/PageFiles/$sCol21\" \"$sPathB/Business/PageFiles/$sCol21\"} sMsg
                  }
               	  if {$bRegister} {
                     set aSchema2($sFile|$sCol22) [list $sCol21 $slsData2]
                     lappend lsSchema2 $sCol22
                  }
               }
            } elseif {$sCol21 == \"\"} {
               if {$iIndexData2 < $iLength2} {
            	  incr iIndexData2
               } else {
                  puts $oFile3 $slsData1
                  puts $oFile5 $slsData1
                  set bFile3 TRUE
                  set bFile5 TRUE
                  incr iIndexData1
                  if {$sFile == \"Program\"} {
                     catch {file copy \"$sPath1/Business/SourceFiles/$sCol11\" \"$sPathA/Business/SourceFiles/$sCol11\"} sMsg
                  } elseif {$sFile == \"Page\"} {
                     catch {file copy \"$sPath1/Business/PageFiles/$sCol11\" \"$sPathA/Business/PageFiles/$sCol11\"} sMsg
                  }
                  if {$bRegister} {
                     set aSchema1($sFile|$sCol12) [list $sCol11 $slsData1]
                     lappend lsSchema1 $sCol12
                  }
               }
            } else {
               set lsTest [lsort -dictionary [list $slsData1 $slsData2]]
               if {$slsData1 == [lindex $lsTest 0]} {
                  puts $oFile3 $slsData1
                  puts $oFile5 $slsData1
                  set bFile3 TRUE
                  set bFile5 TRUE
                  incr iIndexData1
                  if {$sFile == \"Program\"} {
                     catch {file copy \"$sPath1/Business/SourceFiles/$sCol11\" \"$sPathA/Business/SourceFiles/$sCol11\"} sMsg
                  } elseif {$sFile == \"Page\"} {
                     catch {file copy \"$sPath1/Business/PageFiles/$sCol11\" \"$sPathA/Business/PageFiles/$sCol11\"} sMsg
                  }
               	  if {$bRegister} {
                     set aSchema1($sFile|$sCol12) [list $sCol11 $slsData1]
                     lappend lsSchema1 $sCol12
                  }
               } else {
                  puts $oFile4 $slsData2
                  puts $oFile6 $slsData2
                  set bFile4 TRUE
                  set bFile6 TRUE
                  incr iIndexData2
                  if {$sFile == \"Program\"} {
                     catch {file copy \"$sPath2/Business/SourceFiles/$sCol21\" \"$sPathB/Business/SourceFiles/$sCol21\"} sMsg
                  } elseif {$sFile == \"Page\"} {
                     catch {file copy \"$sPath2/Business/PageFiles/$sCol21\" \"$sPathB/Business/PageFiles/$sCol21\"} sMsg
                  }
               	  if {$bRegister} {
                     set aSchema2($sFile|$sCol22) [list $sCol21 $slsData2]
                     lappend lsSchema2 $sCol22
                  }
               }
            }
         }
         set slsData1 [string trim [lindex $lsData1 $iIndexData1]]
         set slsData2 [string trim [lindex $lsData2 $iIndexData2]]
      }
      close $iFile1
      close $iFile2
      close $oFile1
      close $oFile2
      close $oFile3
      close $oFile4
      close $oFile5
      close $oFile6
      if {$bFile1 == \"FALSE\"} {
         if {$bSystem} {
            file delete \"c:/temp/SpinCompare$sSuffix/$sFile\\_Match.xls\"
         } else {
            file delete \"c:/temp/SpinCompare$sSuffix/Spinner$sFile\\Data_Match.xls\"
         }
      }
      if {$bFile2 == \"FALSE\"} {
         if {$bSystem} {
            file delete \"c:/temp/SpinCompare$sSuffix/$sFile\\_Delta.xls\"
         } else {
            file delete \"c:/temp/SpinCompare$sSuffix/Spinner$sFile\\Data_Delta.xls\"
         }
      }
      if {$bFile3 == \"FALSE\"} {
         if {$bSystem} {
            file delete \"c:/temp/SpinCompare$sSuffix/$sFile\\_1Unique.xls\"
         } else {
            file delete \"c:/temp/SpinCompare$sSuffix/Spinner$sFile\\Data_1Unique.xls\"
         }
      }
      if {$bFile4 == \"FALSE\"} {
         if {$bSystem} {
            file delete \"c:/temp/SpinCompare$sSuffix/$sFile\\_2Unique.xls\"
         } else {
            file delete \"c:/temp/SpinCompare$sSuffix/Spinner$sFile\\Data_2Unique.xls\"
         }
      }
      if {$lsSchema1 != \"\" && $lsSchema2 != \"\"} {
      	 foreach sSchema1 $lsSchema1 {
      	    if {[info exists aSchema2($sFile|$sSchema1)]} {
      	       if {$sFile == \"WebForm\"} {
      	       	  set sSymName \"form\"
      	       } elseif {$bSystem} {
      	       	  set sSymName [string tolower $aSystem($sFile)]
      	       } else {
      	       	  set sSymName [string tolower $sFile]
      	       }
      	       set sSymName \"$sSymName\\_$sSchema1\"
      	       regsub -all \" \" $sSymName \"\" sSymName
               set sMessage \"WARNING: Different '$sFile' names share a common registration name: '$sSymName'\\n   Schema 1 '$sFile' Name: '[string trim [lindex [split [lindex [split $aSchema1($sFile|$sSchema1) \\t] 0] \"\\173\"] 0] ]'\\n   Schema 2 '$sFile' Name: '[string trim [lindex [split [lindex [split $aSchema2($sFile|$sSchema1) \\t] 0] \"\\173\"] 0] ]'\"
               puts $sMessage
               puts $iLog $sMessage
               puts $oFile7 \"1\\t[lindex $aSchema1($sFile|$sSchema1) 1]\"
               puts $oFile7 \"2\\t[lindex $aSchema2($sFile|$sSchema1) 1]\"
               set bFile7 TRUE
      	    }
      	 }
      }
      close $oFile7
      if {$bFile7 == \"FALSE\"} {
         file delete \"c:/temp/SpinCompare$sSuffix/SpinnerClash/$sFile.xls\"
      }
   }

# Policy Access Files

   set lsFileTemp [glob -nocomplain \"$sPath1/Business/Policy/*.xls\"]
   set lsFile1 \"\"
   foreach sFile $lsFileTemp {
      lappend lsFile1 [file tail $sFile]
   }
   set lsFileTemp [glob -nocomplain \"$sPath2/Business/Policy/*.xls\"]
   set lsFile2 \"\"
   foreach sFile $lsFileTemp {
      lappend lsFile2 [file tail $sFile]
   }

   foreach sFile1 $lsFile1 sFile2 $lsFile2 {
      if {$sFile1 != \"\" && [lsearch $lsFile2 $sFile1] < 0} {
         catch {file copy \"$sPath1/Business/Policy/$sFile1\" \"$sPathA/Business/Policy/$sFile1\"} sMsg
      } elseif {$sFile2 != \"\" && [lsearch $lsFile1 $sFile2] < 0} {
         catch {file copy \"$sPath2/Business/Policy/$sFile2\" \"$sPathB/Business/Policy/$sFile2\"} sMsg
      } elseif {$sFile1 != \"\" && [lsearch $lsFile2 $sFile1] >= 0} {
         set iFile1 [open \"$sPath1/Business/Policy/$sFile1\" r]
         set iFile2 [open \"$sPath2/Business/Policy/$sFile1\" r]
         set slsFileA [read $iFile1]
         set slsFileB [read $iFile2]
         close $iFile1
         close $iFile2
         if {$slsFileA != $slsFileB} {
            set lsFileTemp [split $slsFileA \\n]
            set lsFileA \"\"
            foreach sFileTemp $lsFileTemp {
               set sFileTemp [pRegSubExcel $sFileTemp]
               set lsFileLineTemp [split $sFileTemp \\t]
               set lsFileLineA \"\"
               foreach sFileLineTemp $lsFileLineTemp {
                  lappend lsFileLineA [pRegSubExcel $sFileLineTemp]
               }
               lappend lsFileA [join $lsFileLineA |]
            }
            set lsFileTemp [split $slsFileB \\n]
            set lsFileB \"\"
            foreach sFileTemp $lsFileTemp {
               set sFileTemp [pRegSubExcel $sFileTemp]
               set lsFileLineTemp [split $sFileTemp \\t]
               set lsFileLineB \"\"
               foreach sFileLineTemp $lsFileLineTemp {
                  lappend lsFileLineB [pRegSubExcel $sFileLineTemp]
               }
               lappend lsFileB [join $lsFileLineB |]
            }

            set bHeader TRUE
            foreach sFileA $lsFileA sFileB $lsFileB {
               if {$bHeader} {
                  set bHeader FALSE
                  continue
               }
               if {($sFileB != \"\" && [lsearch $lsFileA $sFileB] < 0) || ($sFileA != \"\" && [lsearch $lsFileB $sFileA] < 0)} {
                  catch {file copy \"$sPath1/Business/Policy/$sFile1\" \"$sPathA/Business/Policy/$sFile1\"} sMsg
                  catch {file copy \"$sPath2/Business/Policy/$sFile1\" \"$sPathB/Business/Policy/$sFile2\"} sMsg
                  break
               }
            }
         }
      }
   }
   puts \"Files loaded in directory: $sPath\"
   close $iLog
}
" 1 0 0 0 0 0 0 0 0 0 0 0 "" 0 0
 0 1
 SpinnerAgent NULL noname "3/27/2017 3:41:29 PM" 0
"12/6/2015 11:42:58 PM" "3/14/2018 3:57:25 PM"
7
 0 1 "12/6/2015 11:42:58 PM" creator "add program emxSpinnerCompare.tcl mql execute immediate !needsbusinessobject !downloadable !pipe !pooled nothidden file ./Business/SourceFiles/emxSpinnerCompare.tcl"
 0 2 "12/6/2015 11:42:58 PM" creator "add property SpinnerAgent on program emxSpinnerCompare.tcl value '12/6/2015 11:42:58 PM'"
 0 2 "12/6/2015 11:42:58 PM" creator "mod program emxSpinnerCompare.tcl description ''"
 0 2 "2/3/2016 5:21:01 PM" creator "mod property SpinnerAgent on program emxSpinnerCompare.tcl value '2/3/2016 5:21:01 PM'"
 0 2 "2/3/2016 5:21:01 PM" creator "mod program emxSpinnerCompare.tcl file ./Business/SourceFiles/emxSpinnerCompare.tcl"
 0 2 "3/27/2017 3:41:29 PM" creator "mod property SpinnerAgent on program emxSpinnerCompare.tcl value '3/27/2017 3:41:29 PM'"
 0 2 "3/27/2017 3:41:29 PM" creator "mod program emxSpinnerCompare.tcl file ./Business/SourceFiles/emxSpinnerCompare.tcl"

!MTRX!END

!MTRX!AD! program emxSpinnerBusObjects.tcl "3DEXPERIENCE R2015x(24.0.0.0)"
emxSpinnerBusObjects.tcl 0 "" "#*******************************************************************************10.9
# @progdoc        emxSpinnerBusObjects.tcl vM10.9 (Build 25 Feb 09)
#
# @Brief:         Create, modify or delete bus objects
#
# @Description:   Create, modify or delete business objects
#                 Multiple headers for merging different types may be used using <HEADER> as last field.
#                 The file format has to be followed as shown below:
#
#                 Type(^t)Name(^t)Rev(^t)ChangeName(^t)ChangeRev(^t)Policy(^t)State(^t)Vault(^t)Owner(^t)description(^t)'Attribute 1'(^t)'Attribute N'(^t)[see note l](^t)[see note m](^t)[see note n](^t)[see note o]
#                    where (^t) is a tab
#
#                 For revisions chains, the 'Previous Rev' column is added:
#                 Type(^t)Name(^t)Rev(^t)Previous Rev(^t)ChangeName(^t)ChangeRev(^t)Policy(^t)State(^t)Vault(^t)Owner(^t)description(^t)'Attribute 1'(^t)'Attribute N'(^t)[see note l](^t)[see note m](^t)[see note n](^t)[see note o]
#                    where (^t) is a tab
#
#  a.	Runs the spreadsheets in ./Objects and creates a log file in ./logs
#  b.	This program will delete objects if only the T N R is specified or <DELETE> tag specified in Change Name field.
#  c.	Adds a new business object if one does not exist.
#  d.	Change name with the new name in the 4th column.
#  e.	Change revision with the revision value in the 5th column.
#  f.	Change policy with the policy name in the 6th column.
#  g.	Change state with the state name in the 7th column.  Objects can be promoted or demoted.
#  h.	Change vault with the vault name in the 8th column. Vault must exist.
#  i.	Change owner with the new person in the 9th column.
#  j.	Description is input in the 10th column.
#  k.	Attribute names are on the header line and the values are input in the columns below.  Use <NULL> for null values.
#  l.   The first field after attributes is set to 'TRUE' or 'FALSE' to override global setting to force modifications.
#  m.   The second field after attributes is set to 'ON' or 'OFF' to override global setting for create triggers.
#  n.   The third field after attributes is set to 'ON' or 'OFF' to override global setting for mod triggers.
#  o.   The fourth field after attributes is set to 'ON' or 'OFF' to override global setting for delete triggers.
#  p.   Use the '<NEWLINE>' tag to replace linefeeds in multiline attributes.
#
# @Parameters:    none
#
# @Returns:       Nothing   
#
# @Usage:         Can be used for legacy load into production
#
# @progdoc        Copyright (c) 2003, ENOVIA
#*******************************************************************************
# @Modifications:
#
# Charles Merinsky 4/22/2003 - Initial code.
# Venkatesh Harikrishnan - Modified for the new line issue.
# Matt Osterman 1/12/2007 - Added <DELETE> tag capability for delete.
# Pritam Mahajan 2/25/2009 - Fix for 370077.
# Thomas Ducray 6/9/2009 - ALMR Fix for defect 119
#
#*******************************************************************************

tcl;

eval {
   if {[info host] == \"vmw2k3n01dsy\" } {
      source \"c:/Program Files/TclPro1.4/win32-ix86/bin/prodebug.tcl\"
      set cmd \"debugger_eval\"
      set xxx [debugger_init]
   } else {
      set cmd \"eval\"
   }
}
$cmd {

   set bModIfExists [mql get env BUSOBJMODIFEXISTS]
   set bTriggerAdd [mql get env TRIGGERCREATE]
   set bTriggerMod [mql get env TRIGGERMODIFY]
   set bTriggerDel [mql get env TRIGGERDELETE]
   set sAllFiles [mql get env BUSFILELIST]

#  ********************** USER DEFINED VARIABLES*******************************
   if {$bModIfExists == \"\"} {
      set bModIfExists \"FALSE\" ;#TRUE or FALSE - modify bus object if it exists
   }
   if {$bTriggerAdd == \"\"} {
      set bTriggerAdd \"OFF\" ;# ON or OFF - turn trigger on
   }
   if {$bTriggerMod == \"\"} {
      set bTriggerMod \"OFF\" ;# ON or OFF - turn trigger on
   }
   if {$bTriggerDel == \"\"} {
      set bTriggerDel \"OFF\" ;# ON or OFF - turn trigger on
   }
#  ****************************************************************************

   set sDate1 [clock format [clock seconds] -format %Y%m%d]
   set iStartTime  [clock seconds]
   set iErrTotal      0
   set bError     FALSE
   
# Scan Mode
   set bScan [mql get env SPINNERSCANMODE]
   if {$bScan != \"TRUE\"} {set bScan FALSE}
   if {$bScan} {set sDate1 \"SCAN\"}

   global iLogFileId 
   global iErrTot iAddTotal iModTotal iDelTotal iChgNameTotal iPolicyTotal iOwnerTotal iVaultTotal iPromoteTotal iDemoteTotal iRevChainTotal
   
##  this is to set the path
   if {$sAllFiles == \"\"} {set sAllFiles [ glob -nocomplain \"./Objects/*.xls\" ]}
   if {$sAllFiles == \"./Objects/0\"} {set sAllFiles \"\"}
   if {$sAllFiles == \"\"} {
      puts -nonewline \"\\n*** No data files of format '\\[bus object name\\].xls' found ***\"
   }
   
#***************************************************************************
# Procedure:   pLogFile
# Description: Used after all records have been processed. Write time of execution and 
#              Totals of load to files.
# Parameters:  none.
# Returns:  none.
#***************************************************************************
   proc pLogFile { iStartTime } {
   
      global iLogFileId
      global iErrTot iAddTotal iModTotal iDelTotal iChgNameTotal iPolicyTotal iOwnerTotal iVaultTotal iPromoteTotal iDemoteTotal iRevChainTotal sAllFiles sCurFile
      
      set iEndTime  [clock seconds]
      incr iEndTime -$iStartTime
      set iMin  [expr $iEndTime / 60]
      set iSec  [expr $iEndTime - ($iMin * 60 )]
      set iHour [expr $iMin / 60 ]
      set iMin  [expr $iMin - ($iHour * 60 )]
      set iDay  [expr $iHour / 24 ]
      set iHour [expr $iHour - ($iDay * 24 )]
      set iSec  [format \"%0.2i\" $iSec]
      set iMin  [format \"%0.2i\" $iMin]
      
      if {$iAddTotal > 0} {puts $iLogFileId \"#     Number of Objects created:         $iAddTotal\"}
      if {$iModTotal > 0} {puts $iLogFileId \"#     Number of Objects modified:        $iModTotal\"}
      if {$iDelTotal > 0} {puts $iLogFileId \"#     Number of Objects deleted:        $iDelTotal\"}
      if {$iChgNameTotal > 0} {puts $iLogFileId \"#     Number of Objects change name:     $iChgNameTotal\"} 
      if {$iOwnerTotal > 0} {puts $iLogFileId \"#     Number of Objects change owner:    $iOwnerTotal\"}
      if {$iPolicyTotal > 0} {puts $iLogFileId \"#     Number of Objects change policy:   $iPolicyTotal\"}
      if {$iVaultTotal > 0} {puts $iLogFileId \"#     Number of Objects change vault:    $iVaultTotal\"}
      if {$iPromoteTotal > 0} {puts $iLogFileId \"#     Number of Objects promoted:        $iPromoteTotal\"} 
      if {$iDemoteTotal > 0} {puts $iLogFileId \"#     Number of Objects demoted:         $iDemoteTotal\"}
      if {$iRevChainTotal > 0} {puts $iLogFileId \"#     Number of Objects revision chained:         $iRevChainTotal\"}
      if {$iErrTot > 0} {puts $iLogFileId \"#     Number of Errors:                  $iErrTot\"}
      if {[expr $iAddTotal + $iModTotal + $iDelTotal + $iErrTot] > 0} {puts $iLogFileId \"#     Total time for load:               $iDay $iHour:$iMin:$iSec\"}
      
      if {[lsearch $sAllFiles $sCurFile] == [expr [llength $sAllFiles] - 1]} {puts $iLogFileId \"\"}
   }

#***************************************************************************
# Procedure:   pCheckAttrHdr
# Description:   This procedure checks Attribute for a null value.  Only
#  valid Attribute names with attribute values will be returned.  
# Returns:  Attributes.
#***************************************************************************
   proc pCheckAttrHdr { llName llValue } {
      set pCombo \"\"
      if {$llName != \"\" && $llValue != \"\" } {
         foreach lName $llName lValue $llValue {
            if {[string range $lValue 0 0] == \"\\042\" && [string range $lValue end end] == \"\\042\" && [string length $lValue] > 2} {
            	 if {[string first \",\" $lValue] > -1 || [string first \"\\042\\042\" $lValue] > -1} {
            	    set iLast [expr [string length $lValue] -2]
            	    set lValue [string range $lValue 1 $iLast]
            	    regsub -all \"\\042\\042\" $lValue \"\\042\" lValue
            	 }
            }
            regsub -all \"\\134$\" $lValue \"\\134\\134\\$\" lValue
            regsub -all \"\\134{\" $lValue \"\\134\\134\\173\" lValue
            regsub -all \"\\134}\" $lValue \"\\134\\134\\175\" lValue
            regsub -all \"\\134\\133\" $lValue \"\\134\\134\\133\" lValue
            regsub -all \"\\134\\135\" $lValue \"\\134\\134\\135\" lValue
            regsub -all \"\\042\" $lValue \"\\134\\042\" lValue
            regsub -all \"'\" $lValue \"\\047\" lValue
            regsub -all \"<ESC>\" $lValue \"\\134\" lValue
            regsub -all \"<SPACE>\" $lValue \" \" lValue
            regsub -all \"<NULL>\" $lValue \"\" lValue
            append pCombo \" \\\"$lName\\\" \\\"$lValue\\\"\"
         }
      }
      return $pCombo
   }
   
#***************************************************************************
# @procdoc        pGetBasic
# @Brief:         Copy from mxBus to get policy states.
# @Description:   Copy from mxBus to get policy states.
# @Returns:       
#**************************************************************************
   proc pGetBasic { sTypeOrOid sName sRev args } {
      if { $args == \"\" } { return \"\" }
      if { $sName == \"\" } {
         set sOid $sTypeOrOid
      } else {
         set sOid [ list $sTypeOrOid $sName $sRev ]
      }
      set sValues \"\"
      if { [ llength $args ] == 1 } {
         set sValues [ eval mql print bus $sOid select $args dump ]
      } else {
         set sValues [ eval mql print bus $sOid select $args dump ^ ]
      }
      if { [ llength $args ] == 1 } {
         return $sValues
      } else {
         return [ split $sValues ^ ]
      }
   }
   
#***************************************************************************
# @procdoc        pPromoteToTargetState
# @Brief:         Promote to a target state. Stolen from mxBus.
# @Description:   Promote to a target state. Stolen from mxBus.
# @Returns:       0 == good  1 == error
#**************************************************************************
   proc pPromoteToTargetState {lBus sTargetSt} {
   
      global iLogFileId sLogFileError iPromoteTotal iDemoteTotal iErrTot bError bSpinnerAgent iUniqueID lsTempPolicy
      
      set iRet 0
      set lData [ eval pGetBasic $lBus policy current type id ]
      set sBusPol [ lindex $lData 0 ]
      set sBusSt  [ lindex $lData 1 ]
      set sBusType [ lindex $lData 2 ]
      set sBusOid [ lindex $lData 3 ]
      
      if {[catch {set lPolStates [ split [ mql print pol \"$sBusPol\" select state.name dump | ] | ]} sMsg] != 0} {
         puts $iLogFileId \"\\n$lBus: error - cannot promote business object as it does not exist\"
         if {$bSpinnerAgent} {
            set iLogFileErr [open $sLogFileError a+]
            puts $iLogFileErr \"$lBus: error - cannot promote business object as it does not exist\"
            close $iLogFileErr
         }
         set bError TRUE
         incr iErrTot
         set iRet 1
      } else {
         set iBusSt  [ lsearch $lPolStates $sBusSt ]
         set iSt [ lsearch $lPolStates $sTargetSt ]
   
         if { $iSt == -1 } {
            puts $iLogFileId \"\\n$lBus: error State \\\"$sTargetSt\\\" does not exist\"
            if {$bSpinnerAgent} {
               set iLogFileErr [open $sLogFileError a+]
               puts $iLogFileErr \"$lBus: error State \\\"$sTargetSt\\\" does not exist\"
               close $iLogFileErr
            }
            set bError TRUE
            incr iErrTot
            set iRet 1
         } elseif {$iSt != $iBusSt} {
# 12/21/2006 - Set state with policy change instead of promote/demote - MJO
            if {[catch {
               set sTempPol \"$sBusType\\_$sTargetSt\\_$iUniqueID\"
               if {[lsearch $lsTempPolicy $sTempPol] < 0} {
                  set sCmd \"mql add policy \\\"$sTempPol\\\" state \\\"$sTargetSt\\\" type \\\"$sBusType\\\" hidden\"
# 08/07/2008 - Fix for 357699 - Multiple formats for CAD Objects
                  set slsFormat [mql print policy \"$sBusPol\" select format dump |]
                  if {$slsFormat != \"\"} {
                     set lsFormat [split $slsFormat |]
                     foreach sFormat $lsFormat {
                        append sCmd \" format \\\"$sFormat\\\"\"
                     }
                  }
# End Fix 357699
                  eval $sCmd
                  lappend lsTempPolicy $sTempPol
               }
               mql mod bus $sBusOid policy \"$sTempPol\"
               mql mod bus $sBusOid policy \"$sBusPol\"
            } sResult] != 0} {
               puts $iLogFileId \"\\n$lBus - error in changing bus object state: $sResult\"
               if {$bSpinnerAgent} {
                  set iLogFileErr [open $sLogFileError a+]
                  puts $iLogFileErr \"$lBus - error in changing bus object state: $sResult\"
                  close $iLogFileErr
               }
               set bError TRUE
               incr iErrTot
               set iRet 1
            } else {
               puts $iLogFileId \"# $lBus: changing bus object state - successful\"
               if { [ expr $iSt - $iBusSt ] > 0 } {
                  incr iPromoteTotal
               } else {
                  incr iDemoteTotal
               }
               set iRet 0
            }
         }
      }
      return $iRet
   }
   
# Procedure to write screen cue
   proc pWriteCue {} {
      global iAddTotal iModTotal iDelTotal iSkipTotal iErrTot iTenPercent iPrevAddModDel iPrevError
      set iAddModDel [expr $iAddTotal + $iModTotal + $iDelTotal - $iPrevAddModDel]
      set iError [expr $iErrTot - $iPrevError]
      set iPrevAddModDel [expr $iAddTotal + $iModTotal + $iDelTotal]
      set iPrevError $iErrTot
      set sWrite \"...\"
      if {$iAddModDel && $iError} {
         set sWrite \"  \\($iAddModDel\\: $iError\\!\\)\"
      } elseif {$iAddModDel} {
         set sWrite \"  \\($iAddModDel\\:\\)\"
      } elseif {$iError} {
         set sWrite \"  \\($iError\\!\\)\"
      }
      puts -nonewline \"$sWrite[expr $iTenPercent * 10]%\"
   }

#main

   if {$sAllFiles != \"\"} {
      puts \"\\n   global setting to modify bus objects if they exist: $bModIfExists\"
      puts -nonewline \"   global setting for triggers: create - $bTriggerAdd; modify - $bTriggerMod; delete - $bTriggerDel\"
   }
   mql verbose on
   mql trigger off
   file mkdir \"./logs\"
   if {[mql get env SPINNERLOGFILE] != \"\"} {
      set sLogFilePath [mql get env SPINNERLOGFILE]
      set sLogFileError [mql get env SPINNERERRORLOG]
      set bSpinnerAgent TRUE
   } else {    
      set sLogFilePath \"./logs/BusObjects\\.$sDate1.log\"
      set bSpinnerAgent FALSE
   }
   set iLogFileId    [open $sLogFilePath a+]
   set iUniqueID [clock seconds]
   set lsTempPolicy {}
   
   foreach sCurFile $sAllFiles {
      set iFileId    [open $sCurFile r]
      puts $iLogFileId \"\\n# \\[[clock format [clock seconds] -format %H:%M:%S]\\] File: '[file tail $sCurFile]'\"
      puts -nonewline \"\\nLoading bus objects from file '[file tail $sCurFile]'\"
      
      set iErrTot        0
      set iAddTotal      0 
      set iModTotal      0 
      set iDelTotal      0 
      set iChgNameTotal  0
      set iPolicyTotal   0 
      set iOwnerTotal    0
      set iVaultTotal    0
      set iPromoteTotal  0
      set iDemoteTotal   0
      set iRevChainTotal 0
      set iHeader        0
      set iSkipTotal     0
      set iPrevAddModDel 0
      set iPrevError     0
      set bPercent   FALSE
      set iTenPercent    1
      set bTrigOver(1) OFF
      set bTrigOver(2) OFF
      set bTrigOver(3) OFF
      set bTrigOn FALSE
      set bRevision FALSE

# READ FILES AND PROCESS RECORDS. 

      set lsFile [split [read $iFileId] \\n]
      close $iFileId
      if {[llength $lsFile] > 50} {
         set iPercent [expr [llength $lsFile] / 10]
         set bPercent TRUE
      }
      set iAttrEnd end
      foreach sLine $lsFile {
         set sLine [string trim $sLine]
         set lsLine [split $sLine \\t]
         if {[string first \"<HEADER>\" $sLine] >= 0} {
            set iHeader 0
            set iAttrEnd [expr [llength $lsLine] -2]
            set lsLine [lrange $lsLine 0 $iAttrEnd]
            set bRevision FALSE
         }         
         if { $iHeader == 0 } {
# 361693 (Revision Chain) - MJO - 10/9/2008
            if {[string first \"Previous Rev\" $sLine] == 14} {
               set bRevision TRUE
            }
            if {$iAttrEnd == \"end\"} {set iAttrEnd [expr [llength $lsLine] -1]}
            if {$bRevision} {
               set llName     [ lrange  $lsLine 10 $iAttrEnd ]
            } else {
               set llName     [ lrange  $lsLine 9 $iAttrEnd ]
            }            
# End 361693
            incr iHeader
            set lsName \"\"
            foreach lName $llName {
               set lName [string trim $lName]
               if {[catch {
                  if {[string tolower $lName] != \"description\" && ([string tolower $lName] == \"originated\" || [string tolower $lName] == \"modified\" || [mql print attribute $lName select type dump] == \"timestamp\")} {
                     set aTimeStamp($lName) TRUE
                  } else {
                     set aTimeStamp($lName) FALSE
                  }
               } sMsg] != 0} {
               	  puts \"\\nERROR: Attribute name '$lName' is not a valid attribute or field order is incorrect.\"
                  close $iLogFileId
               	  exit 1
               	  return
               }
               lappend lsName $lName
            }
            set llName $lsName
         } elseif {$sLine != \"\"} {
            set sType       [ string trim [ lindex $lsLine 0 ] ]
            set sName       [ string trim [ lindex $lsLine 1 ] ]
            set sRev        [ string trim [ lindex $lsLine 2 ] ]
# 361693 (Revision Chain) - MJO - 10/9/2008
            if {$bRevision} {
               set sPrevRev    [ string trim [ lindex $lsLine 3 ] ]
               set sChangeName [ string trim [ lindex $lsLine 4 ] ]
               set sChangeRev  [ string trim [ lindex $lsLine 5 ] ]
               set sPolicy     [ string trim [ lindex $lsLine 6 ] ]
               set sState      [ string trim [ lindex $lsLine 7 ] ]
               set sVault      [ string trim [ lindex $lsLine 8 ] ]
               set sOwner      [ string trim [ lindex $lsLine 9 ] ]
               set llValue     [ lrange  $lsLine 10 $iAttrEnd ]
            } else {
               set sChangeName [ string trim [ lindex $lsLine 3 ] ]
               set sChangeRev  [ string trim [ lindex $lsLine 4 ] ]
               set sPolicy     [ string trim [ lindex $lsLine 5 ] ]
               set sState      [ string trim [ lindex $lsLine 6 ] ]
               set sVault      [ string trim [ lindex $lsLine 7 ] ]
               set sOwner      [ string trim [ lindex $lsLine 8 ] ]
               set llValue     [ lrange  $lsLine 9 $iAttrEnd ]
            }
# End 361693
            set lsName \"\"
            set lsValue \"\"
            foreach lName $llName lValue $llValue {
               if {$lName != \"\"} {
                  set lValue [string trim $lValue]
                  if {$lValue != \"\"} {
#                     if {$aTimeStamp($lName)} {set lValue [lindex [split [string trim $lValue] \" \"] 0]}
                     lappend lsName $lName
                     lappend lsValue $lValue
                  }
               }
            }
            set llAttr [pCheckAttrHdr \"$lsName\" \"$lsValue\"]
            set bNonByPass [string toupper [ string trim [ lindex $lsLine [expr $iAttrEnd + 1 ] ] ] ]
            set bTrigOver(1) [string toupper [ string trim [ lindex $lsLine [expr $iAttrEnd + 2 ] ] ] ]
            set bTrigOver(2) [string toupper [ string trim [ lindex $lsLine [expr $iAttrEnd + 3 ] ] ] ]
            set bTrigOver(3) [string toupper [ string trim [ lindex $lsLine [expr $iAttrEnd + 4 ] ] ] ]
            set sTrig(1) $bTriggerAdd
            set sTrig(2) $bTriggerMod
            set sTrig(3) $bTriggerDel
            for {set i 1} {$i < 4} {incr i} {
               if {$bTrigOver($i) == \"ON\" || $bTrigOver($i) == \"OFF\"} {set sTrig($i) $bTrigOver($i)}
            }
            
# flag for delete if fields after T N R are blank or Change Name field is <DELETE>
            set bDelete TRUE
            set bChgNR TRUE
            if {[lindex $lsLine 3] == \"<DELETE>\"} {
               set bChgNR FALSE
            } else {
               for {set i 3} {$i < [llength $lsLine]} {incr i} {
                  if {[lindex $lsLine $i] != \"\"} {
                     set bDelete FALSE
                     break
                  }
               }
            }

# set mql command for adding or modifying object
            set iErr  [ catch { mql print businessobject \"$sType\" \"$sName\" \"$sRev\" select exists dump } result1 ]   
            
            if { \"$sName\" != \"\"} {
               set bError FALSE
               set bMod FALSE
               set bAdd FALSE
               set bDel FALSE
               set bExists FALSE
               if {$bScan != \"TRUE\"} {mql start transaction update}
               if {$result1 == \"FALSE\" && $bDelete == \"FALSE\"} {
                  if {$sName != $sChangeName && $sChangeName != \"\"} {set sName $sChangeName}
                  if {$sRev != $sChangeRev && $sChangeRev != \"\"} {set sRev $sChangeRev}
                  set iErr2  [ catch { mql print businessobject \"$sType\" \"$sName\" \"$sRev\" select exists dump } result2 ]
                  if {$result2 == \"FALSE\"} {  
	# Modified by Solution Library for the New Line Feeder error - Start
                     regsub -all \"<LINEFEED>\" $llAttr \"\\\\\\n\" llAttr
                     regsub -all \"<RETURN>\" $llAttr \"\\\\\\n\" llAttr
										 regsub -all \"<NEWLINE>\" $llAttr \"\\\\\\n\" llAttr
	# Modified by Solution Library for the New Line Feeder error - End
	
	             # Modified below for fixing 370077 on 25 Feb 09 . Added word escape. - start
                     set sCmd  \"mql escape add businessobject \\\"$sType\\\" \\\"$sName\\\" \\\"$sRev\\\" policy \\\"$sPolicy\\\" vault \\\"$sVault\\\" owner \\\"$sOwner\\\" $llAttr\"
     	             # Modified above for fixing 370077 on 25 Feb 09 . Added word escape. - end
                     set bTrigOn FALSE
                     if {$bTrigOver(1) == \"ON\" || ($bTriggerAdd == \"ON\" && $bTrigOver(1) != \"OFF\")} {
                        mql trigger on
                        set bTrigOn TRUE
                     }
                     if {$bScan} {
                        puts $iLogFileId $sCmd
                     } elseif {[catch {eval $sCmd} sResult] != 0} {
                        puts $iLogFileId \"$sCmd\"
                        puts $iLogFileId \"# \\\"$sType\\\" \\\"$sName\\\" \\\"$sRev\\\": $sResult - triggers $sTrig(1)\"
                        if {$bSpinnerAgent} {
                           set iLogFileErr [open $sLogFileError a+]
                           puts $iLogFileErr \"\\\"$sType\\\" \\\"$sName\\\" \\\"$sRev\\\": $sResult - triggers $sTrig(1)\"
                           close $iLogFileErr
                        }
                        set bError TRUE
                     } else {
                        set bAdd TRUE
                        puts $iLogFileId \"$sCmd\"
                        puts $iLogFileId \"# \\\"$sType\\\" \\\"$sName\\\" \\\"$sRev\\\": $sResult - triggers $sTrig(1)\"
                        set lBus \"\\\"$sType\\\" \\\"$sName\\\" \\\"$sRev\\\"\"
                        set iErr  [ catch { mql print businessobject \"$sType\" \"$sName\" \"$sRev\" select current dump } sCurState ]   
                        if { \"$sCurState\" == \"$sState\"} {
                        } else {	
                           set lBus \"\\\"$sType\\\" \\\"$sName\\\" \\\"$sRev\\\"\"
                           if {$bScan} {
                              puts $iLogFileId \"Promote '$lBus' to state '$sState'\"
                           } else {
                              pPromoteToTargetState \"$lBus\" \"$sState\"
                           }
                        }
                     }
                     if {$bTrigOn} {mql trigger off}
                  } else {
                     set bExists TRUE
                  }
               } elseif {$result1} {
                  set bExists TRUE
               }
               
# add revision chain (361693 - MJO - 10/9/2008)
               if {$bRevision && !$bError} {
                  if { \"$sPrevRev\" == \"\"} {
                  } elseif { \"$sRev\" == \"$sPrevRev\" } {
                  } elseif { [mql print bus \"$sType\" \"$sName\" \"$sRev\" select previous dump] != \"\" } {
                  } elseif {[mql print bus \"$sType\" \"$sName\" \"$sPrevRev\" select exists dump] != \"TRUE\"} {
                  } else {
                     set sCurId [mql print businessobject \"$sType\" \"$sName\" \"$sRev\" select id dump]
                     set lsPrev [split [mql print businessobject \"$sType\" \"$sName\" \"$sPrevRev\" select id next dump |] |]   
                     set sPrevId       [ string trim [ lindex \"$lsPrev\" 0 ] ]
                     set sPrevNextRev  [ string trim [ lindex \"$lsPrev\" 1 ] ]
                     if {$sPrevNextRev != \"\"} {
                     } else {
                        set sCmd  \"mql revise bus $sPrevId bus $sCurId\"
                        if {$bScan} {
                           puts $iLogFileId $sCmd
                        } elseif {[catch {eval $sCmd} sResult] != 0} {
                           puts $iLogFileId \"$sCmd\"
                           puts $iLogFileId \"\\n\\\"$sType\\\" \\\"$sName\\\" \\\"$sRev\\\" - error in connecting revision chain: $sResult - triggers off\"
                           if {$bSpinnerAgent} {
                              set iLogFileErr [open $sLogFileError a+]
                              puts $iLogFileErr \"\\\"$sType\\\" \\\"$sName\\\" \\\"$sRev\\\" - error in connecting revision chain : $sResult - triggers off\"
                              close $iLogFileErr
                           }
                           set bError TRUE
                        } else {
                           puts $iLogFileId \"$sCmd\"
                           puts $iLogFileId \"# \\\"$sType\\\" \\\"$sName\\\" \\\"$sRev\\\": revision chain connected - triggers off\"
                           set bMod TRUE
                           incr iRevChainTotal
                        }
                     }
                  }
               }
# End 361693
               if {$bExists} {
                  set bChgName FALSE
                  set bChgRev FALSE
# modify name or name/rev
                  if {$bChgNR && $sName != $sChangeName && $sChangeName != \"\"} {
                     if {$sRev != $sChangeRev && $sChangeRev != \"\"} {
                        set iErr3  [ catch { mql print businessobject \"$sType\" \"$sChangeName\" \"$sChangeRev\" select exists dump } result3 ]
                        if {$result3 == \"FALSE\"} {
                           set sCmd  \"mql mod businessobject \\\"$sType\\\" \\\"$sName\\\" \\\"$sRev\\\" name \\\"$sChangeName\\\" revision \\\"$sChangeRev\\\"\"
                           set bTrigOn FALSE
                           if {$bTrigOver(2) == \"ON\" || ($bTriggerMod == \"ON\" && $bTrigOver(2) != \"OFF\")} {
                              mql trigger on
                              set bTrigOn TRUE
                           }
                           set bChgName TRUE
                           set bChgRev TRUE
                           set bNonByPass TRUE
                        } else {
                           set bDelete TRUE
                        }
                     } else {
                        set iErr4  [ catch { mql print businessobject \"$sType\" \"$sChangeName\" \"$sRev\" select exists dump } result4 ]
                        if {$result4 == \"FALSE\"} {
                           set sCmd  \"mql mod businessobject \\\"$sType\\\" \\\"$sName\\\" \\\"$sRev\\\" name \\\"$sChangeName\\\"\"
                           set bTrigOn FALSE
                           if {$bTrigOver(2) == \"ON\" || ($bTriggerMod == \"ON\" && $bTrigOver(2) != \"OFF\")} {
                              mql trigger on
                              set bTrigOn TRUE
                           }
                           set bChgName TRUE
                           set bNonByPass TRUE
                        } else {
                           set bDelete TRUE
                        }
                     }
                     if {$bChgName || $bChgRev} {
                        if {$bScan} {
                           puts $iLogFileId $sCmd
                        } elseif {[catch {eval $sCmd} sResult] != 0} {
                           puts $iLogFileId \"$sCmd\"
                           puts $iLogFileId \"# \\\"$sType\\\" \\\"$sName\\\" \\\"$sRev\\\": $sResult\"
                           if {$bSpinnerAgent} {
                              set iLogFileErr [open $sLogFileError a+]
                              puts $iLogFileErr \"\\\"$sType\\\" \\\"$sName\\\" \\\"$sRev\\\": $sResult\"
                              close $iLogFileErr
                           }
                           set bError TRUE
                        } else {
                           set bMod TRUE
                           puts $iLogFileId \"$sCmd\"
                           puts $iLogFileId \"# \\\"$sType\\\" \\\"$sName\\\" \\\"$sRev\\\": $sResult\"
                        }
                        if {$bTrigOn} {mql trigger off}
                     }
# add revision
                  } elseif {$bChgNR && $sRev != $sChangeRev && $sChangeRev != \"\"} {
                     set iErr5  [ catch { mql print businessobject \"$sType\" \"$sName\" \"$sChangeRev\" select exists dump } result5 ]
                     if {$result5 == \"FALSE\"} {
                        set sNameTemp [clock seconds]
                        set sCmd  \"mql copy businessobject \\\"$sType\\\" \\\"$sName\\\" \\\"$sRev\\\" to $sNameTemp \\\"$sChangeRev\\\";mql mod businessobject \\\"$sType\\\" $sNameTemp \\\"$sChangeRev\\\" name \\\"$sName\\\"\"
                        set bChgRev TRUE
                        set bNonByPass TRUE
                        if {$bScan} {
                           puts $iLogFileId $sCmd
                        } elseif {[catch {eval $sCmd} sResult] != 0} {
                           puts $iLogFileId \"$sCmd\"
                           puts $iLogFileId \"# \\\"$sType\\\" \\\"$sName\\\" \\\"$sRev\\\": $sResult\"
                           if {$bSpinnerAgent} {
                              set iLogFileErr [open $sLogFileError a+]
                              puts $iLogFileErr \"\\\"$sType\\\" \\\"$sName\\\" \\\"$sRev\\\": $sResult\"
                              close $iLogFileErr
                           }
                           set bError TRUE
                        } else {
                           set bMod TRUE
                           puts $iLogFileId \"$sCmd\"
                           puts $iLogFileId \"# \\\"$sType\\\" \\\"$sName\\\" \\\"$sRev\\\": $sResult\"
                        }
                     }
                     set bDelete TRUE
                  }

# delete bus object
                  if {$bDelete} {
                     set sCmd  \"mql delete businessobject \\\"$sType\\\" \\\"$sName\\\" \\\"$sRev\\\"\"
                     set bTrigOn FALSE
                     if {$bTrigOver(3) == \"ON\" || ($bTriggerDel == \"ON\" && $bTrigOver(3) != \"OFF\")} {
                     	mql trigger on
                     	set bTrigOn TRUE
                     }
                     if {$bScan} {
                        puts $iLogFileId $sCmd
                     } elseif {[catch {eval $sCmd} sResult] != 0} {
                        puts $iLogFileId \"$sCmd\"
                        puts $iLogFileId \"# \\\"$sType\\\" \\\"$sName\\\" \\\"$sRev\\\": $sResult - triggers $sTrig(3)\"
                        if {$bSpinnerAgent} {
                           set iLogFileErr [open $sLogFileError a+]
                           puts $iLogFileErr \"\\\"$sType\\\" \\\"$sName\\\" \\\"$sRev\\\": $sResult - triggers $sTrig(3)\"
                           close $iLogFileErr
                        }
                        set bError TRUE
                     } else {
                        set bDel TRUE
                        puts $iLogFileId \"$sCmd\"
                        puts $iLogFileId \"# \\\"$sType\\\" \\\"$sName\\\" \\\"$sRev\\\": $sResult - triggers $sTrig(3)\"
                     }
                     if {$bTrigOn} {mql trigger off}
                  }
                  
                  if {$bChgName} {
                     set sName $sChangeName
                  } elseif {$bChgNR && $bDelete && $sName != $sChangeName && $sChangeName != \"\"} {
                     set sName $sChangeName
                  }
                  if {$bChgRev} {
                     set sRev $sChangeRev
                  } elseif {$bChgNR && $bDelete && $sRev != $sChangeRev && $sChangeRev != \"\"} {
                     set sRev $sChangeRev
                  }
# modify other elements if setting allows                     
                  if {($bDel != \"TRUE\" ) && (($bModIfExists && $bNonByPass != \"FALSE\") || $bNonByPass == \"TRUE\")} {
                     set iErr  [ catch { mql print businessobject \"$sType\" \"$sName\" \"$sRev\" select policy vault owner id current dump \",\" } sChgMod ]   
                     set sChgMod1     [split \"$sChgMod\" \",\" ] 
                     set sCurPolicy   [ string trim [ lindex \"$sChgMod1\" 0 ] ]
                     set sCurVault    [ string trim [ lindex \"$sChgMod1\" 1 ] ]
                     set sCurOwner    [ string trim [ lindex \"$sChgMod1\" 2 ] ]
                     set sCurId       [ string trim [ lindex \"$sChgMod1\" 3 ] ]
                     set sCurState    [ string trim [ lindex \"$sChgMod1\" 4 ] ]
                     set bTrigOn FALSE
                     if {$bTrigOver(2) == \"ON\" || ($bTriggerMod == \"ON\" && $bTrigOver(2) != \"OFF\")} {
                     	  mql trigger on
                     	  set bTrigOn TRUE
                     }
# modify policy
                     if { \"$sPolicy\" == \"\"} {
                     } elseif { \"$sPolicy\" == \"$sCurPolicy\" } {
                     } else {
                        set sCmd  \"mql modify businessobject $sCurId policy \\\"$sPolicy\\\"\"
                        if {$bScan} {
                           puts $iLogFileId $sCmd
                        } elseif {[catch {eval $sCmd} sResult] != 0} {
                           puts $iLogFileId \"$sCmd\"
                           puts $iLogFileId \"\\n\\\"$sType\\\" \\\"$sName\\\" \\\"$sRev\\\" - error in modifying policy: $sResult - triggers $sTrig(2)\"
                           if {$bSpinnerAgent} {
                              set iLogFileErr [open $sLogFileError a+]
                              puts $iLogFileErr \"\\\"$sType\\\" \\\"$sName\\\" \\\"$sRev\\\" - error in modifying policy: $sResult - triggers $sTrig(2)\"
                              close $iLogFileErr
                           }
                           set bError TRUE
                        } else {
                           puts $iLogFileId \"$sCmd\"
                           puts $iLogFileId \"# \\\"$sType\\\" \\\"$sName\\\" \\\"$sRev\\\": policy changed - triggers $sTrig(2)\"
                           set bMod TRUE
                           incr iPolicyTotal
                           set sCurState [mql print businessobject \"$sType\" \"$sName\" \"$sRev\" select current dump]
                        }
                     }
# modify vault
                     if { \"$sVault\" == \"\"} {
                     } elseif { \"$sVault\" == \"$sCurVault\" } {
                     } else {
                        set sCmd  \"mql modify businessobject $sCurId vault \\\"$sVault\\\"\"
                        if {$bScan} {
                           puts $iLogFileId $sCmd
                        } elseif {[catch {eval $sCmd} sResult] != 0} {
                           puts $iLogFileId \"$sCmd\"
                           puts $iLogFileId \"\\n\\\"$sType\\\" \\\"$sName\\\" \\\"$sRev\\\" - error in change vault: $sResult - triggers $sTrig(2)\"
                           if {$bSpinnerAgent} {
                              set iLogFileErr [open $sLogFileError a+]
                              puts $iLogFileErr \"\\\"$sType\\\" \\\"$sName\\\" \\\"$sRev\\\" - error in change vault: $sResult - triggers $sTrig(2)\"
                              close $iLogFileErr
                           }
                           set bError TRUE
                        } else {
                           puts $iLogFileId \"$sCmd\"
                           puts $iLogFileId \"# \\\"$sType\\\" \\\"$sName\\\" \\\"$sRev\\\": vault changed - triggers $sTrig(2)\"
                           set bMod TRUE
                           incr iVaultTotal
                        }
                     }
# modify owner
                     if { \"$sOwner\" == \"\"} {
                     } elseif { \"$sOwner\" ==  \"$sCurOwner\" } {
                     } else {
                        set sCmd  \"mql modify businessobject $sCurId owner \\\"$sOwner\\\"\"
                        if {$bScan} {
                           puts $iLogFileId $sCmd
                        } elseif {[catch {eval $sCmd} sResult] != 0} {
                           puts $iLogFileId \"$sCmd\"
                           puts $iLogFileId \"\\n\\\"$sType\\\" \\\"$sName\\\" \\\"$sRev\\\" - error in owner change: $sResult - triggers $sTrig(2)\"
                           if {$bSpinnerAgent} {
                               set iLogFileErr [open $sLogFileError a+]
                               puts $iLogFileErr \"\\\"$sType\\\" \\\"$sName\\\" \\\"$sRev\\\" - error in owner change: $sResult - triggers $sTrig(2)\"
                               close $iLogFileErr
                           }
                           set bError TRUE
                        } else {
                           puts $iLogFileId \"$sCmd\"
                           puts $iLogFileId \"# \\\"$sType\\\" \\\"$sName\\\" \\\"$sRev\\\": owner changed - triggers $sTrig(2)\"
                           set bMod TRUE
                           incr iOwnerTotal
                        }
                     }
# modify attributes
                     if { \"$llAttr\" == \"\"} {
                     } else {
                     	regsub -all \"<NEWLINE>\" $llAttr \"\\\\\\n\" llAttr
                     	regsub -all \"<LINEFEED>\" $llAttr \"\\\\\\n\" llAttr
                     	regsub -all \"<RETURN>\" $llAttr \"\\\\\\n\" llAttr
                     	regsub -all \"<BACKSLASH>\" $llAttr \"\\\\\\\\\\\\\\\\\\\\\\\\\" llAttr
# Modified below for fixing 370077 on 25 Feb 09 . Added word escape. - start
                     	set sCmd  \"mql escape modify businessobject $sCurId $llAttr\"
# Modified below for fixing 370077 on 25 Feb 09 . Added word escape. - end

                        if {$bScan} {
                           puts $iLogFileId $sCmd
                        } elseif {[catch {eval $sCmd} sResult] != 0} {
                           puts $iLogFileId \"$sCmd\"
                           puts $iLogFileId \"\\n\\\"$sType\\\" \\\"$sName\\\" \\\"$sRev\\\" - error in attributes modify: $sResult - triggers $sTrig(2)\"
                           if {$bSpinnerAgent} {
                              set iLogFileErr [open $sLogFileError a+]
                              puts $iLogFileErr \"\\\"$sType\\\" \\\"$sName\\\" \\\"$sRev\\\" - error in attributes modify: $sResult - triggers $sTrig(2)\"
                              close $iLogFileErr
                           }
                           set bError TRUE
                        } else {
                           puts $iLogFileId \"$sCmd\"
                           puts $iLogFileId \"# \\\"$sType\\\" \\\"$sName\\\" \\\"$sRev\\\": attributes modified - triggers $sTrig(2)\"
                           set bMod TRUE
                           #Fix for defect 119
                           if { [regexp \"Warning: #1500218:\" $sResult] != 0 || [regexp \"Warning: #1900075:\" $sResult] != 0 } {
                              puts $iLogFileId \"\\n\\\"$sType\\\" \\\"$sName\\\" \\\"$sRev\\\" - error in attributes modify: $sResult - triggers $sTrig(2)\"
                              if {$bSpinnerAgent} {
                                 set iLogFileErr [open $sLogFileError a+]
                                 puts $iLogFileErr \"\\\"$sType\\\" \\\"$sName\\\" \\\"$sRev\\\" - uncaught error in attributes modify: $sResult - triggers $sTrig(2)\"
                                 puts $iLogFileErr \"\\\"$sType\\\" \\\"$sName\\\" \\\"$sRev\\\" - attributes before the wrong attribute have been updated, but not the ones after\"
                                 close $iLogFileErr
                              }
                              set bError TRUE
                           }
                           #End Fix for defect 119
                        }
                     }
                     if {$bTrigOn} {mql trigger off}
# modify states
                     if { \"$sCurState\" == \"$sState\"} {
                     } else {	
                        set lBus \"\\\"$sType\\\" \\\"$sName\\\" \\\"$sRev\\\"\"
                        if {$bScan} {
                           puts $iLogFileId \"Change '$lBus' to state '$sState'\"
                        } else {
                           pPromoteToTargetState \"$lBus\" \"$sState\"
                           set bMod TRUE
                        }
                     }
                  }
               }

# write cue
               if {$bError} {
               	  if {$bScan != \"TRUE\"} {mql abort transaction}
                  if {$bPercent == \"FALSE\"} {puts -nonewline \"!\"}
                  incr iErrTot
               } elseif {$bMod || $bAdd} {
                  if {$bScan != \"TRUE\"} {mql commit transaction}
                  if {$bMod} {
                     incr iModTotal
                     if {$bPercent == \"FALSE\"} {puts -nonewline \":\"}
                  } else {
                     incr iAddTotal
                     if {$bPercent == \"FALSE\"} {puts -nonewline \"+\"}
                  }
               } elseif {$bDel} {
                  if {$bScan != \"TRUE\"} {mql commit transaction}
                  if {$bPercent == \"FALSE\"} {puts -nonewline \"-\"}
                  incr iDelTotal
               } else {
                  if {$bScan != \"TRUE\"} {mql commit transaction}
                  if {$bPercent == \"FALSE\"} {puts -nonewline \".\"}
                  incr iSkipTotal
               }
               if {$bPercent && $iTenPercent < 10 && [expr $iAddTotal + $iModTotal + $iDelTotal + $iSkipTotal + $iErrTot] > [expr $iTenPercent * $iPercent]} {
                  pWriteCue
                  incr iTenPercent
               }
            } 
            # name is blank
         } 
         #  end of if
      } 
      ## end while for reading file
      if {$bPercent} {pWriteCue}
      pLogFile $iStartTime
      incr iErrTotal $iErrTot
   } 
   # end of forloop 
   close $iLogFileId
   mql set env BUSOBJERROR $iErrTotal
# Delete temporary policies for changing states
   foreach sTempPol $lsTempPolicy {
      catch {mql delete policy \"$sTempPol\"} sMsg
   }
   puts \"\"
} 
# end program

" 1 0 0 0 0 0 0 0 0 0 0 0 "" 0 0
 0 1
 SpinnerAgent NULL noname "3/27/2017 3:41:29 PM" 0
"12/6/2015 11:42:58 PM" "3/14/2018 3:57:25 PM"
7
 0 1 "12/6/2015 11:42:58 PM" creator "add program emxSpinnerBusObjects.tcl mql execute immediate !needsbusinessobject !downloadable !pipe !pooled nothidden file ./Business/SourceFiles/emxSpinnerBusObjects.tcl"
 0 2 "12/6/2015 11:42:58 PM" creator "add property SpinnerAgent on program emxSpinnerBusObjects.tcl value '12/6/2015 11:42:58 PM'"
 0 2 "12/6/2015 11:42:58 PM" creator "mod program emxSpinnerBusObjects.tcl description ''"
 0 2 "2/3/2016 5:21:01 PM" creator "mod property SpinnerAgent on program emxSpinnerBusObjects.tcl value '2/3/2016 5:21:01 PM'"
 0 2 "2/3/2016 5:21:01 PM" creator "mod program emxSpinnerBusObjects.tcl file ./Business/SourceFiles/emxSpinnerBusObjects.tcl"
 0 2 "3/27/2017 3:41:29 PM" creator "mod property SpinnerAgent on program emxSpinnerBusObjects.tcl value '3/27/2017 3:41:29 PM'"
 0 2 "3/27/2017 3:41:29 PM" creator "mod program emxSpinnerBusObjects.tcl file ./Business/SourceFiles/emxSpinnerBusObjects.tcl"

!MTRX!END

!MTRX!AD! program emxSpinnerBusRels.tcl "3DEXPERIENCE R2015x(24.0.0.0)"
emxSpinnerBusRels.tcl 0 "" "#*******************************************************************************10.59
# @progdoc        emxSpinnerBusRels.tcl vM10.59 (Build 5.9.30)
#
# @Description:   Add new relationships or modify/delete existing.  
#                 Multiple headers for merging different types may be used using <HEADER> as last field.
#                 The file format has to be followed as shown below:
#
#                 FromType(^t)FromName(^t)FromRev(^t)ToType(^t)ToName(^t)ToRev(^t)Direction(^t)Rel Name(^t)Attr 1(^t)Attr N(^t)[see note f](^t)[see note g](^t)[see note h](^t)[see note i]
#                    where (^t) is a tab
#
#  a.	Runs the spreadsheets in ./Relationships named '*.xls'
#  b.	Creates a log file in ./logs  
#  c.	This will connect relationships and also modify or delete existing relationships.
#  d.	Attribute values may also be added or modified on the relationship.  Use <NULL> for null values.
#  e.   To delete rel's, enter <DELETE> in column 9 for Attr 1.  This will remove ALL rel's of specified rel name.
#  f.   The first field after attributes is set to 'TRUE' or 'FALSE' to override global setting to force modifications.
#  g.   The second field after attributes is set to 'ON' or 'OFF' to override global setting for create triggers.
#  h.   The third field after attributes is set to 'ON' or 'OFF' to override global setting for mod triggers.
#  i.   The fourth field after attributes is set to 'ON' or 'OFF' to override global setting for delete triggers.
#
# @Parameters:    none
#
# @Usage:         Intended for loading administrative data for AEF schema.
#
# @progdoc        Copyright (c) 2003, MatrixOne
#
#*******************************************************************************
# @Modifications:
#
# Charles Merinsky 4/22/2003 - initial code.
# Balaji Sutti 4/3/2006 - IR Fix 315205.
# Venkatesh Harikrishnan - Modified for the new line issue.
#*******************************************************************************

tcl;

eval {
   if {[info host] == \"mostermant43\" } {
      source \"c:/Program Files/TclPro1.3/win32-ix86/bin/prodebug.tcl\"
      set cmd \"debugger_eval\"
      set xxx [debugger_init]
   } else {
      set cmd \"eval\"
   }
}
$cmd {

   set bModIfExists [mql get env BUSRELMODIFEXISTS]
   set bTriggerAdd [mql get env TRIGGERCREATE]
   set bTriggerMod [mql get env TRIGGERMODIFY]
   set bTriggerDel [mql get env TRIGGERDELETE]
   set sAllFiles [mql get env RELFILELIST]

#  ********************** USER DEFINED VARIABLES*******************************
   if {$bModIfExists == \"\"} {
      set bModIfExists \"TRUE\" ;#TRUE or FALSE - modify bus object if it exists
   }
   if {$bTriggerAdd == \"\"} {
      set bTriggerAdd \"OFF\" ;# ON or OFF - turn trigger on
   }
   if {$bTriggerMod == \"\"} {
      set bTriggerMod \"OFF\" ;# ON or OFF - turn trigger on
   }
   if {$bTriggerDel == \"\"} {
      set bTriggerDel \"OFF\" ;# ON or OFF - turn trigger on
   }
#  ****************************************************************************

   set sDate1 [clock format [clock seconds] -format %Y%m%d]
   set iStartTime  [clock seconds]
   set iErrTot 0
   set iErrTotal 0

# Scan Mode
   set bScan [mql get env SPINNERSCANMODE]
   if {$bScan != \"TRUE\"} {set bScan FALSE}
   if {$bScan} {set sDate1 \"SCAN\"}

   global iLogFileId 
   global iErrTot iAddTotal iModTotal iDelTotal
   if {$sAllFiles == \"\"} {set sAllFiles [glob -nocomplain \"./Relationships/*.xls\"]}  
   if {$sAllFiles == \"./Relationships/0\"} {set sAllFiles \"\"}
   if {$sAllFiles == \"\"} {
      puts -nonewline \"\\n*** No data files of format '*.xls' found ***\"
   }

#***************************************************************************
# Procedure:   pLogFile
# Description: Used after all records have been processed. Write time of execution and 
#              Totals of load to files.
# Parameters:  none.
# Returns:  none.
#***************************************************************************
   proc pLogFile { iStartTime } {
   
      global iLogFileId
      global iErrTot iAddTotal iModTotal iDelTotal iChgNameTotal iPolicyTotal iOwnerTotal iVaultTotal sAllFiles sCurFile
      
      set iEndTime  [clock seconds]
      incr iEndTime -$iStartTime
      set iMin  [expr $iEndTime / 60]
      set iSec  [expr $iEndTime - ($iMin * 60 )]
      set iHour [expr $iMin / 60 ]
      set iMin  [expr $iMin - ($iHour * 60 )]
      set iDay  [expr $iHour / 24 ]
      set iHour [expr $iHour - ($iDay * 24 )]
      set iSec  [format \"%0.2i\" $iSec]
      set iMin  [format \"%0.2i\" $iMin]
      
      if {$iAddTotal > 0} {puts $iLogFileId \"#     Number of Rels created:   $iAddTotal\"}
      if {$iModTotal > 0} {puts $iLogFileId \"#     Number of Rels modified:  $iModTotal\"} 
      if {$iDelTotal > 0} {puts $iLogFileId \"#     Number of Rels deleted:   $iDelTotal\"} 
      if {$iErrTot > 0} {puts $iLogFileId   \"#     Number of Errors:         $iErrTot\"}
      if {[expr $iAddTotal + $iModTotal + $iDelTotal + $iErrTot] > 0} {puts $iLogFileId \"#     Total time for load:               $iDay $iHour:$iMin:$iSec\"}
      if {[lsearch $sAllFiles $sCurFile] == [expr [llength $sAllFiles] - 1]} {puts $iLogFileId \"\"}
   }

#***************************************************************************
# Procedure:   pCheckAttrHdr
# Description:   This procedure checks Attribute for a null value.  Only
#  valid Attribute names with attribute values will be returned.  
# Returns:  Attributes.
#***************************************************************************
   proc pCheckAttrHdr { llName llValue } {
      set pCombo \"\"
      if {$llName != \"\" && $llValue != \"\" } {
         foreach lName $llName lValue $llValue {
            if {[string range $lValue 0 0] == \"\\042\" && [string range $lValue end end] == \"\\042\" && [string length $lValue] > 2} {
               if {[string first \",\" $lValue] > -1 || [string first \"\\042\\042\" $lValue] > -1} {
                  set iLast [expr [string length $lValue] -2]
            	set lValue [string range $lValue 1 $iLast]
            	regsub -all \"\\042\\042\" $lValue \"\\042\" lValue
               }
            }
            regsub -all \"\\134$\" $lValue \"\\134\\134\\$\" lValue
            regsub -all \"\\134{\" $lValue \"\\134\\134\\173\" lValue
            regsub -all \"\\134}\" $lValue \"\\134\\134\\175\" lValue
            regsub -all \"\\134\\133\" $lValue \"\\134\\134\\133\" lValue
            regsub -all \"\\134\\135\" $lValue \"\\134\\134\\135\" lValue
            regsub -all \"\\042\" $lValue \"\\134\\042\" lValue
            regsub -all \"'\" $lValue \"\\047\" lValue
            regsub -all \"<ESC>\" $lValue \"\\134\" lValue
            regsub -all \"<SPACE>\" $lValue \" \" lValue
            regsub -all \"<NULL>\" $lValue \"\" lValue
            append pCombo \" \\\"$lName\\\" \\\"$lValue\\\"\"
         }
      }
      return $pCombo
   }

# Procedure to write screen cue
   proc pWriteCue {} {
      global iAddTotal iModTotal iDelTotal iSkipTotal iErrTot iTenPercent iPrevAddModDel iPrevError
      set iAddModDel [expr $iAddTotal + $iModTotal + $iDelTotal - $iPrevAddModDel]
      set iError [expr $iErrTot - $iPrevError]
      set iPrevAddModDel [expr $iAddTotal + $iModTotal + $iDelTotal]
      set iPrevError $iErrTot
      set sWrite \"...\"
      if {$iAddModDel && $iError} {
         set sWrite \"  \\($iAddModDel\\: $iError\\!\\)\"
      } elseif {$iAddModDel} {
         set sWrite \"  \\($iAddModDel\\:\\)\"
      } elseif {$iError} {
         set sWrite \"  \\($iError\\!\\)\"
      }
      puts -nonewline \"$sWrite[expr $iTenPercent * 10]%\"
   }

# Main
   if {$sAllFiles != \"\"} {
      puts -nonewline \"\\n   global setting to modify rels if they exist: $bModIfExists\"
      puts -nonewline \"\\n   global setting for triggers: create - $bTriggerAdd; modify - $bTriggerMod; delete - $bTriggerDel\"
   }
   mql verbose on
   mql trigger off
   file mkdir \"./logs\"
   if {[mql get env SPINNERLOGFILE] != \"\"} {
      set sLogFilePath [mql get env SPINNERLOGFILE]
      set sLogFileError [mql get env SPINNERERRORLOG]
      set iLogFileErr [open $sLogFileError a+]
      set bSpinnerAgent TRUE
   } else {    
      set sLogFilePath \"./logs/BusRels\\.$sDate1.log\"
      set bSpinnerAgent FALSE
   }
   set iLogFileId    [open $sLogFilePath a+]

   foreach sCurFile $sAllFiles {
      set iFileId    [open $sCurFile r]
      puts $iLogFileId \"\\n# \\[[clock format [clock seconds] -format %H:%M:%S]\\] File '[file tail $sCurFile]'\"
      puts -nonewline \"\\nConnecting relationships from file '[file tail $sCurFile]'\"

      set iAddTotal      0 
      set iModTotal      0 
      set iDelTotal      0 
      set iErrTot        0
      set iSkipTotal     0
      set iHeader        0
      set iPrevAddModDel 0
      set iPrevError     0
      set bPercent   FALSE
      set iTenPercent    1
      set bTrigOver(1) OFF
      set bTrigOver(2) OFF
      set bTrigOver(3) OFF
      set bTrigOn FALSE

# READ FILES AND PROCESS RECORDS. 

      set lsFile [split [read $iFileId] \\n]
      close $iFileId
      if {[llength $lsFile] > 50} {
         set iPercent [expr [llength $lsFile] / 10]
         set bPercent TRUE
      }
      set iAttrEnd end
      foreach sLine $lsFile {
         set bRepeat TRUE
         set bSkipSkip FALSE
         while {$bRepeat} {
         set bRepeat FALSE
         set bDeleteFirst FALSE
         set sLine [string trim $sLine]
         set lsLine [split $sLine \\t]
         if {[string first \"<HEADER>\" $sLine] >= 0} {
            set iHeader 0
            set iAttrEnd [expr [llength $lsLine] -2]
            set lsLine [lrange $lsLine 0 $iAttrEnd]
         }
         if { $iHeader == 0 } {
            if {$iAttrEnd == \"end\"} {set iAttrEnd [expr [llength $lsLine] -1]}
            set llName     [ lrange  $lsLine 8 $iAttrEnd ]
            incr iHeader        
            set lsName \"\"
            foreach lName $llName {
               set lName [string trim $lName]
               if {[catch {
                  if {[mql print attribute $lName select type dump] == \"timestamp\"} {
                     set aTimeStamp($lName) TRUE
                  } else {
                     set aTimeStamp($lName) FALSE
                  }
               } sMsg] != 0} {
                  puts \"\\nERROR: Attribute name '$lName' is not a valid attribute or field order is incorrect.\"
                  close $iLogFileId
               	exit 1
               	return
               }
               lappend lsName $lName
            }
            set llName $lsName
         } elseif {$sLine != \"\"} {
            set sFromType [ string trim [ lindex $lsLine 0 ] ]
            set sFromName [ string trim [ lindex $lsLine 1 ] ]
            set sFromRev  [ string trim [ lindex $lsLine 2 ] ]
            set sToType   [ string trim [ lindex $lsLine 3 ] ]
            set sToName   [ string trim [ lindex $lsLine 4 ] ]
            set sToRev    [ string trim [ lindex $lsLine 5 ] ]
            set sToDir    [ string tolower [ string trim [ lindex $lsLine 6 ] ] ]
            set sRel      [ string trim [ lindex $lsLine 7 ] ]
            set sDelete   [ string trim [ lindex $lsLine 8 ] ]
            set bDelete FALSE
            if {$sDelete == \"<DELETE>\"} {
               set bDelete TRUE
               set llAttr \"\"
            } else {
               set llValue [ lrange  $lsLine 8 $iAttrEnd ]
               set lsName \"\"
               set lsValue \"\"
               foreach lName $llName lValue $llValue {
                  if {$lName != \"\"} {
                     set lValue [string trim $lValue]
                     if {$lValue != \"\"} {
                        if {$aTimeStamp($lName)} {set lValue [lindex [split [string trim $lValue] \" \"] 0]}
                        lappend lsName $lName
                        lappend lsValue $lValue
                     }
                  }
               }
               set llAttr [pCheckAttrHdr \"$lsName\" \"$lsValue\"]
            }
            set bNonByPass [string toupper [ string trim [ lindex $lsLine [expr $iAttrEnd + 1 ] ] ] ]
            set bTrigOver(1) [string toupper [ string trim [ lindex $lsLine [expr $iAttrEnd + 2 ] ] ] ]
            set bTrigOver(2) [string toupper [ string trim [ lindex $lsLine [expr $iAttrEnd + 3 ] ] ] ]
            set bTrigOver(3) [string toupper [ string trim [ lindex $lsLine [expr $iAttrEnd + 4 ] ] ] ]
            set sTrig(1) $bTriggerAdd
            set sTrig(2) $bTriggerMod
            set sTrig(3) $bTriggerDel
            for {set i 1} {$i < 4} {incr i} {
               if {$bTrigOver($i) == \"ON\" || $bTrigOver($i) == \"OFF\"} {set sTrig($i) $bTrigOver($i)}
            }
            set sFromDir \"from\"
            if {$sToDir == \"from\"} {set sFromDir \"to\"}
            set sFromCard \"\"
            set sToCard \"\"
            set sFromCard [mql print rel $sRel select \"$sFromDir\\cardinality\" dump]
            set sToCard [mql print rel $sRel select \"$sToDir\\cardinality\" dump]
            set sSkip \"n\"
            if {$sFromName != \"\"} {
# Check From Type and To Type existence
               set iErr1  [ catch { mql print businessobject \"$sFromType\" \"$sFromName\" \"$sFromRev\" select id dump } sFromId ]   
               set iErr2  [ catch { mql print businessobject \"$sToType\" \"$sToName\" \"$sToRev\" select id dump } sToId ]   
               if { [expr $iErr1 + $iErr2] != 0} {
                  if {$bDelete} {
               	   set sSkip \"d\"
               	} else {
               	   if {$iErr1 != 0} {
                        puts $iLogFileId \"\\n\\\"$sFromType\\\" \\\"$sFromName\\\" \\\"$sFromRev\\\" to \\\"$sToType\\\" \\\"$sToName\\\" \\\"$sToRev\\\": \\\"$sFromType\\\" \\\"$sFromName\\\" \\\"$sFromRev\\\" does not exist\"
                        if {$bSpinnerAgent} {puts $iLogFileErr \"\\\"$sFromType\\\" \\\"$sFromName\\\" \\\"$sFromRev\\\" to \\\"$sToType\\\" \\\"$sToName\\\" \\\"$sToRev\\\": \\\"$sFromType\\\" \\\"$sFromName\\\" \\\"$sFromRev\\\" does not exist\"}
                     }
                     if {$iErr2 != 0} {
                        puts $iLogFileId \"\\n\\\"$sFromType\\\" \\\"$sFromName\\\" \\\"$sFromRev\\\" to \\\"$sToType\\\" \\\"$sToName\\\" \\\"$sToRev\\\": \\\"$sToType\\\" \\\"$sToName\\\" \\\"$sToRev\\\" does not exist\"
                        if {$bSpinnerAgent} {puts $iLogFileErr \"\\\"$sFromType\\\" \\\"$sFromName\\\" \\\"$sFromRev\\\" to \\\"$sToType\\\" \\\"$sToName\\\" \\\"$sToRev\\\": \\\"$sToType\\\" \\\"$sToName\\\" \\\"$sToRev\\\" does not exist\"}
                     }
                     incr iErrTot
                     set sSkip \"y\"
                  }
               }
# Check Cardinality and set Add or Mod
               if {$sSkip == \"n\"} {
                  set aConnect(\"$sFromId|$sToId|$sRel\") \"\"
                  set sSkip \"a\"
               	if {[catch {set lsExpandFrom $aExpandFrom(\"$sRel|$sFromId\")} sMsg] != 0} { 
                     set lsExpandFrom [split [mql print bus $sFromId select $sFromDir\\[$sRel\\].id dump |] |]
                     set aExpandFrom(\"$sRel|$sFromId\") $lsExpandFrom
                  }
               	if {[catch {set lsExpandTo $aExpandTo(\"$sRel|$sToId\")} sMsg] != 0} { 
                     set lsExpandTo [split [mql print bus $sToId select $sToDir\\[$sRel\\].id dump |] |]
                     set aExpandTo(\"$sRel|$sToId\") $lsExpandTo
                  }
                  if {$bDelete && ($lsExpandFrom == \"\" || $lsExpandTo == \"\") } {
                     set sSkip \"d\"
                  } elseif {$lsExpandFrom == \"\" && $lsExpandTo == \"\"} {
                     set bMatch(\"$sFromId|$sToId|$sRel\") TRUE
                  } elseif {$lsExpandFrom == \"\" && $lsExpandTo != \"\"} {
                     if {$sFromCard == \"One\"} {
                        puts $iLogFileId \"\\n\\\"$sFromType\\\" \\\"$sFromName\\\" \\\"$sFromRev\\\" to \\\"$sToType\\\" \\\"$sToName\\\" \\\"$sToRev\\\": \\\"$sToType\\\" \\\"$sToName\\\" \\\"$sToRev\\\" cardinality violation\"
                        if {$bSpinnerAgent} {puts $iLogFileErr \"\\\"$sFromType\\\" \\\"$sFromName\\\" \\\"$sFromRev\\\" to \\\"$sToType\\\" \\\"$sToName\\\" \\\"$sToRev\\\": \\\"$sToType\\\" \\\"$sToName\\\" \\\"$sToRev\\\" cardinality violation\"}
                        incr iErrTot
                        set sSkip \"y\"
                     }
                  } elseif {$lsExpandFrom != \"\" && $lsExpandTo == \"\"} {
                     if {$sToCard == \"One\"} {
                        puts $iLogFileId \"\\n\\\"$sFromType\\\" \\\"$sFromName\\\" \\\"$sFromRev\\\" to \\\"$sToType\\\" \\\"$sToName\\\" \\\"$sToRev\\\": \\\"$sToType\\\" \\\"$sToName\\\" \\\"$sToRev\\\" cardinality violation\"
                        if {$bSpinnerAgent} {puts $iLogFileErr \"\\\"$sFromType\\\" \\\"$sFromName\\\" \\\"$sFromRev\\\" to \\\"$sToType\\\" \\\"$sToName\\\" \\\"$sToRev\\\": \\\"$sToType\\\" \\\"$sToName\\\" \\\"$sToRev\\\" cardinality violation\"}
                        incr iErrTot
                        set sSkip \"y\"
                     }
                  } else {
                     if {[catch {
                        if {$bMatch(\"$sFromId|$sToId|$sRel\")} {
                           if {[mql print rel $sRel select preventduplicates dump]} {
                              set sSkip \"m\"
                              puts $iLogFileId \"\\nWARNING: Rel '$sRel' from \\\"$sFromType\\\" \\\"$sFromName\\\" \\\"$sFromRev\\\" to \\\"$sToType\\\" \\\"$sToName\\\" \\\"$sToRev\\\" is duplicated\"
                              if {$bSpinnerAgent} {puts $iLogFileErr \"WARNING: Rel '$sRel' from \\\"$sFromType\\\" \\\"$sFromName\\\" \\\"$sFromRev\\\" to \\\"$sToType\\\" \\\"$sToName\\\" \\\"$sToRev\\\" is duplicated\"}
                           } elseif {$sFromCard == \"One\" || $sToCard == \"One\"} {
                                 puts $iLogFileId \"\\nERROR: Rel '$sRel' from \\\"$sFromType\\\" \\\"$sFromName\\\" \\\"$sFromRev\\\" to \\\"$sToType\\\" \\\"$sToName\\\" \\\"$sToRev\\\" is duplicated\"
                                 if {$bSpinnerAgent} {puts $iLogFileErr \"ERROR: Rel '$sRel' from \\\"$sFromType\\\" \\\"$sFromName\\\" \\\"$sFromRev\\\" to \\\"$sToType\\\" \\\"$sToName\\\" \\\"$sToRev\\\" is duplicated\"}
                                 incr iErrTot
                                 set sSkip \"y\"
                           }	
                        }
                     } sMsg] != 0} {
                     	set bMatch(\"$sFromId|$sToId|$sRel\") TRUE
                        foreach sExpand $lsExpandFrom {
                           if {[lsearch $lsExpandTo $sExpand] >= 0} {
                              lappend aConnect(\"$sFromId|$sToId|$sRel\") $sExpand
                           }
                        }
                        if {[llength $aConnect(\"$sFromId|$sToId|$sRel\")] > 1} {
                           set bDeleteFirst TRUE
                        } elseif {$aConnect(\"$sFromId|$sToId|$sRel\") != \"\"} {
                           set sSkip \"m\"
                        } elseif {$bDelete} {
                           set sSkip \"d\"
                        } elseif {$sFromCard == \"One\" || $sToCard == \"One\"} {
                              puts $iLogFileId \"\\nERROR: Rel '$sRel' from \\\"$sFromType\\\" \\\"$sFromName\\\" \\\"$sFromRev\\\" to \\\"$sToType\\\" \\\"$sToName\\\" \\\"$sToRev\\\" cardinality violation\"
                              if {$bSpinnerAgent} {puts $iLogFileErr \"ERROR: Rel '$sRel' from \\\"$sFromType\\\" \\\"$sFromName\\\" \\\"$sFromRev\\\" to \\\"$sToType\\\" \\\"$sToName\\\" \\\"$sToRev\\\" cardinality violation\"}
                              incr iErrTot
                              set sSkip \"y\"
                        }	
                     }
                  }
               }
# Process Add, Mod or Skip
               if {$sSkip == \"d\"} {
                  if {$bSkipSkip != \"TRUE\"} {
                     if {$bPercent == \"FALSE\"} {puts -nonewline \".\"}
                     incr iSkipTotal
                  }
               } elseif {$sSkip != \"y\"} {
               	set bError FALSE
                  if {$bScan != \"TRUE\"} {mql start transaction update}
                  if {$sSkip == \"a\" && $bDelete != \"TRUE\"} {
                     if {$bDeleteFirst} {
                        foreach sConnect $aConnect(\"$sFromId|$sToId|$sRel\") {
                           set sCmd \"mql disconnect connection $sConnect\"
                           puts $iLogFileId \"$sCmd; #Rel: \\\"$sRel\\\" BusObj: \\\"$sFromType\\\" \\\"$sFromName\\\" \\\"$sFromRev\\\" To: \\\"$sToType\\\" \\\"$sToName\\\" \\\"$sToRev\\\"\"
                           if {[catch {eval $sCmd} sResult]} {
                              puts $iLogFileId \"\\nERROR: Cannot disconnect duplicate rel.  Error message: \\n$sResult\"
                              if {$bSpinnerAgent} {puts $iLogFileErr \"\\nERROR: Cannot disconnect duplicate rel.  Error message: \\n$sResult\"}
                              if {$bPercent == \"FALSE\"} {puts -nonewline \"!\"}
                              incr iErrTot
                              mql abort transaction
                              set bError TRUE
                              break
                           }
# Remove rel from lists
                           set lsExpandFrom \"\"
                           foreach sExpandFrom $aExpandFrom(\"$sRel|$sFromId\") {
                              if {[lsearch $aConnect(\"$sFromId|$sToId|$sRel\") $sExpandFrom] < 0} {
                                 lappend lsExpandFrom $sExpandFrom
                              }
                           }
                           set aExpandFrom(\"$sRel|$sFromId\") $lsExpandFrom
                           set lsExpandTo \"\"
                           foreach sExpandTo $aExpandTo(\"$sRel|$sToId\") {
                              if {[lsearch $aConnect(\"$sFromId|$sToId|$sRel\") $sExpandTo] < 0} {
                                 lappend lsExpandTo $sExpandTo
                              }
                           }
                           set aExpandTo(\"$sRel|$sToId\") $lsExpandTo                           
                        }
                     }

	# Modified by Solution Library for the New Line Feeder error - Start
		     regsub -all {<NEWLINE>} $llAttr \"\\\\\\n\" llAttr
	# Modified by Solution Library for the New Line Feeder error - End
                     set sCmd \"mql connect bus $sFromId rel \\\"$sRel\\\" $sToDir $sToId $llAttr\"
                     puts $iLogFileId \"$sCmd\"
                     set bTrigOn FALSE
                     if {$bTrigOver(1) == \"ON\" || ($bTriggerAdd == \"ON\" && $bTrigOver(1) != \"OFF\")} {
                     	mql trigger on
                     	set bTrigOn TRUE
                     }
                     if {$bScan || $bError} {
                     } elseif {[catch {eval $sCmd} sResult]} {
                        puts $iLogFileId \"\\nRel: \\\"$sRel\\\" BusObj: \\\"$sFromType\\\" \\\"$sFromName\\\" \\\"$sFromRev\\\" To: \\\"$sToType\\\" \\\"$sToName\\\" \\\"$sToRev\\\": $sResult - triggers $sTrig(1)\"
                        if {$bSpinnerAgent} {puts $iLogFileErr \"Rel: \\\"$sRel\\\" BusObj: \\\"$sFromType\\\" \\\"$sFromName\\\" \\\"$sFromRev\\\" to \\\"$sToType\\\" \\\"$sToName\\\" \\\"$sToRev\\\": $sResult - triggers $sTrig(1)\"}
                        if {$bPercent == \"FALSE\"} {puts -nonewline \"!\"}
                        incr iErrTot
                        mql abort transaction
                     } else {
                        puts $iLogFileId \"# \\\"$sFromType\\\" \\\"$sFromName\\\" \\\"$sFromRev\\\" to \\\"$sToType\\\" \\\"$sToName\\\" \\\"$sToRev\\\": $sResult - triggers $sTrig(1)\"
                        if {$bPercent == \"FALSE\"} {puts -nonewline \"+\"}
                        incr iAddTotal
                        mql commit transaction
                        set sNewID [mql print connection bus \"$sFromType\" \"$sFromName\" \"$sFromRev\" $sToDir \"$sToType\" \"$sToName\" \"$sToRev\" rel \"$sRel\" select id dump]
                        lappend aExpandFrom(\"$sRel|$sFromId\") $sNewID
                        lappend aExpandTo(\"$sRel|$sToId\") $sNewID
			# IR Fix 315205
			set bMatch(\"$sFromId|$sToId|$sRel\") TRUE
                     }
                     if {$bTrigOn} {mql trigger off}
                  } elseif {$bDelete || ($sSkip == \"m\" && $llAttr != \"\")} {
                     if {$bDelete} {
                     	set sModDel disconnect
                     	set sConnect \"\"
                     } else {
                     	set sModDel modify
                     	set sConnect connection
                     }
                     if {$bDelete || $bNonByPass == \"TRUE\" || ($bModIfExists && $bNonByPass != \"FALSE\")} {
	# Modified by Solution Library for the New Line Feeder error - Start
		        regsub -all {<NEWLINE>} $llAttr \"\\\\\\n\" llAttr
	# Modified by Solution Library for the New Line Feeder error - End
                        set sCmd \"mql $sModDel $sConnect bus \\\"$sFromType\\\" \\\"$sFromName\\\" \\\"$sFromRev\\\" $sToDir \\\"$sToType\\\" \\\"$sToName\\\" \\\"$sToRev\\\" rel \\\"$sRel\\\" $llAttr\"
                        puts $iLogFileId \"$sCmd\"
                        set bTrigOn FALSE
                        if {$bModIfExists} {
                           if {$bTrigOver(2) == \"ON\" || ($bTriggerMod == \"ON\" && $bTrigOver(2) != \"OFF\")} {
                              mql trigger on
                              set bTrigOn TRUE
                           }
                        }
                        if {$bDelete} {
                           if {$bTrigOver(3) == \"ON\" || ($bTriggerDel == \"ON\" && $bTrigOver(3) != \"OFF\")} {
                              mql trigger on
                              set bTrigOn TRUE
                              set sTrig(2) $sTrig(3)
                           }
                        }
                        if {$bScan} {
                        } elseif {[catch {eval $sCmd} sResult]} {
                           puts $iLogFileId \"\\n\\\"$sFromType\\\" \\\"$sFromName\\\" \\\"$sFromRev\\\" to \\\"$sToType\\\" \\\"$sToName\\\" \\\"$sToRev\\\": $sResult - triggers $sTrig(2)\"
                           if {$bSpinnerAgent} {puts $iLogFileErr \"\\\"$sFromType\\\" \\\"$sFromName\\\" \\\"$sFromRev\\\" to \\\"$sToType\\\" \\\"$sToName\\\" \\\"$sToRev\\\": $sResult - triggers $sTrig(2)\"}
                           if {$bPercent == \"FALSE\"} {puts -nonewline \"!\"}
                           incr iErrTot
                           mql abort transaction
                        } else {
                           puts $iLogFileId \"# \\\"$sFromType\\\" \\\"$sFromName\\\" \\\"$sFromRev\\\" to \\\"$sToType\\\" \\\"$sToName\\\" \\\"$sToRev\\\": $sResult - triggers $sTrig(2)\"
                           if {$bDelete} {
                              if {$bPercent == \"FALSE\"} {puts -nonewline \"-\"}
                              incr iDelTotal
                              set bRepeat TRUE
                              set bSkipSkip TRUE
                              unset aExpandFrom(\"$sRel|$sFromId\")
                              unset aExpandTo(\"$sRel|$sToId\")
                           } else {
                              if {$bPercent == \"FALSE\"} {puts -nonewline \":\"}
                              incr iModTotal
                           }
                           mql commit transaction
                        }
                        if {$bTrigOn} {mql trigger off}
                     } else {
                        if {$bScan != \"TRUE\"} {mql commit transaction}
                        if {$bPercent == \"FALSE\"} {puts -nonewline \".\"}
                        incr iSkipTotal
                     }      
                  } else {
                     if {$bScan != \"TRUE\"} {mql commit transaction}
                     if {$bPercent == \"FALSE\"} {puts -nonewline \".\"}
                     incr iSkipTotal
                  }
               } else {
                  if {$bPercent == \"FALSE\"} {puts -nonewline \"!\"}
               }
            }
         } 
# Write cue
         if {$bPercent && $iTenPercent < 10 && [expr $iAddTotal + $iModTotal + $iDelTotal + $iSkipTotal + $iErrTot] > [expr $iTenPercent * $iPercent]} {
            pWriteCue
            incr iTenPercent
         }
         }
      } 
      # end while for reading file
      if {$bPercent} {pWriteCue}
      pLogFile $iStartTime
      incr iErrTotal $iErrTot
   } 
   # end of forloop
   close $iLogFileId
   mql set env BUSRELERROR $iErrTotal
   puts \"\"
} 
# end program
" 1 0 0 0 0 0 0 0 0 0 0 0 "" 0 0
 0 1
 SpinnerAgent NULL noname "3/27/2017 3:41:29 PM" 0
"12/6/2015 11:42:58 PM" "3/14/2018 3:57:25 PM"
7
 0 1 "12/6/2015 11:42:58 PM" creator "add program emxSpinnerBusRels.tcl mql execute immediate !needsbusinessobject !downloadable !pipe !pooled nothidden file ./Business/SourceFiles/emxSpinnerBusRels.tcl"
 0 2 "12/6/2015 11:42:58 PM" creator "add property SpinnerAgent on program emxSpinnerBusRels.tcl value '12/6/2015 11:42:58 PM'"
 0 2 "12/6/2015 11:42:58 PM" creator "mod program emxSpinnerBusRels.tcl description ''"
 0 2 "2/3/2016 5:21:01 PM" creator "mod property SpinnerAgent on program emxSpinnerBusRels.tcl value '2/3/2016 5:21:01 PM'"
 0 2 "2/3/2016 5:21:01 PM" creator "mod program emxSpinnerBusRels.tcl file ./Business/SourceFiles/emxSpinnerBusRels.tcl"
 0 2 "3/27/2017 3:41:29 PM" creator "mod property SpinnerAgent on program emxSpinnerBusRels.tcl value '3/27/2017 3:41:29 PM'"
 0 2 "3/27/2017 3:41:29 PM" creator "mod program emxSpinnerBusRels.tcl file ./Business/SourceFiles/emxSpinnerBusRels.tcl"

!MTRX!END

!MTRX!AD! program emxSpinnerBusFiles.tcl "3DEXPERIENCE R2015x(24.0.0.0)"
emxSpinnerBusFiles.tcl 0 "" "#*******************************************************************************10.62
# @progdoc        emxSpinnerBusFiles.tcl vM10.62 (Build 7.2.7)
#
# @Brief:         Checkin or delete bus object files
#
# @Description:   Create, modify or delete business objects
#                 The file format has to be followed as shown below:
#
#                 Type(^t)Name(^t)Rev(^t)Format(^t)File Path(^t)[see notes c & d](^t)[see note e]
#                    where (^t) is a tab
#
#  a.	Runs the spreadsheets in ./Objects/Files and creates a log file in ./logs
#  b.	Use one row per file path.
#  c.	This program will delete the file if <DELETE> is specified in column after File Path (6th column).
#  d.   The sixth field is set to 'ON' or 'OFF' to override global checkin trigger.
#  e.   The seventh field is used to replace files if set to 'REPLACE' (append is default).
#
# @Parameters:    none.
#
# @Returns:       Nothing   
#
# @Usage:         Can be used for legacy load into production.
#
# @progdoc        Copyright (c) 2003, MatrixOne
#*******************************************************************************
# @Modifications:
#
# FirstName LastName mm/dd/yyyy - Description
#
#*******************************************************************************

tcl;

eval {
   if {[info host] == \"mostermant43\" } {
      source \"c:/Program Files/TclPro1.3/win32-ix86/bin/prodebug.tcl\"
      set cmd \"debugger_eval\"
      set xxx [debugger_init]
   } else {
      set cmd \"eval\"
   }
}
$cmd {

   set bTriggerChk [mql get env TRIGGERCHECKIN]
   set sAllFiles [mql get env FILELIST]

#  ********************** USER DEFINED VARIABLES*******************************
   if {$bTriggerChk == \"\"} {
      set bTriggerChk \"OFF\" ;# ON or OFF - turn trigger on
   }
#  ****************************************************************************

   set sDate1 [clock format [clock seconds] -format %Y%m%d]
   set iStartTime  [clock seconds]
   set iErrTotal      0
   set bError     FALSE
   
# Scan Mode
   set bScan [mql get env SPINNERSCANMODE]
   if {$bScan != \"TRUE\"} {set bScan FALSE}
   if {$bScan} {set sDate1 \"SCAN\"}

# CDM Awareness
   set bCDM [mql get env CDMAWARE]
   if {$bCDM != \"TRUE\"} {set bCDM FALSE}

   global iLogFileId 
   global iErrTot iModTotal iDelTotal iChgNameTotal iPolicyTotal iOwnerTotal iVaultTotal iPromoteTotal iDemoteTotal bCDM
   
##  this is to set the path
   if {$sAllFiles == \"\"} {set sAllFiles [ glob -nocomplain \"./Objects/Files/*.xls\" ]}
   if {$sAllFiles == \"./Objects/Files/0\"} {set sAllFiles \"\"}
   if {$sAllFiles == \"\"} {
      puts -nonewline \"\\n*** No data files found ***\"
   }
   
#***************************************************************************
# Procedure:   pLogFile
# Description: Used after all records have been processed. Write time of execution and 
#              Totals of load to files.
# Parameters:  none.
# Returns:  none.
#***************************************************************************
   proc pLogFile { iStartTime } {
   
      global iLogFileId
      global iErrTot iDelTotal iModTotal iChgNameTotal iPolicyTotal iOwnerTotal iVaultTotal iPromoteTotal iDemoteTotal sAllFiles sCurFile
      
      set iEndTime  [clock seconds]
      incr iEndTime -$iStartTime
      set iMin  [expr $iEndTime / 60]
      set iSec  [expr $iEndTime - ($iMin * 60 )]
      set iHour [expr $iMin / 60 ]
      set iMin  [expr $iMin - ($iHour * 60 )]
      set iDay  [expr $iHour / 24 ]
      set iHour [expr $iHour - ($iDay * 24 )]
      set iSec  [format \"%0.2i\" $iSec]
      set iMin  [format \"%0.2i\" $iMin]
      
      if {$iModTotal > 0} {puts $iLogFileId \"#     Number of Files checked-in:        $iModTotal\"}
      if {$iDelTotal > 0} {puts $iLogFileId \"#     Number of Files deleted:           $iDelTotal\"}
      if {$iErrTot > 0} {puts $iLogFileId \"#     Number of Errors:                  $iErrTot\"}
      if {[expr $iDelTotal + $iModTotal + $iErrTot] > 0} {puts $iLogFileId \"#     Total time for load:               $iDay $iHour:$iMin:$iSec\"}
      
      if {[lsearch $sAllFiles $sCurFile] == [expr [llength $sAllFiles] - 1]} {puts $iLogFileId \"\"}
   }

# Procedure to write screen cue
   proc pWriteCue {} {
      global iDelTotal iModTotal iSkipTotal iErrTot iTenPercent iPrevAddModDel iPrevError
      set iAddModDel [expr $iDelTotal + $iModTotal - $iPrevAddModDel]
      set iError [expr $iErrTot - $iPrevError]
      set iPrevAddModDel [expr $iDelTotal + $iModTotal]
      set iPrevError $iErrTot
      set sWrite \"...\"
      if {$iAddModDel && $iError} {
         set sWrite \"  \\($iAddModDel\\: $iError\\!\\)\"
      } elseif {$iAddModDel} {
         set sWrite \"  \\($iAddModDel\\:\\)\"
      } elseif {$iError} {
         set sWrite \"  \\($iError\\!\\)\"
      }
      puts -nonewline \"$sWrite[expr $iTenPercent * 10]%\"
   }

#main

   if {$sAllFiles != \"\"} {
      puts \"\\n   global setting for triggers: checkin - $bTriggerChk\"
      set sCDM \"OFF\"
      if {$bCDM} {set sCDM \"ON\"}
      puts \"   global setting for CDM awareness - $sCDM\"
   }
   mql verbose on
   mql trigger off
   file mkdir \"./logs\"
   if {[mql get env SPINNERLOGFILE] != \"\"} {
      set sLogFilePath [mql get env SPINNERLOGFILE]
      set sLogFileError [mql get env SPINNERERRORLOG]
      set bSpinnerAgent TRUE
   } else {    
      set sLogFilePath \"./logs/BusFiles\\.$sDate1.log\"
      set bSpinnerAgent FALSE
   }
   set iLogFileId    [open $sLogFilePath a+]
   
   set lsCDMType {}
   if {[mql list relationship \"Latest Version\"] == \"\"} {
      set bCDM FALSE
   } elseif {$bCDM} {
      set lsFromType [split [mql print relationship \"Latest Version\" select fromtype dump |] |]
      foreach sFromType $lsFromType {
         set lslsFromType [split [mql print type $sFromType select derivative dump |] |]
         set lsCDMType [concat $lsCDMType $lslsFromType]
      }
      set lsCDMType [lsort -unique $lsCDMType]
   }
   
   foreach sCurFile $sAllFiles {
      set iFileId    [open $sCurFile r]
      puts $iLogFileId \"\\n# \\[[clock format [clock seconds] -format %H:%M:%S]\\] File: '[file tail $sCurFile]'\"
      puts -nonewline \"Checking in files specified in '[file tail $sCurFile]'\"
      
      set iErrTot        0
      set iDelTotal      0 
      set iModTotal      0 
      set iHeader        0
      set iSkipTotal     0
      set iPrevAddModDel 0
      set iPrevError     0
      set bPercent   FALSE
      set iTenPercent    1
      set bTrigOver OFF
      set bTrigOn FALSE

# READ FILES AND PROCESS RECORDS. 

      set lsFile [split [read $iFileId] \\n]
      close $iFileId
      if {[llength $lsFile] > 50} {
         set iPercent [expr [llength $lsFile] / 10]
         set bPercent TRUE
      }
      foreach sLine $lsFile {
         set sLine [string trim $sLine]
         set lsLine [split $sLine \\t]
         if {[string first \"<HEADER>\" $sLine] >= 0} {
            set iHeader 0
            set lsLine [lrange $lsLine 0 [expr [llength $lsLine] -2]]
         }         
         if { $iHeader == 0 } {
            incr iHeader
         } elseif {$sLine != \"\"} {
            set sType     [ string trim [ lindex $lsLine 0 ] ]
            set sName     [ string trim [ lindex $lsLine 1 ] ]
            set sRev      [ string trim [ lindex $lsLine 2 ] ]
            set sFormat   [ string trim [ lindex $lsLine 3 ] ]
            set sChkPath  [ string trim [ lindex $lsLine 4 ] ]
            set bTrigOver [string toupper [ string trim [ lindex $lsLine 5 ] ] ]
            set sReplace  [string toupper [ string trim [ lindex $lsLine 6 ] ] ]
            set bCDMRow FALSE
            set sCDMAppend \" - CDM awareness OFF\"
            if {$bCDM} {
               if {[lsearch $lsCDMType $sType] >= 0} {
                  set bCDMRow TRUE
                  set sCDMAppend \" - CDM awareness ON\"
               }
            }
            regsub -all \"\\134\\134\" $sChkPath \"/\" sChkPath
            set bDelete FALSE
            if {$bTrigOver == \"<DELETE>\"} {set bDelete TRUE}
            set bReplace FALSE
            if {$sReplace == \"REPLACE\"} {set bReplace TRUE}
            set sTrig $bTriggerChk
            if {$bTrigOver == \"ON\" || $bTrigOver == \"OFF\"} {set sTrig $bTrigOver}
            
# basic checks
            if { [mql print businessobject \"$sType\" \"$sName\" \"$sRev\" select exists dump] == \"FALSE\" } {
               puts $iLogFileId \"#Business Object \\\"$sType\\\" \\\"$sName\\\" \\\"$sRev\\\" does not exist\"
               if {$bSpinnerAgent} {
                  set iLogFileErr [open $sLogFileError a+]
               	  puts $iLogFileErr \"\\\"$sType\\\" \\\"$sName\\\" \\\"$sRev\\\" does not exist\"
               	  close $iLogFileErr
               }
               if {$bPercent == \"FALSE\"} {puts -nonewline \"!\"}
               incr iErrTot
            } elseif {[file exists $sChkPath] == 0 && !$bDelete} {
               puts $iLogFileId \"#File '$sChkPath' for BO \\\"$sType\\\" \\\"$sName\\\" \\\"$sRev\\\" does not exist or not accessible\"
               if {$bSpinnerAgent} {
                  set iLogFileErr [open $sLogFileError a+]
               	  puts $iLogFileErr \"File '$sChkPath' for BO \\\"$sType\\\" \\\"$sName\\\" \\\"$sRev\\\" does not exist or not accessible\"
               	  close $iLogFileErr
               }
               if {$bPercent == \"FALSE\"} {puts -nonewline \"!\"}
               incr iErrTot
            } else {            	            	
               set bError FALSE
               set bMod FALSE
               set bDel FALSE
               set bExists FALSE
               set oID [mql print bus \"$sType\" \"$sName\" \"$sRev\" select id dump]
               set lsBOFile [split [mql print bus \"$sType\" \"$sName\" \"$sRev\" select format.file.name dump |] |]
               set sDirectory [file dirname $sChkPath]
               append sDirectory \"/\"
               set sFile [file tail $sChkPath]
               set sPolicy [mql print bus \"$sType\" \"$sName\" \"$sRev\" select policy dump]
               set sStore [mql print policy \"$sPolicy\" select store dump]
               if {[lsearch $lsBOFile $sFile] >= 0} {
               	  set bCheckedIn TRUE
               } else {
               	  set bCheckedIn FALSE
               }
               if {$bScan != \"TRUE\"} {mql start transaction update}
# delete bus object file
               if {$bDelete && $bCheckedIn} {
                  set sDelFormat [mql print bus \"$sType\" \"$sName\" \"$sRev\" select format.file\\[$sFile\\].format dump]
                  set sCmd  \"mql delete bus \\042$sType\\042 \\042$sName\\042 \\042$sRev\\042 format \\042$sDelFormat\\042 file \\042$sFile\\042\"
                  if {$bScan} {
                     puts $iLogFileId $sCmd
                  } elseif {[catch {eval $sCmd} sResult] != 0} {
                     puts $iLogFileId \"$sCmd\"
                     puts $iLogFileId \"# \\\"$sType\\\" \\\"$sName\\\" \\\"$sRev\\\" file \\\"$sFile\\\": $sResult\"
                     if {$bSpinnerAgent} {
                        set iLogFileErr [open $sLogFileError a+]
                     	puts $iLogFileErr \"\\\"$sType\\\" \\\"$sName\\\" \\\"$sRev\\\" file \\\"$sFile\\\": $sResult\"
                     	close $iLogFileErr
                     }
                     set bError TRUE
                  } else {
                     set bDel TRUE
                     puts $iLogFileId \"$sCmd\"
                     puts $iLogFileId \"# \\\"$sType\\\" \\\"$sName\\\" \\\"$sRev\\\" file \\\"$sFile\\\": $sResult\"
# CDM - Delete Version Objects
                     if {$bCDMRow} {
                        set slsExpBus [lindex [split [mql expand bus \\042$sType\\042 \\042$sName\\042 \\042$sRev\\042 rel \\042Latest Version\\042 from select bus last where \\042attribute\\[Title\\] == '$sFile'\\042 dump |] \\n] 0]
                        if {$slsExpBus != \"\"} {
                           set lsExpBus [split $slsExpBus |]
                           set sVerName [lindex $lsExpBus 4]
                           set iVersion [lindex $lsExpBus 6]
                           for {set i $iVersion} {$i >= 1} {incr i -1} {
                              if {[mql print bus \"$sType\" \"$sVerName\" $i select exists dump]} {
                                 set sCmd \"mql delete bus \\042$sType\\042 \\042$sVerName\\042 \\042$i\\042\"
                                 if {$bScan} {
                                    puts $iLogFileId $sCmd
                                 } elseif {[catch {eval $sCmd} sResult] != 0} {
                                    puts $iLogFileId \"$sCmd\"
                                    puts $iLogFileId \"# \\\"$sType\\\" \\\"$sName\\\" \\\"$sRev\\\" file \\\"$sFile\\\" - Delete Version Object: $sResult\"
                                    if {$bSpinnerAgent} {
                                       set iLogFileErr [open $sLogFileError a+]
                                 	     puts $iLogFileErr \"\\\"$sType\\\" \\\"$sName\\\" \\\"$sRev\\\" file \\\"$sFile\\\" - Delete Version Object: $sResult\"
                                 	     close $iLogFileErr
                                    }
                                    set bError TRUE
                                 } else {
                                    set bDel TRUE
                                    puts $iLogFileId \"$sCmd\"
                                    puts $iLogFileId \"# \\\"$sType\\\" \\\"$sName\\\" \\\"$sRev\\\" file \\\"$sFile\\\" - Delete Version Object: $sResult\"
                                 }
                              }
                           }
                        }
                     }
                  }
               } elseif {$bDelete != \"TRUE\"} {
# checkin file
                  if {$sFormat != \"\"} {
                     if {!$bCDMRow} {set sFormat \" format '$sFormat'\"}
                  } else {
                     if {$bCDMRow} {
                        set sFormat \"generic\"
                     } else {
                        set sFormat \" format generic\"
                     }
                  }
                  set sAppend \" append\"
                  if {$bReplace} {set sAppend \"\"}
# CDM Format 1/21/2007 MJO
                  if {$bCDMRow} {            
                     set sCmd \"mql exec prog emxCommonDocument -method checkinBus $oID \\042$sDirectory\\042 \\042$sFile\\042 \\042$sFormat\\042 \\042$sStore\\042 false server 'File: $sFile checked into: $sType $sName $sRev'\\;\"
                  } else {
                     set sCmd \"mql checkin bus \\\"$sType\\\" \\\"$sName\\\" \\\"$sRev\\\"$sFormat$sAppend \\\"$sChkPath\\\"\"
                  }
                  set bTrigOn FALSE
                  if {$bTrigOver == \"ON\" || ($bTriggerChk == \"ON\" && $bTrigOver != \"OFF\")} {
                  	mql trigger on
                  	set bTrigOn TRUE
                  }
                  if {$bScan} {
                     puts $iLogFileId $sCmd
                  } elseif {[catch {eval $sCmd} sResult] != 0} {
                     puts $iLogFileId \"$sCmd\"
                     puts $iLogFileId \"\\n\\\"$sType\\\" \\\"$sName\\\" \\\"$sRev\\\" file \\\"$sChkPath\\\": $sResult - triggers $sTrig\\$sCDMAppend\"
                     if {$bSpinnerAgent} {
                        set iLogFileErr [open $sLogFileError a+]
			  puts $iLogFileErr \"\\\"$sType\\\" \\\"$sName\\\" \\\"$sRev\\\" file \\\"$sChkPath\\\": $sResult - triggers $sTrig\\$sCDMAppend\"
                     	  close $iLogFileErr
                     }
                     set bError TRUE
                  } else {
                     puts $iLogFileId \"$sCmd\"
                     puts $iLogFileId \"# \\\"$sType\\\" \\\"$sName\\\" \\\"$sRev\\\" file '$sFile' checked in - triggers $sTrig\\$sCDMAppend\"
                     set bMod TRUE
                  }
                  if {$bTrigOn} {mql trigger off}
               }
# write cue
               if {$bError} {
               	  if {$bScan != \"TRUE\"} {mql abort transaction}
                  if {$bPercent == \"FALSE\"} {puts -nonewline \"!\"}
                  incr iErrTot
               } elseif {$bMod} {
                  if {$bScan != \"TRUE\"} {mql commit transaction}
                  if {$bPercent == \"FALSE\"} {puts -nonewline \":\"}
                  incr iModTotal
               } elseif {$bDel} {
                  if {$bScan != \"TRUE\"} {mql commit transaction}
                  if {$bPercent == \"FALSE\"} {puts -nonewline \"-\"}
                  incr iDelTotal
               } else {
                  if {$bScan != \"TRUE\"} {mql commit transaction}
                  if {$bPercent == \"FALSE\"} {puts -nonewline \".\"}
                  incr iSkipTotal
               }
               if {$bPercent && $iTenPercent < 10 && [expr $iModTotal + $iDelTotal + $iSkipTotal + $iErrTot] > [expr $iTenPercent * $iPercent]} {
                  pWriteCue
                  incr iTenPercent
               } 
            }
         } 
      } 
      if {$bPercent} {pWriteCue}
      pLogFile $iStartTime
      incr iErrTotal $iErrTot
   } 
   close $iLogFileId
   mql set env BUSFILERROR $iErrTotal
   puts \"\"
} 
" 1 0 0 0 0 0 0 0 0 0 0 0 "" 0 0
 0 1
 SpinnerAgent NULL noname "3/27/2017 3:41:29 PM" 0
"12/6/2015 11:42:58 PM" "3/14/2018 3:57:25 PM"
7
 0 1 "12/6/2015 11:42:58 PM" creator "add program emxSpinnerBusFiles.tcl mql execute immediate !needsbusinessobject !downloadable !pipe !pooled nothidden file ./Business/SourceFiles/emxSpinnerBusFiles.tcl"
 0 2 "12/6/2015 11:42:58 PM" creator "add property SpinnerAgent on program emxSpinnerBusFiles.tcl value '12/6/2015 11:42:58 PM'"
 0 2 "12/6/2015 11:42:58 PM" creator "mod program emxSpinnerBusFiles.tcl description ''"
 0 2 "2/3/2016 5:21:01 PM" creator "mod property SpinnerAgent on program emxSpinnerBusFiles.tcl value '2/3/2016 5:21:01 PM'"
 0 2 "2/3/2016 5:21:01 PM" creator "mod program emxSpinnerBusFiles.tcl file ./Business/SourceFiles/emxSpinnerBusFiles.tcl"
 0 2 "3/27/2017 3:41:29 PM" creator "mod property SpinnerAgent on program emxSpinnerBusFiles.tcl value '3/27/2017 3:41:29 PM'"
 0 2 "3/27/2017 3:41:29 PM" creator "mod program emxSpinnerBusFiles.tcl file ./Business/SourceFiles/emxSpinnerBusFiles.tcl"

!MTRX!END

!MTRX!AD! program emxSpinnerBusGrants.tcl "3DEXPERIENCE R2015x(24.0.0.0)"
emxSpinnerBusGrants.tcl 0 "" "#*******************************************************************************10.59
# @progdoc        emxSpinnerBusGrants.tcl vM10.59 (Build 5.9.26)
#
# @Brief:         Add Bus Object Grants
#
# @Description:   Add Bus Object Grants
#                 Multiple headers for merging different types may be used using <HEADER> as last field.
#                 The file format has to be followed as shown below:
#
#                 Type(^t)Name(^t)Rev(^t)Grantor(^t)Grantee(^t)Read(^t)Modify(^t)Delete(^t)Checkout(^t)Checkin(^t)Schedule(^t)Lock(^t)Unlock(^t)Execute(^t)Freeze(^t)Thaw(^t)Create(^t)Revise(^t)Promote(^t)Demote(^t)Grant(^t)Enable(^t)Disable(^t)Override(^t)ChangeName(^t)ChangeType(^t)ChangeOwner(^t)ChangePolicy(^t)Revoke(^t)ChangeVault(^t)FromConnect(^t)ToConnect(^t)FromDisconnect(^t)ToDisconnect(^t)ViewForm(^t)Modifyform(^t)Show(^t)Signature(^t)Key
#                 Type(^t)Name(^t)Rev(^t)ChangeName(^t)ChangeRev(^t)Policy(^t)State(^t)Vault(^t)Owner(^t)description(^t)'Attribute 1'(^t)'Attribute N'(^t)[see note l](^t)[see note m](^t)[see note n](^t)[see note o]
#                    where (^t) is a tab
#
# @Parameters:    none
#
# @Returns:       Nothing   
#
# @Usage:         Can be used for legacy load into production
#
# @progdoc        Copyright (c) 2005, MatrixOne
#*******************************************************************************
# @Modifications:
#
# Matt Osterman 9/22/2005 - Initial Code
#
#*******************************************************************************

tcl;

eval {
   if {[info host] == \"mostermant43\" } {
      source \"c:/Program Files/TclPro1.3/win32-ix86/bin/prodebug.tcl\"
      set cmd \"debugger_eval\"
      set xxx [debugger_init]
   } else {
      set cmd \"eval\"
   }
}
$cmd {

   set sAllFiles [mql get env BUSGRANTLIST]

#  ********************** USER DEFINED VARIABLES*******************************
#  ****************************************************************************

   set sDate1 [clock format [clock seconds] -format %Y%m%d]
   set iStartTime  [clock seconds]
   set iErrTotal      0
   set bError     FALSE
   
# Scan Mode
   set bScan [mql get env SPINNERSCANMODE]
   if {$bScan != \"TRUE\"} {set bScan FALSE}
   if {$bScan} {set sDate1 \"SCAN\"}

   global iLogFileId 
   global iErrTot iAddTotal iDelTotal
   
##  this is to set the path
   if {$sAllFiles == \"\"} {set sAllFiles [ glob -nocomplain \"./Objects/Grants/*.xls\" ]}
   if {$sAllFiles == \"./Objects/Grants/0\"} {set sAllFiles \"\"}
   if {$sAllFiles == \"\"} {
      puts -nonewline \"\\n*** No data files of format 'grant_\\[bus object name\\].xls' found ***\"
   }
   
#***************************************************************************
# Procedure:   pLogFile
# Description: Used after all records have been processed. Write time of execution and 
#              Totals of load to files.
# Parameters:  none.
# Returns:  none.
#***************************************************************************
   proc pLogFile { iStartTime } {
   
      global iLogFileId
      global iErrTot iAddTotal iDelTotal sAllFiles sCurFile
      
      set iEndTime  [clock seconds]
      incr iEndTime -$iStartTime
      set iMin  [expr $iEndTime / 60]
      set iSec  [expr $iEndTime - ($iMin * 60 )]
      set iHour [expr $iMin / 60 ]
      set iMin  [expr $iMin - ($iHour * 60 )]
      set iDay  [expr $iHour / 24 ]
      set iHour [expr $iHour - ($iDay * 24 )]
      set iSec  [format \"%0.2i\" $iSec]
      set iMin  [format \"%0.2i\" $iMin]
      
      if {$iAddTotal > 0} {puts $iLogFileId \"#     Number of Grants added:         $iAddTotal\"}
      if {$iDelTotal > 0} {puts $iLogFileId \"#     Number of Grants deleted:        $iDelTotal\"}
      if {$iErrTot > 0} {puts $iLogFileId \"#     Number of Errors:                  $iErrTot\"}
      if {[expr $iAddTotal + $iDelTotal + $iErrTot] > 0} {puts $iLogFileId \"#     Total time for load:               $iDay $iHour:$iMin:$iSec\"}
      if {[lsearch $sAllFiles $sCurFile] == [expr [llength $sAllFiles] - 1]} {puts $iLogFileId \"\"}
   }

# Procedure to write screen cue
   proc pWriteCue {} {
      global iAddTotal iDelTotal iSkipTotal iErrTot iTenPercent iPrevAddModDel iPrevError
      set iAddModDel [expr $iAddTotal + $iDelTotal - $iPrevAddModDel]
      set iError [expr $iErrTot - $iPrevError]
      set iPrevAddModDel [expr $iAddTotal + $iDelTotal]
      set iPrevError $iErrTot
      set sWrite \"...\"
      if {$iAddModDel && $iError} {
         set sWrite \"  \\($iAddModDel\\: $iError\\!\\)\"
      } elseif {$iAddModDel} {
         set sWrite \"  \\($iAddModDel\\:\\)\"
      } elseif {$iError} {
         set sWrite \"  \\($iError\\!\\)\"
      }
      puts -nonewline \"$sWrite[expr $iTenPercent * 10]%\"
   }

#main
   mql verbose on
   mql trigger off
   file mkdir \"./logs\"
   if {[mql get env SPINNERLOGFILE] != \"\"} {
      set sLogFilePath [mql get env SPINNERLOGFILE]
      set sLogFileError [mql get env SPINNERERRORLOG]
      set bSpinnerAgent TRUE
   } else {    
      set sLogFilePath \"./logs/BusGrants\\.$sDate1.log\"
      set bSpinnerAgent FALSE
   }
   set iLogFileId    [open $sLogFilePath a+]
   
   set lsAccessModes [ list read modify delete checkout checkin schedule lock \\
        unlock execute freeze thaw create revise promote demote grant enable \\
        disable override changename changetype changeowner changepolicy revoke \\
        changevault fromconnect toconnect fromdisconnect todisconnect \\
        viewform modifyform show ]
   set sHeader \"Type\\tName\\tRevision\\tGrantor\\tGrantee\\tRead\\tModify\\tDelete\\tCheckout\\tCheckin\\tSchedule\\tLock\\tUnlock\\tExecute\\tFreeze\\tThaw\\tCreate\\tRevise\\tPromote\\tDemote\\tGrant\\tEnable\\tDisable\\tOverride\\tChangeName\\tChangeType\\tChangeOwner\\tChangePolicy\\tRevoke\\tChangeVault\\tFromConnect\\tToConnect\\tFromDisconnect\\tToDisconnect\\tViewForm\\tModifyform\\tShow\\tSignature\\tKey\\n\"

   foreach sCurFile $sAllFiles {
      set iFileId    [open $sCurFile r]
      puts $iLogFileId \"\\n# \\[[clock format [clock seconds] -format %H:%M:%S]\\] File: '[file tail $sCurFile]'\"
      puts -nonewline \"\\nLoading bus objects from file '[file tail $sCurFile]'\"
      
      set iErrTot        0
      set iAddTotal      0 
      set iDelTotal      0 
      set iHeader        0
      set iSkipTotal     0
      set iPrevAddModDel 0
      set iPrevError     0
      set bPercent   FALSE
      set iTenPercent    1

# READ FILES AND PROCESS RECORDS. 

      set lsFile [split [read $iFileId] \\n]
      close $iFileId
      if {[llength $lsFile] > 50} {
         set iPercent [expr [llength $lsFile] / 10]
         set bPercent TRUE
      }
      foreach sLine $lsFile {
      	 set bAdd FALSE
      	 set bDel FALSE
      	 set bError FALSE
         set sLine [string trim $sLine]
         set lsLine [split $sLine \\t]
         if {[string first \"<HEADER>\" $sLine] >= 0} {
            set iHeader 0
         }         
         if { $iHeader == 0 } {
            incr iHeader
         } elseif {$sLine != \"\"} {
            set sType           [ string trim [ lindex $lsLine 0 ] ]
            set sName           [ string trim [ lindex $lsLine 1 ] ]
            set sRev            [ string trim [ lindex $lsLine 2 ] ]
            set sGrantor        [ string trim [ lindex $lsLine 3 ] ]
            set sGrantee        [ string trim [ lindex $lsLine 4 ] ]
            set bSignature      [string toupper [ string trim [ lindex $lsLine 37 ] ] ]
            set sKey            [ string trim [ lindex $lsLine 38 ] ]
            
# flag for revoke if fields after T N R are blank and set variables
            set bRevoke TRUE
            set sAccess \"\"
            set lsAccess \"\"
            for {set i 3} {$i < 39} {incr i} {
               if {[lindex $lsLine $i] != \"\"} {
                  set bRevoke FALSE
               } 
               if {$i > 4 && $i < 38 && [string tolower [lindex $lsLine $i]] == \"y\"} {
               	  set j [expr $i - 5]
               	  lappend lsAccess [lindex $lsAccessModes $j]
               }
               set sAccess [join $lsAccess ,]
            }
            if {$bSignature != \"TRUE\"} {
               set bSignature \"FALSE\"
            }
# Check Existence of Bus Object
            if {$bScan != \"TRUE\"} {mql start transaction update}               
            set iErr  [ catch { mql print bus \"$sType\" \"$sName\" \"$sRev\" select exists dump } sResult ]   
            if {$iErr != 0 || $sResult != \"TRUE\"} {
               puts $iLogFileId \"# ERROR: Bus Object \\\"$sType\\\" \\\"$sName\\\" \\\"$sRev\\\": does not exist\"
               if {$bSpinnerAgent} {
                  set iLogFileErr [open $sLogFileError a+]
                  puts $iLogFileErr \"ERROR: Bus Object \\\"$sType\\\" \\\"$sName\\\" \\\"$sRev\\\": does not exist\"
                  close $iLogFileErr
               }
               set bError TRUE
            } else {
               if {[catch {
                  if {$bMatch(\"$sType|$sName|$sRev\")} {
                     set bRevokeFirst FALSE
                  }
               } sMsg] != 0} {
                  set bMatch(\"$sType|$sName|$sRev\") TRUE
                  set bRevokeFirst TRUE
               }
               if {$bRevoke || $bRevokeFirst} {
                  if {[mql print bus \"$sType\" \"$sName\" \"$sRev\" select granteeaccess dump |] != \"\"} {
                     set sCmd  \"mql mod bus \\\"$sType\\\" \\\"$sName\\\" \\\"$sRev\\\" revoke all\"
                     if {$bScan} {
                        puts $iLogFileId $sCmd
                     } elseif {[catch {eval $sCmd} sResult] != 0} {
                        puts $iLogFileId \"$sCmd\"
                        puts $iLogFileId \"# ERROR: Bus Object \\\"$sType\\\" \\\"$sName\\\" \\\"$sRev\\\": $sResult\"
                        if {$bSpinnerAgent} {
                           set iLogFileErr [open $sLogFileError a+]
                           puts $iLogFileErr \"ERROR: Bus Object \\\"$sType\\\" \\\"$sName\\\" \\\"$sRev\\\": $sResult\"
                           close $iLogFileErr
                        }
                        set bError TRUE
                     } else {
                        puts $iLogFileId \"$sCmd\"
                        puts $iLogFileId \"# \\\"$sType\\\" \\\"$sName\\\" \\\"$sRev\\\": $sResult\"
                        if {$bRevoke} {set bDel TRUE}
                     }
                  }
               }
               if {$bRevoke != \"TRUE\" && $bError != \"TRUE\"} {
# Check Grantor
# Changed the code fro list person to list user to fix the incident 339262 in line 239 and 250
                  if {[mql list user $sGrantor] == \"\"} {
                     puts $iLogFileId \"# ERROR: Grantor '$sGrantor' on Bus Object \\\"$sType\\\" \\\"$sName\\\" \\\"$sRev\\\" not valid\"
                     if {$bSpinnerAgent} {
                        set iLogFileErr [open $sLogFileError a+]
                        puts $iLogFileErr \"ERROR: Grantor '$sGrantor' on Bus Object \\\"$sType\\\" \\\"$sName\\\" \\\"$sRev\\\" not valid\"
                        close $iLogFileErr
                     }
                     set bError TRUE
                  }
# Check Grantee
                  if {$bError != \"TRUE\"} {
                     if {[mql list user $sGrantee] == \"\"} {
                        puts $iLogFileId \"# ERROR: Grantee '$sGrantee' on Bus Object \\\"$sType\\\" \\\"$sName\\\" \\\"$sRev\\\" not valid\"
                        if {$bSpinnerAgent} {
                           set iLogFileErr [open $sLogFileError a+]
                           puts $iLogFileErr \"ERROR: Grantee '$sGrantee' on Bus Object \\\"$sType\\\" \\\"$sName\\\" \\\"$sRev\\\" not valid\"
                           close $iLogFileErr
                        }
                        set bError TRUE
                     }
                  }
# Push Context to Grantor and Add Access
                  if {$bError != \"TRUE\"} {
                     mql push context user $sGrantor
                     set sCmd  \"mql mod businessobject \\\"$sType\\\" \\\"$sName\\\" \\\"$sRev\\\" grant \\\"$sGrantee\\\" access \\\"$sAccess\\\" signature \\\"$bSignature\\\" key \\\"$sKey\\\"\"
                     if {$bScan} {
                        puts $iLogFileId $sCmd
                     } elseif {[catch {eval $sCmd} sResult] != 0} {
                        puts $iLogFileId \"$sCmd\"
                        puts $iLogFileId \"# ERROR: \\\"$sType\\\" \\\"$sName\\\" \\\"$sRev\\\": $sResult\"
                        if {$bSpinnerAgent} {
                           set iLogFileErr [open $sLogFileError a+]
                           puts $iLogFileErr \"ERROR: \\\"$sType\\\" \\\"$sName\\\" \\\"$sRev\\\": $sResult\"
                           close $iLogFileErr
                        }
                        set bError TRUE
                     } else {
                        set bAdd TRUE
                        puts $iLogFileId \"$sCmd\"
                        puts $iLogFileId \"# \\\"$sType\\\" \\\"$sName\\\" \\\"$sRev\\\": $sResult\"
                     }
                     mql pop context
                  }
               }
            }
# write cue
            if {$bError} {
               if {$bScan != \"TRUE\"} {mql abort transaction}
               if {$bPercent == \"FALSE\"} {puts -nonewline \"!\"}
               incr iErrTot
            } elseif {$bAdd} {
               if {$bScan != \"TRUE\"} {mql commit transaction}
               incr iAddTotal
               if {$bPercent == \"FALSE\"} {puts -nonewline \"+\"}
            } elseif {$bDel} {
               if {$bScan != \"TRUE\"} {mql commit transaction}
               if {$bPercent == \"FALSE\"} {puts -nonewline \"-\"}
               incr iDelTotal
            } else {
               if {$bScan != \"TRUE\"} {mql commit transaction}
               if {$bPercent == \"FALSE\"} {puts -nonewline \".\"}
               incr iSkipTotal
            }
            if {$bPercent && $iTenPercent < 10 && [expr $iAddTotal + $iDelTotal + $iSkipTotal + $iErrTot] > [expr $iTenPercent * $iPercent]} {
               pWriteCue
               incr iTenPercent
            }
         } 
         #  end of if
      } 
      ## end while for reading file
      if {$bPercent} {pWriteCue}
      pLogFile $iStartTime
      incr iErrTotal $iErrTot
   } 
   # end of forloop 
   close $iLogFileId
   mql set env BUSGRANTERROR $iErrTotal
   puts \"\"
} 
# end program
" 1 0 0 0 0 0 0 0 0 0 0 0 "" 0 0
 0 1
 SpinnerAgent NULL noname "3/27/2017 3:41:29 PM" 0
"12/6/2015 11:42:58 PM" "3/14/2018 3:57:25 PM"
7
 0 1 "12/6/2015 11:42:58 PM" creator "add program emxSpinnerBusGrants.tcl mql execute immediate !needsbusinessobject !downloadable !pipe !pooled nothidden file ./Business/SourceFiles/emxSpinnerBusGrants.tcl"
 0 2 "12/6/2015 11:42:58 PM" creator "add property SpinnerAgent on program emxSpinnerBusGrants.tcl value '12/6/2015 11:42:58 PM'"
 0 2 "12/6/2015 11:42:58 PM" creator "mod program emxSpinnerBusGrants.tcl description ''"
 0 2 "2/3/2016 5:21:01 PM" creator "mod property SpinnerAgent on program emxSpinnerBusGrants.tcl value '2/3/2016 5:21:01 PM'"
 0 2 "2/3/2016 5:21:01 PM" creator "mod program emxSpinnerBusGrants.tcl file ./Business/SourceFiles/emxSpinnerBusGrants.tcl"
 0 2 "3/27/2017 3:41:29 PM" creator "mod property SpinnerAgent on program emxSpinnerBusGrants.tcl value '3/27/2017 3:41:29 PM'"
 0 2 "3/27/2017 3:41:29 PM" creator "mod program emxSpinnerBusGrants.tcl file ./Business/SourceFiles/emxSpinnerBusGrants.tcl"

!MTRX!END

!MTRX!AD! program emxSpinnerSystem.tcl "3DEXPERIENCE R2015x(24.0.0.0)"
emxSpinnerSystem.tcl 0 "" "#####################################################################*10.62
#
# @progdoc      emxSpinnerSystem.tcl vM10.62 (Build 7.1.23)
#
# @Description: This is schema spinner that adds system schema.
#               Invoked from program
#               'emxSpinnerSystem.tcl'.
#
# @Parameters:  None
#
# @Usage:       Run this program for an MQL command window w/data files in directories:
#               . (current dir)         emxSpinnerAgent.tcl, emxSpinnerAccess.tcl programs
#
# @progdoc      Copyright (c) MatrixOne Inc., June 26, 2002
#
#########################################################################
#
# @Modifications: Greg Inglis 2004-02-09 - first version.
# @Modifications: Matt Osterman 2007-01-18 - fully functional for vault, store,
#               location, site, server, index w/modify, delete and registration
#
#########################################################################
tcl;

eval {
   if {[info host] == \"mostermant43\" } {
      source \"c:/Program Files/TclPro1.3/win32-ix86/bin/prodebug.tcl\"
      set cmd \"debugger_eval\"
      set xxx [debugger_init]
   } else {
      set cmd \"eval\"
   }
}
$cmd {

#************************************************************************
# Procedure:   pfile_write
#
# Description: Procedure to write a variable to file.
#
# Parameters:  The filename to write to,
#              The data variable.
#
# Returns:     Nothing
#************************************************************************

proc pfile_write { filename data } {
  return  [catch {
    set fileid [open $filename \"a+\"]
    puts $fileid $data
    close $fileid
  }]
}
#End pfile_write


#************************************************************************
# Procedure:   pfile_read
#
# Description: Procedure to read a file.
#
# Parameters:  The filename to read from.
#
# Returns:     The file data
#************************************************************************

proc pfile_read { sFile } {

  set data \"\"
  if { [file readable $sFile] } {
    set fd [open $sFile r]
    set data [read $fd]
    close $fd
  }
  return $data
}
#End file_read


proc pProcessFile { sFileName sDelimit } {

    set lFileData [ list ]
    set sFileData [ split [ pfile_read $sFileName ] \\n ]
    set sHeaderRaw [split [lindex $sFileData 0] $sDelimit ]

    set sHeader [ list ]
    foreach i $sHeaderRaw {
        lappend sHeader [ string trim $i ]
    }
    lappend lFileData $sHeader
    set sData [ lrange $sFileData 1 end ]
    foreach sDataLine $sData {
        set sDataLine [ split $sDataLine $sDelimit ]
        if {$sDataLine != \"\"} {
            lappend lFileData $sDataLine
        }
    }
    return $lFileData
}
# End pIncludeFile


#main

    set bScan [mql get env SPINNERSCANMODE]; #scan mode and log suffix - SpinnerAgent
    if {$bScan != \"TRUE\"} {set bScan FALSE}
    set sSuffix [clock format [clock seconds] -format \".%m%d%y\"]
    if {$bScan} {set sSuffix \".SCAN\"}

    set sDelimit \"\\t\"
    set lSystemTypeNames [ list ]
    if {[mql get env SPINNERLOGFILE] != \"\"} {; # SpinnerAgent
       set sLogFile [mql get env SPINNERLOGFILE]
       set sLogFileError [mql get env SPINNERERRORLOG]
       set bSpinnerAgent TRUE
    } else {    
       set sLogFile [file join . logs System$sSuffix.log]
       set bSpinnerAgent FALSE
    }
    set iSystemError 0; # SpinnerAgent

    set lSystemInfo [ list {location location.xls} {site site.xls} \\
        {store store_captured.xls} {store store_ingested.xls} {store store_tracked.xls} \\
        {server server.xls} \\
        {vault vault_local.xls} {vault vault_remote.xls} {vault vault_foreign.xls} \\
        {index index.xls} ]
    if {[mql list program eServiceSchemaVariableMapping.tcl] == \"\"} {
       set bRegistry FALSE
    } else {
       set bRegistry TRUE
       set lsRegistry [split [mql print program eServiceSchemaVariableMapping.tcl select property dump |] |]
       array set aRegistry [list store store vault lattice location location site site server server index index]
    }
    puts \"\"
    
    foreach lSystem $lSystemInfo {
        set sSystemType [lindex $lSystem 0]
        set sSystemFileName [lindex $lSystem 1]
            
        set sSpinDir \"\"
        if {$bSpinnerAgent} {
           set sSpinDir [mql get env SPINNERPATH]
        }
        if {$sSpinDir != \"\" && $sSpinDir != \".\"} {
              set sFile [file join \"$sSpinDir\\/System\" $sSystemFileName]
        } else {
              set sFile [file join System $sSystemFileName]
        }

        if {[file exists $sFile] == 1} {
           puts \"Process $sSystemType\\(s\\) from file '$sSystemFileName':\"
           pfile_write $sLogFile \"# \\[[clock format [clock seconds] -format %H:%M:%S]\\] $sSystemType\\(s\\) from file '$sSystemFileName':\\n\"
           set lFileData [pProcessFile $sFile $sDelimit]
       
           set lHeader [lindex $lFileData 0]
           set lData [lrange $lFileData 1 end]
   
           set sCmd \"mql list $sSystemType\"
           if {[catch {eval $sCmd} sMsg] == 0} {
               set sRtn $sMsg
           } else {
               set sCmt \"An error occurred. The mql cmd is\\n$sCmd\\nError message is\\n$sMsg\\n\"
               puts $sCmt
               pfile_write $sLogFile $sCmt
               if {$bSpinnerAgent} {
                  set iLogFileErr [open $sLogFileError a+]
                  puts $iLogFileErr $sCmt
                  close $iLogFileErr
               }
               incr iSystemError; #SpinnerAgent
           }
           
           if {$sRtn == \"\"} {
               pfile_write $sLogFile \"# No System type '$sSystemType for file '$sSystemFileName' exist\"
           } else {
               set lSystemTypeNames [split $sRtn \\n]
           }
   
           foreach lLineData $lData {
               set bAdd FALSE
               set bMod FALSE
               set bModAppend FALSE
               set bDel FALSE
               set sCmd \"\"
               set sName [lindex $lHeader 0]
               set sNameValue [string trim [lindex $lLineData 0] \\\"]
               if {$sNameValue == \"\"} {continue}
               if {[string first \"<<\" $sNameValue] == 0 && [string first \">>\" $sNameValue] == [expr [string length $sNameValue] -2]} {
                   regsub \"<<\" $sNameValue \"\" sNameValue
                   regsub \">>\" $sNameValue \"\" sNameValue
                   set sNameValue [string trim $sNameValue]
                   set bDel TRUE
               }
   # Analyze Registration 1/18/2007 MJO     
               set bReg FALSE
               set bUnReg FALSE
               set bRename FALSE
               if {!$bDel} {
                   set lUnRegProp {}
                   set lUnRegTo {}
                   set sRegName [string trim [lindex $lLineData 1] \\\"]
                   if {$sRegName != \"\" && $bRegistry} {
                       if {[string tolower $sRegName] == \"<null>\"} {set sRegName \"\"}
                       set sSymbolicFromName \"\"
                       set iReg [lsearch -regexp $lsRegistry \"to $aRegistry($sSystemType) $sNameValue\"]
                       if {$iReg >= 0} {
                           set sSymbolicFromName [lindex [split [lindex $lsRegistry $iReg] \" \"] 0]
                       }
        
                       if {$sRegName == \"\"} {
                          if {$sSymbolicFromName != \"\"} {
                              set bUnReg TRUE
                              lappend lUnRegProp $sSymbolicFromName
                              lappend lUnRegTo $sNameValue
                          }
                       } else {
                           set sSymbolicFromRegName \"$sSystemType\\_$sRegName\"
                           regsub -all \" \" $sSymbolicFromRegName \"\" sSymbolicFromRegName
                           set sNameFromRegName [mql print program eServiceSchemaVariableMapping.tcl select property\\[$sSymbolicFromRegName\\].to dump]
                           if {$sNameFromRegName != \"\"} {
                               regsub $aRegistry($sSystemType) $sNameFromRegName \"\" sNameFromRegName
                               set sNameFromRegName [string trim $sNameFromRegName]
                           }
                           if {$sSymbolicFromName == \"\" && $sNameFromRegName != \"\" && $sNameValue != $sNameFromRegName} {
                               set bRename TRUE
                               set sNewName $sNameValue
                               set sNameValue $sNameFromRegName
                           } else {
                               if {$sSymbolicFromName == \"\" || $sNameFromRegName == \"\" || $sNameValue != $sNameFromRegName || $sSymbolicFromName != $sSymbolicFromRegName} {
                                   set bReg TRUE
                               }
                               if {$sNameFromRegName != \"\" && $sNameValue != $sNameFromRegName} {
                                   set bUnReg TRUE
                                   lappend lUnRegProp $sSymbolicFromRegName
                                   lappend lUnRegTo $sNameFromRegName
                               }
                               if {$sSymbolicFromName != \"\" && $sSymbolicFromName != $sSymbolicFromRegName} { 
                                   set bUnReg TRUE
                                   lappend lUnRegProp $sSymbolicFromName
                                   lappend lUnRegTo $sNameValue
                               }
                           }
                       }
                   }
               }
   # End Analyze Registration
               set sExists [lsearch $lSystemTypeNames $sNameValue]
               set sCmt \"     $sNameValue\"
               puts -nonewline $sCmt
               if {$sExists == -1 && !$bDel} {
                   set bAdd TRUE
                   set sCmd \"mql add $sSystemType \\042$sNameValue\\042\"
               } elseif {$bDel} {
                   set sCmd \"mql delete $sSystemType \\042$sNameValue\\042\"
               } else {
                   set bMod TRUE
                   set sCmd \"mql mod $sSystemType \\042$sNameValue\\042\"
                   if {$bRename} {append sCmd \" name \\042$sNewName\\042\"}
               }
               if {!$bDel} {
                   foreach i $lHeader j $lLineData {
                       set j [string trim $j \\\"]
                       if {$i == \"path\" || $i == \"file\"} {
                           # replace all double backslash with a forward slash, all singles with forward
                           regsub -all -- {\\134\\134} $j {/} j
                           regsub -all -- {\\134} $j {/} j
                       }
                       if { $i == \"name\" || $i == \"Registry Name\"} {
                           # do not process the registry name (a future)
                           continue
                       } elseif {$bMod && $i == \"type\"} {
                           # skip as type is set on add only
                           pfile_write $sLogFile \"# WARNING: Skipping modification to 'type' as not allowed.\"
                           continue
                       } elseif {$bMod && ($i == \"indexspace\" || $i == \"tablespace\" || $i == \"server\" || $i == \"interface\")} {
                           # skip as items are set on add only
                           pfile_write $sLogFile \"# WARNING: Skipping modification to '$i' as not allowed.\"
                           continue
                       } elseif {$i == \"location\" && $j != \"\"} {
                           set lLoc [split $j |]
                           set sLocData \"\"
                           foreach sLoc $lLoc {
                               set sLoc [string trim $sLoc ]
                               if {[string first \"<<\" $sLoc] == 0 && [string first \">>\" $sLoc] == [expr [string length $sLoc] -2]} {
                                   if {$bMod} {
                                       regsub \"<<\" $sLoc \"\" sLoc
                                       regsub \">>\" $sLoc \"\" sLoc
                                       set sLoc [string trim $sLoc]
                                       if {[mql list location \\042$sLoc\\042] != \"\"} {append sLocData \"remove location \\042$sLoc\\042 \"}
                                    }
                               } else {
                                  append sLocData \"add location \\042$sLoc\\042 \"
                               }
                           }
                           if {$sLocData != \"\"} {
                               if {$bAdd} {
                                   set bModAppend TRUE
                                   set sModName $sNameValue
                                   if {$bRename} {set sModName $sNewName}
                                   set sModAppend \"mql mod $sSystemType \\042$sModName\\042 $sLocData\"
                               } elseif {$bMod} {
                                   append sCmd \" $sLocData\"
                               }
                           }
                       } elseif {$i == \"attribute\" && $j != \"\"} {
                           set lAttr [split $j |]
                           set lAttrData {}
                           set sAttrData \"\"
                           foreach sAttr $lAttr {
                               set sAttr [string trim $sAttr]
                               if {[string first \"<<\" $sAttr] == 0 && [string first \">>\" $sAttr] == [expr [string length $sAttr] -2]} {
                                   if {$bMod} {
                                       regsub \"<<\" $sAttr \"\" sAttr
                                       regsub \">>\" $sAttr \"\" sAttr
                                       set sAttr [string trim $sAttr]
                                       if {[mql list attribute \\042$sAttr\\042] != \"\"} {append sAttrData \"remove attribute \\042$sAttr\\042 \"}
                                    }
                               } else {
                                   if {$bAdd} {
				        #Commented below line to fix 355056 on 12 june 08
					#lappend lAttrData $sAttr
					#Added below to fix 355056  on 12 june 08 - start
					set tempAttrName '
					append tempAttrName $sAttr
					append tempAttrName '
                                        lappend lAttrData $tempAttrName
					#Added to fix 355056  on 12 june 08 - end
                                    } elseif {$bMod} {
                                       set lsAttr [split [mql print $sSystemType \"$sNameValue\" select attribute dump |] |]
                                       if {[lsearch $lsAttr $sAttr] < 0} {
                                           append sAttrData \"add attribute \\042$sAttr\\042 \"
                                       }
                                   }
                               }
                           }
                           if {$bAdd} {
                               if {[llength $lAttrData] > 0} {
                                   #Modified below to fix 355056 on 12 june 08 - start
				   append sCmd \" \" \"$i\" \" \" [join $lAttrData ,]
				   #Modified to fix 355056 on 12 june 08 - end
                                }
                           } elseif {$bMod} {
                               if {$sAttrData != \"\"} {
                                   append sCmd \" $sAttrData\"
                               }
                           }
                       } elseif {$i == \"enable\" && $j != \"\"} {
                           set bModAppend TRUE
                           set sModName $sNameValue
                           if {$bRename} {set sModName $sNewName}
                           if {[string tolower $j] != \"true\" && [string tolower $j] != \"$i\"} {
                              set sModAppend \"mql disable index \\042$sModName\\042\"
                           } else {
                              set sModAppend \"mql enable index \\042$sModName\\042\"
                           }
                       } elseif { $i == \"hidden\" || $i == \"multipledirectories\" || $i == \"unique\" || $i == \"foreign\" || $i == \"lock\"} {
                           if {$j != \"\"} {
                               if {[string tolower $j] != \"true\" && [string tolower $j] != \"$i\"} {
                                   if {$i == \"lock\"} {
                                       set j \"unlock\"
                                   } else {
                                       set j \"not$i\"
                                   }
                               } else {
                                   set j $i
                               }
                               append sCmd \" $j\"
                           }
                       } elseif { $j != \"\" } {
                           if {[string tolower $j] == \"<null>\"} {set j \"\"}
                           if {$i == \"permission\"} {
                               regsub -all -- \"\\134\\174\" $j \",\" j
                               regsub -all -- \" \" $j \"\" j
                           }
                           append sCmd \" \" \"$i\" \" \" \"\\\"$j\\\"\"
                       }
                   }
               }
   # Process Command
               pfile_write $sLogFile $sCmd
               set bErr FALSE
               if {$bScan != \"TRUE\"} {;#spinneragent
                   if {$sCmd == \"\"} {
                       puts \" (SKIP)\"
                       pfile_write $sLogFile \"# Command return is: SKIP\"
                   } elseif {[catch {eval $sCmd} sMsg] == 0} {
                       if {!$bModAppend} {
                           puts \" (SUCCESS)\"
                           pfile_write $sLogFile \"# Command return is: SUCCESS\"
                       }
                   } else {
                       puts \" (ERROR)\"
                       pfile_write $sLogFile \"Command return is: ERROR, message is:\\n$sMsg\"
                       if {$bSpinnerAgent} {
                          set iLogFileErr [open $sLogFileError a+]
                          puts $iLogFileErr \"MQL command:\\n$sCmd\\nError message is:\\n$sMsg\"
                          close $iLogFileErr
                       }
                       incr iSystemError; #SpinnerAgent
                       set bErr TRUE
                   }
               }
   # Post Process Command
               if {$bModAppend} {
                   pfile_write $sLogFile \"$sModAppend\"
                   if {$bScan != \"TRUE\"} {; #Spinneragent
                       if {[catch {eval $sModAppend} sMsg] == 0} {
                           puts \" (SUCCESS)\"
                           pfile_write $sLogFile \"# Command return is: SUCCESS\"
                       } else {
                           if {!$bErr} {
                               puts \" (ERROR)\"
                               incr iSystemError; #SpinnerAgent
                           }
                           pfile_write $sLogFile \"Command return is: ERROR, message is:\\n$sMsg\"
                           if {$bSpinnerAgent} {
                              set iLogFileErr [open $sLogFileError a+]
                              puts $iLogFileErr \"MQL command:\\n$sModAppend\\nError message is:\\n$sMsg\"
                              close $iLogFileErr
                           }
                       }
                   }
               }
   # Process Registration 1/18/2007 MJO
               if {$bUnReg} {
                   foreach sUnRegProp $lUnRegProp sUnRegTo $lUnRegTo {
                       set sCmd \"mql delete property $sUnRegProp on program eServiceSchemaVariableMapping.tcl to $aRegistry($sSystemType) \\042$sUnRegTo\\042\"
                       pfile_write $sLogFile \"$sCmd\"
                       if {$bScan != \"TRUE\"} {; #Spinneragent
                           if {[catch {eval $sCmd} sMsg] == 0} {
                               puts \"Unregistration of $aRegistry($sSystemType) \\042$sUnRegTo\\042 (SUCCESS)\"
                               pfile_write $sLogFile \"# Command return is: SUCCESS\"
                               set lsRegistry [split [mql print program eServiceSchemaVariableMapping.tcl select property dump |] |]
                           } else {
                               if {!$bErr} {
                                   puts \"Unregistration of $aRegistry($sSystemType) \\042$sUnRegTo\\042 (ERROR)\"
                                   incr iSystemError; #SpinnerAgent
                               }
                               pfile_write $sLogFile \"Command return is: ERROR, message is:\\n$sMsg\"
                               if {$bSpinnerAgent} {
                                   set iLogFileErr [open $sLogFileError a+]
                                   puts $iLogFileErr \"MQL command:\\n$sCmd\\nError message is:\\n$sMsg\"
                                   close $iLogFileErr
                               }
                           }
                       }
                   }
               }
               if {$bReg} {
                   set sCmd \"mql add property $sSymbolicFromRegName on program eServiceSchemaVariableMapping.tcl to $aRegistry($sSystemType) \\042$sNameValue\\042\"
                   pfile_write $sLogFile \"$sCmd\"
                   if {$bScan != \"TRUE\"} {; #Spinneragent
                       if {[catch {eval $sCmd} sMsg] == 0} {
                           puts \"Registration of $aRegistry($sSystemType) \\042$sNameValue\\042 (SUCCESS)\"
                           pfile_write $sLogFile \"# Command return is: SUCCESS\"
                           set lsRegistry [split [mql print program eServiceSchemaVariableMapping.tcl select property dump |] |]
                       } else {
                           if {!$bErr} {
                               puts \"Registration of $aRegistry($sSystemType) \\042$sNameValue\\042 (ERROR)\"
                               incr iSystemError; #SpinnerAgent
                           }
                           pfile_write $sLogFile \"Command return is: ERROR, message is:\\n$sMsg\"
                           if {$bSpinnerAgent} {
                               set iLogFileErr [open $sLogFileError a+]
                               puts $iLogFileErr \"MQL command:\\n$sCmd\\nError message is:\\n$sMsg\"
                               close $iLogFileErr
                           }
                       }
                   }
               }
   # End Process Registration
           }
        pfile_write $sLogFile \"# End Process $sSystemType\\n\"
        }
    }
    mql set env SYSTEMERROR $iSystemError; #SpinnerAgent
}
" 1 0 0 0 0 0 0 0 0 0 0 0 "" 0 0
 0 1
 SpinnerAgent NULL noname "3/27/2017 3:41:29 PM" 0
"12/6/2015 11:42:58 PM" "3/14/2018 3:57:25 PM"
7
 0 1 "12/6/2015 11:42:58 PM" creator "add program emxSpinnerSystem.tcl mql execute immediate !needsbusinessobject !downloadable !pipe !pooled nothidden file ./Business/SourceFiles/emxSpinnerSystem.tcl"
 0 2 "12/6/2015 11:42:58 PM" creator "add property SpinnerAgent on program emxSpinnerSystem.tcl value '12/6/2015 11:42:58 PM'"
 0 2 "12/6/2015 11:42:58 PM" creator "mod program emxSpinnerSystem.tcl description ''"
 0 2 "2/3/2016 5:21:01 PM" creator "mod property SpinnerAgent on program emxSpinnerSystem.tcl value '2/3/2016 5:21:01 PM'"
 0 2 "2/3/2016 5:21:01 PM" creator "mod program emxSpinnerSystem.tcl file ./Business/SourceFiles/emxSpinnerSystem.tcl"
 0 2 "3/27/2017 3:41:29 PM" creator "mod property SpinnerAgent on program emxSpinnerSystem.tcl value '3/27/2017 3:41:29 PM'"
 0 2 "3/27/2017 3:41:29 PM" creator "mod program emxSpinnerSystem.tcl file ./Business/SourceFiles/emxSpinnerSystem.tcl"

!MTRX!END

!MTRX!AD! program emxSpinnerPerson.tcl "3DEXPERIENCE R2015x(24.0.0.0)"
emxSpinnerPerson.tcl 0 "" "#####################################################################*10.62
#
# @progdoc      emxSpinnerPerson.tcl vM10.62 (Build 7.1.23)
#
# @Description: This is schema spinner that adds Person schema.
#               Invoked from program
#               'emxSpinnerPerson.tcl'.
#
# @Usage:       Run this program for an MQL command window w/data files in directories:
#               . (current dir)         emxSpinnerAgent.tcl, emxSpinnerAccess.tcl programs
#
# @progdoc      Copyright (c) MatrixOne Inc., June 26, 2002
#
#########################################################################
#
# @Modifications: Greg Inglis   2004-02-09 - first version.
#                 Matt Osterman 2004-08-01 - added email, iconmail, password, hidden
#                 Tarun Gupta 11/28/2005 - Added code to set the Site of users to blank.
#                 Matt Osterman 2006-08-15 - incorporated overlay mode with emphasis on role/group assignments
#########################################################################
tcl;
eval {
   set sHost [info host]
   if { $sHost == \"mostermant43\" } {
      source \"c:/Program Files/TclPro1.3/win32-ix86/bin/prodebug.tcl\"
      set cmd \"debugger_eval\"
      set xxx [debugger_init]
   } else {
      set cmd \"eval\"
   }
}
$cmd {

   set bOverlay [mql get env OVERLAY]
   set bModIfExists [mql get env PERSONMODIFEXISTS]

#########################################################################
#                         USER DEFINED VARIABLES                        #
#########################################################################
   if {$bModIfExists == \"\" || $bModIfExists != \"TRUE\"} {
      set bModIfExists \"FALSE\" ;#TRUE or FALSE - modify person admin object if it exists
   }
   if {$bOverlay == \"\" || $bOverlay != \"TRUE\"} {
      set bOverlay \"FALSE\" ;#TRUE or FALSE - overlay person properties
   }
   set sChangeOwner \"Test Everything\" ;# person to change ownership of bus objects to if person is deleted.
#########################################################################


#************************************************************************
# Procedure:   pfile_write
#
# Description: Procedure to write a variable to file.
#
# Parameters:  The filename to write to,
#              The data variable.
#
# Returns:     Nothing
#************************************************************************

proc pfile_write { filename data } {
  return  [catch {
    set fileid [open $filename \"a+\"]
    puts $fileid $data
    close $fileid
  }]
}
#End pfile_write


#************************************************************************
# Procedure:   pfile_read
#
# Description: Procedure to read a file.
#
# Parameters:  The filename to read from.
#
# Returns:     The file data
#************************************************************************

proc pfile_read { sFile } {

  set data \"\"
  if { [file readable $sFile] } {
    set fd [open $sFile r]
    set data [read $fd]
    close $fd
  }
  return $data
}
#End file_read


proc pProcessFile { sFileName sDelimit } {

    set lFileData [ list ]
    set sFileData [ split [ pfile_read $sFileName ] \\n ]
    set sHeaderRaw [split [lindex $sFileData 0] $sDelimit ]

    set sHeader [ list ]
    foreach i $sHeaderRaw {
        lappend sHeader [ string trim $i ]
    }
    lappend lFileData $sHeader
    set sData [ lrange $sFileData 1 end ]
    foreach sDataLine $sData {
        set sDataLine [ split $sDataLine $sDelimit ]
        if {$sDataLine != \"\"} {
            lappend lFileData $sDataLine
        }
    }
    return $lFileData
}
# End pIncludeFile

#************************************************************************
# Procedure:   pWriteCue
#
# Description: Procedure to write processing cue to display.
#
# Returns:     Nothing
#************************************************************************

   proc pWriteCue {} {
      global iAddCounter iSkipCounter iErrorCounter iTenPercent iPrevAddModDel iPrevError
      set iAddModDel [expr $iAddCounter - $iPrevAddModDel]
      set iError [expr $iErrorCounter - $iPrevError]
      set iPrevAddModDel $iAddCounter
      set iPrevError $iErrorCounter
      set sWrite \"...\"
      if {$iAddModDel && $iError} {
         set sWrite \"  \\($iAddModDel\\: $iError\\!\\)\"
      } elseif {$iAddModDel} {
         set sWrite \"  \\($iAddModDel\\:\\)\"
      } elseif {$iError} {
         set sWrite \"  \\($iError\\!\\)\"
      }
      puts -nonewline \"$sWrite[expr $iTenPercent * 10]%\"
   }
# end pWriteCue

#main

    set bScan [mql get env SPINNERSCANMODE]; #scan mode and log suffix - SpinnerAgent
    if {$bScan != \"TRUE\"} {set bScan FALSE}
    set sSuffix [clock format [clock seconds] -format \".%m%d%y\"]
    if {$bScan} {set sSuffix \".SCAN\"}

    set sDelimit \"\\t\"
    if {[mql get env SPINNERLOGFILE] != \"\"} {; # SpinnerAgent
       set sLogFile [mql get env SPINNERLOGFILE]
       set sLogFileError [mql get env SPINNERERRORLOG]
       set bSpinnerAgent TRUE
    } else {    
       set sLogFile [file join . logs Person$sSuffix.log]
       set bSpinnerAgent FALSE
    }
    set iSystemError 0; # SpinnerAgent
    set iAddCounter 0
    set iSkipCounter 0
    set iErrorCounter 0
    set iPrevAddModDel 0
    set iPrevError 0
    set iTenPercent 1

    set lRole [split [mql list role] \\n]
    set lGroup [split [mql list group] \\n]
    
    set sBusType person
    set sSpinDir \"\"
    if {$bSpinnerAgent} {
       set sSpinDir [mql get env SPINNERPATH]
    }
    set lsDataFile [glob -nocomplain \"$sSpinDir/Business/SpinnerPersonData*.*\"]
    set bFirstRun TRUE
    foreach sBusFileName $lsDataFile {
       set sFile $sBusFileName
       set sBusFileName [file tail $sBusFileName]
       
       if {$bSpinnerAgent == \"FALSE\"} {
          puts \"Process $sBusType\\(s\\) from file '$sBusFileName':\"
       } else {
          pfile_write $sLogFile \"# \\[[clock format [clock seconds] -format %H:%M:%S]\\] Person\\(s\\) from file '$sBusFileName':\\n\"
          if {$bFirstRun} {
             puts \"\"
             set bFirstRun FALSE
          }
       }
               
       set lFileData [pProcessFile $sFile $sDelimit]
       set lHeader [lindex $lFileData 0]
       set lData [lrange $lFileData 1 end]
   
       set sCmd \"mql list $sBusType\"
       if {[catch {eval $sCmd} sMsg] == 0} {
           set sRtn $sMsg
       } else {
           set sCmt \"An error occurred. The mql cmd is\\n$sCmd\\nError message is\\n$sMsg\\n\"
           puts $sCmt
           pfile_write $sLogFile $sCmt
           if {$bSpinnerAgent} {
              set iLogFileErr [open $sLogFileError a+]
              puts $iLogFileErr $sCmt
              close $iLogFileErr
           }
           incr iSystemError; #SpinnerAgent
       }
           
       if {$sRtn == \"\"} {
           pfile_write $sLogFile \"# No Bus type '$sBusType for file '$sBusFileName' exist\"
       } else {
           set lPersonNames [split $sRtn \\n]
       }
   
       set bWriteCue FALSE
       if {[llength $lData] > 19} {
          set bWriteCue TRUE
          set iPercent [expr [llength $lData] / 10]
       }
       foreach lLineData $lData {
           set sName [lindex $lHeader 0]
           set sNameValue [string trim [lindex $lLineData 0] \\\"]
           set bDel FALSE
           if {[string first \"<<\" $sNameValue] == 0 && [string first \">>\" $sNameValue] == [expr [string length $sNameValue] -2]} {
              set sNameValue [string range $sNameValue 2 [expr [string length $sNameValue] -3]]
              set bDel TRUE
           }
           set sAddMod \"mod\"
           set slsAssign \"\"
           set lsAssignActual \"\"
           set sExists [lsearch $lPersonNames $sNameValue]
           if {!$bDel} {
              if {$sExists == -1} {
                 set sAddMod \"add\"
              } elseif {$bOverlay} {
                 catch {set slsAssign [mql print person \"$sNameValue\" select assignment dump |]} sMsg
                 set lsAssignActual [split $slsAssign |]
              } else {
                 catch {mql mod person \"$sNameValue\" remove assign all} sMsg
              }
           }
           set sCmt \"     $sNameValue\"
           if {$bWriteCue == \"FALSE\"} {
              puts -nonewline $sCmt
              if {$bScan} {puts \"\"}
           }
           if { $sExists == -1 || $bModIfExists} {
               set sCmd \"mql $sAddMod $sBusType \"
               set bJ FALSE
               set bRoleGroup FALSE
               set lsAssignRole \"\"
               set lsAssignGroup \"\"
               foreach i $lHeader j $lLineData {
                   set j [string trim $j \\\"]
                   if {[string tolower $j] == \"<null>\"} {set j \"<null>\"}
                   # do Not process the registry name
                   if {$i == \"Registry Name\"} {
                       continue
                   }
                   if { $i == \"name\" } {
                      append sCmd \" \" \"\\\"$sNameValue\\\"\"
                   } elseif {$j != \"\" && !$bDel} {
                       set bJ TRUE
                       if { $i == \"assign_role\"} {
                           set bRoleGroup TRUE
                           set jtest [string tolower $j]
                           if {$jtest == \"all\"} {
                              set lsAssignRole $lRole
                           } elseif {$jtest == \"<null>\" || $jtest == \"<<all>>\"} {
                              if {$bOverlay} {
                                 set lsAssignRole \"<null>\"
                              } else {
                                 set lsAssignRole \"\"
                              }
                           } else {
                              set lsAssignRole [split $j |]
                           }
                       } elseif { $i == \"assign_group\"} {
                           set bRoleGroup TRUE
                           set jtest [string tolower $j]
                           if {[string tolower $j] == \"all\"} {
                              set lsAssignGroup $lGroup
                           } elseif {$jtest == \"<null>\" || $jtest == \"<<all>>\"} {
                              if {$bOverlay} {
                                 set lsAssignGroup \"<null>\"
                              } else {
                                 set lsAssignGroup \"\"
                              }
                           } else {
                              set lsAssignGroup [split $j |]
                           }
                       } elseif { $i == \"hidden\"} {
                          if {$j != \"\"} {
                             if {[string tolower $j] != \"true\" && [string tolower $j] != \"hidden\"} {
                                set j nothidden
                             } else {
                                set j hidden
                             }
                             append sCmd \" $j\"
                          }
                       } elseif { $i == \"password\"} {
                          set bModPassword TRUE
                          if {$sAddMod == \"mod\"} {
                             set lsPerson [split [mql print person \"$sNameValue\"] \\n]
                             foreach sPerson $lsPerson {
                                if {[string trim $sPerson] == \"password <RESTRICTED>\"} {
                                   set bModPassword FALSE
                                   break
                                }
                             }
                          }
                          if {$bModPassword} {                               
                             if {$j == \"<BLANK>\" || $j == \"<null>\"} {
                                set j \"\"
                             }
                             append sCmd \" \" \"$i\" \" \" \"\\\"$j\\\"\"
                          }
                       } elseif { $i == \"forcepassword\"} {
                          if {$j != \"\"} {
                             if {[string tolower $j] == \"<blank>\" || [string tolower $j] == \"<null>\"} {
                                set j \"\"
                             }
                             append sCmd \" \" \"password\" \" \" \"\\\"$j\\\"\"
                          }
                       } elseif { $i == \"passwordexpired\"} {
                          if {$j != \"\"} {
                             if {[string tolower $j] == \"true\" || [string tolower $j] == \"yes\" || [string tolower $j] == \"passwordexpired\"} {
                                append sCmd \" passwordexpired\"
                             }
                          }
                       } elseif { $i == \"iconmail\" || $i == \"e_mail\" || ( $i == \"email\" && [string first \"@\" $j] < 0 )} {
                          if {$j != \"\"} {
                             if {[string tolower $j] == \"enable\" || [string tolower $j] == \"true\"} {
                                set j enable
                             } else {
                                set j disable
                             }
                             regsub \"_\" $i \"\" i 
                             append sCmd \" $j $i\"
                          }
                       } else {
                          if {$j == \"<null>\"} {set j \"\"}
                          append sCmd \" \" \"$i\" \" \" \"\\\"$j\\\"\"
                       }
                   }
               }
   # Process Roles and Groups            
               if {$bRoleGroup} {
                  if {$bOverlay} {
                     if {$lsAssignRole == \"<null>\" && $lsAssignGroup == \"<null>\"} {
                        append sCmd \" remove assign all\"
                     } elseif {$lsAssignRole == \"<null>\"} {
                        set slsRemoveRole \"\"
                        foreach sRole $lRole {
                           if {[lsearch $lsAssignActual $sRole] > -1} {
                              append sCmd \" remove assign role \\\"$sRole\\\"\"
                           }
                        }
                     } elseif {$lsAssignGroup == \"<null>\"} {
                        foreach sGroup $lGroup {
                           if {[lsearch $lsAssignActual $sGroup] > -1} {
                              append sCmd \" remove assign group \\\"$sGroup\\\"\"
                           }
                        }
                     }
                  }
                  if {$lsAssignRole != \"<null>\"} {
                     foreach sAssignRole $lsAssignRole {
                        set sAssignRole [string trim $sAssignRole]
                        if {$bOverlay && [string first \"<<\" $sAssignRole] >= 0 && [string first \">>\" $sAssignRole] == [expr [string length $sAssignRole] -2]} {
                           set sAssignRole [string trim $sAssignRole \"<<\"]
                           set sAssignRole [string trim $sAssignRole \">>\"]
                           set sAssignRole [string trim $sAssignRole]
                           if {[lsearch $lRole $sAssignRole] > -1 && [lsearch $lsAssignActual $sAssignRole] > -1} {
                              append sCmd \" remove assign role \\\"$sAssignRole\\\"\"
                           }
                        } elseif {[lsearch $lRole $sAssignRole] > -1} {
                           if {$bOverlay} {
                              if {[lsearch $lsAssignActual $sAssignRole] < 0} {
                                 append sCmd \" assign role \\\"$sAssignRole\\\"\"
                              }
                           } else {
                              append sCmd \" assign role \\\"$sAssignRole\\\"\"
                           }
                        }
                     }
                  }
                  if {$lsAssignGroup != \"<null>\"} {
                     foreach sAssignGroup $lsAssignGroup {
                        set sAssignGroup [string trim $sAssignGroup]
                        if {$bOverlay && [string first \"<<\" $sAssignGroup] >= 0 && [string first \">>\" $sAssignGroup] == [expr [string length $sAssignGroup] -2]} {
                           set sAssignGroup [string trim $sAssignGroup \"<<\"]
                           set sAssignGroup [string trim $sAssignGroup \">>\"]
                           set sAssignGroup [string trim $sAssignGroup]
                           if {[lsearch $lGroup $sAssignGroup] > -1 && [lsearch $lsAssignActual $sAssignGroup] > -1} {
                              append sCmd \" remove assign group \\\"$sAssignGroup\\\"\"
                           }
                        } elseif {[lsearch $lGroup $sAssignGroup] > -1} {
                           if {$bOverlay} {
                              if {[lsearch $lsAssignActual $sAssignGroup] < 0} {
                                 append sCmd \" assign group \\\"$sAssignGroup\\\"\"
                              }
                           } else {
                              append sCmd \" assign group \\\"$sAssignGroup\\\"\"
                           }
                        }
                     }
                  }
               }
               
               set bProcess TRUE
               if {$bJ == \"FALSE\"} {
                  if {$sExists == -1} {
                     set bProcess FALSE
                  } else {
                     regsub \"mod\" $sCmd \"delete\" sCmd
                     mql trigger off
                     if {[mql list person $sNameValue] != \"\"} {
                        puts -nonewline \" (DELETE in progress - reassigning bus objects to '$sChangeOwner')\"
                        if {[mql print bus Person $sNameValue - select exists dump]} {
                           mql delete bus Person $sNameValue -
                           pfile_write $sLogFile \"mql delete bus Person \\\"$sNameValue\\\" -\"
                        }  
                        set lsBusObj [split [mql temp query bus * * * owner \"$sNameValue\" select id dump |] \\n]
                        foreach slsBusObj $lsBusObj {
                           set oId [lindex [split $slsBusObj |] 3]
                           mql mod bus $oId owner $sChangeOwner
                           pfile_write $sLogFile \"mql mod bus $oId owner \\\"$sChangeOwner\\\"\"
                        }
                     }
                     mql trigger on
                  }
               }
               if {$bProcess} {
                  pfile_write $sLogFile $sCmd
                  if {$bScan != \"TRUE\"} {;#spinneragent
                      if {[catch {eval $sCmd} sMsg] == 0} {
                          if {$bWriteCue == \"FALSE\"} {
                             puts \" (SUCCESS)\"
                          } else {
                             incr iAddCounter
                          }
                          pfile_write $sLogFile \"# Command return is: SUCCESS\"
                      } else {
                          if {$bWriteCue == \"FALSE\"} {
                             puts \" (ERROR)\"
                          } else {
                             incr iErrorCounter
                          }
                          pfile_write $sLogFile \"Command return is: ERROR, message is:\\n$sMsg\"
                          if {$bSpinnerAgent} {
                             set iLogFileErr [open $sLogFileError a+]
                             puts $iLogFileErr \"MQL command:\\n$sCmd\\nError message is:\\n$sMsg\"
                             close $iLogFileErr
                          }
                          incr iSystemError; #SpinnerAgent
                      }
                  }
               } else {
                  if {$bWriteCue == \"FALSE\"} {
                     puts \" (SKIP)\"
                  } else {
                     incr iSkipCounter
                  }
                  pfile_write $sLogFile \"# $sBusType '$sNameValue' already deleted, SKIP\"
               }
           } else {
               if {$bWriteCue == \"FALSE\"} {
                  puts \" (SKIP)\"
               } else {
                  incr iSkipCounter
               }
               pfile_write $sLogFile \"# $sBusType '$sNameValue' already exists, SKIP\"
           }
           if {$bWriteCue && $iTenPercent < 10 && [expr $iAddCounter + $iSkipCounter + $iErrorCounter] > [expr $iTenPercent * $iPercent]} {
              pWriteCue
              incr iTenPercent
           }
       }
       if {$bWriteCue} {
          pWriteCue
          puts \"\"
       }
       pfile_write $sLogFile \"# End Process $sBusType\\n\"
       mql set env PERSONERROR $iSystemError; #SpinnerAgent
    }
}
" 1 0 0 0 0 0 0 0 0 0 0 0 "" 0 0
 0 1
 SpinnerAgent NULL noname "3/27/2017 3:41:29 PM" 0
"12/6/2015 11:42:58 PM" "3/14/2018 3:57:25 PM"
7
 0 1 "12/6/2015 11:42:58 PM" creator "add program emxSpinnerPerson.tcl mql execute immediate !needsbusinessobject !downloadable !pipe !pooled nothidden file ./Business/SourceFiles/emxSpinnerPerson.tcl"
 0 2 "12/6/2015 11:42:58 PM" creator "add property SpinnerAgent on program emxSpinnerPerson.tcl value '12/6/2015 11:42:58 PM'"
 0 2 "12/6/2015 11:42:58 PM" creator "mod program emxSpinnerPerson.tcl description ''"
 0 2 "2/3/2016 5:21:02 PM" creator "mod property SpinnerAgent on program emxSpinnerPerson.tcl value '2/3/2016 5:21:02 PM'"
 0 2 "2/3/2016 5:21:02 PM" creator "mod program emxSpinnerPerson.tcl file ./Business/SourceFiles/emxSpinnerPerson.tcl"
 0 2 "3/27/2017 3:41:29 PM" creator "mod property SpinnerAgent on program emxSpinnerPerson.tcl value '3/27/2017 3:41:29 PM'"
 0 2 "3/27/2017 3:41:29 PM" creator "mod program emxSpinnerPerson.tcl file ./Business/SourceFiles/emxSpinnerPerson.tcl"

!MTRX!END

!MTRX!AD! program emxSpinnerSettings.tcl "3DEXPERIENCE R2015x(24.0.0.0)"
emxSpinnerSettings.tcl 0 "" "#************************************************************************
# @progdoc        emxSpinnerSettings.tcl
#
# @Brief:         User definable settings for emxSpinnerAgent.tcl
#
# @Usage:         Modify parameters as commented below.  
#
# @progdoc        Copyright (c) 2005, MatrixOne Inc.
#************************************************************************
# @Modifications:
#
# @FirstName LastName --/--/--  - Description
#  
#************************************************************************

#  ********************** USER DEFINED VARIABLES*********************************
#  WARNING - DO NOT CHANGE SETTINGS UNTIL YOU ARE FAMILIAR WITH DEFAULT BEHAVIOR!
#  ******************************************************************************
   set sParentChild \"parent\"        ;# parent or child - use parent or child fields in roles and groups - cannot use both!
   set bUseAssignmentField \"FALSE\" ;# TRUE or FALSE - process person assignments set in role/group data
#                                   Note: recommend using group and role assignments in person data file instead
   set bUseAccessField \"FALSE\"     ;# TRUE or FALSE - process user access assignments in rules and policy states
#                                   Note: strongly recommended to use policy/rule access files instead
   set bRetainBusObject \"TRUE\"     ;# TRUE or FALSE - retain bus objects current states when resequencing policy states
#                                   Note: For large data sets, set to FALSE and use data migration methods instead
   set bImportOverwrite \"FALSE\"    ;# TRUE or FALSE - overwrite import if it exists
   set bBusObjOverwrite \"TRUE\"    ;# TRUE or FALSE - overwrite bus objects in emxSpinnerBusObjects.tcl if exists
   set bBusRelOverwrite \"TRUE\"    ;# TRUE or FALSE - overwrite bus rels in emxSpinnerBusRels.tcl if exists
   set bTriggerAdd \"OFF\"           ;# ON or OFF - turns global create triggers on or off for bus objects and connections
   set bTriggerMod \"OFF\"           ;# ON or OFF - turns global modify triggers on or off for bus objects and connections
   set bTriggerDel \"OFF\"           ;# ON or OFF - turns global delete triggers on or off for bus objects and connections
   set bTriggerChk \"OFF\"           ;# ON or OFF - turns global checkin triggers on or off for bus object files
   set sReplaceSymbolic \"&?%$ ()\"  ;# characters to be trimmed when creating symbolic names
   set sDelimiter \"tab\"            ;# data delimiter: select tab, pipe, comma, carot, tilde or newline
   set sRangeDelim \"pipe\"          ;# attr range delimiter (use different one than data delimiter!)
   set bShowModOnly \"TRUE\"         ;# TRUE or FALSE - only modifications are logged when set to TRUE
   set bStreamLog \"FALSE\"          ;# TRUE or FALSE - output log to screen if TRUE
   set bShowTransaction \"FALSE\"    ;# TRUE or FALSE - show transaction boundaries during logging
   set bCompile \"TRUE\"             ;# TRUE or FALSE - compile JPO's added or modified if TRUE
   set bOverlay \"FALSE\"             ;# TRUE or FALSE - skip blank entries, append/merge list elements
#                                   Notes: - Overlay not applicable to access, system, bus object or rel data files
#                                          - Use <NULL> to force null values
#                                          - Use double tags to delete list items (e.g. <<Delete Element>> )
   set lsSubDirSequence [list \"\"]  ;# list of subdirectories for sequenced builds (e.g. [list Spinner1 Spinner2 \"\"]
#                                   Note: \"\" is current working directory.  In example, ./Spinner/Spinner1 is run first,
#                                         ./Spinner/Spinner2 second, ./Spinner last.  Read Schema_Agent.htm for usage 
   set lsFileExtSkip [list \".bak\" \".scc\" \".tmp\"] ;# list of file extensions to skip when reading data files
   set rRefreshLog 17               ;# time interval in days to reset SpinDone.log (forces processing of all data files)
   set bAbbrCue \"FALSE\"            ;# TRUE or FALSE - abbreviate cues to screen if TRUE
   set iBusObjCommit 1000          ;# number of bus objects to process before committing when renaming states
   set bForeignVault \"FALSE\"       ;# TRUE or FALSE - use foreign vaults in bus object queries
   set bContinueOnError \"FALSE\"    ;# TRUE or FALSE - flag, but do not halt on errors
   set bChangeAttrType \"TRUE\"     ;# TRUE or FALSE - allow attribute type to be changed (e.g. string to real)
#                                   WARNING: Attribute must be deleted then added to change type so may cause loss of data
   set bPersonOverwrite \"TRUE\"     ;# TRUE or FALSE - overwrite person objects in emxSpinnerPerson.tcl if exists
   set bCDM \"TRUE\"                 ;# TRUE or FALSE - checkin files using CDM format
   set bOut \"TRUE\"                 ;# TRUE or FALSE - display warning messages to console
#  ****************************************************************************
" 1 0 0 0 0 0 0 0 0 0 0 0 "" 0 0
 0 1
 SpinnerAgent NULL noname "3/27/2017 3:41:29 PM" 0
"12/6/2015 11:42:58 PM" "3/14/2018 3:57:25 PM"
48
 0 1 "12/6/2015 11:42:58 PM" creator "add program emxSpinnerSettings.tcl mql execute immediate !needsbusinessobject !downloadable !pipe !pooled nothidden file ./Business/SourceFiles/emxSpinnerSettings.tcl"
 0 2 "12/6/2015 11:42:58 PM" creator "add property SpinnerAgent on program emxSpinnerSettings.tcl value '12/6/2015 11:42:58 PM'"
 0 2 "12/6/2015 11:42:58 PM" creator "mod program emxSpinnerSettings.tcl description ''"
 0 2 "2/3/2016 5:21:02 PM" creator "mod property SpinnerAgent on program emxSpinnerSettings.tcl value '2/3/2016 5:21:02 PM'"
 0 2 "2/3/2016 5:21:02 PM" creator "mod program emxSpinnerSettings.tcl file ./Business/SourceFiles/emxSpinnerSettings.tcl"
 0 2 "3/3/2016 10:10:52 AM" creator "  modify program emxSpinnerSettings.tcl !pipe code \"#************************************************************************  set sParentChild \"child\"        ;# parent or child - use parent or child fields in roles and groups - cannot use both! set bUseAssignmentField \"FALSE\" ;# TRUE or FALSE - process person assignments set in role/group data set bUseAccessField \"FALSE\"     ;# TRUE or FALSE - process user access assignments in rules and policy states set bRetainBusObject \"TRUE\"     ;# TRUE or FALSE - retain bus objects current states when resequencing policy states set bImportOverwrite \"TRUE\"    ;# TRUE or FALSE - overwrite import if it exists set bBusObjOverwrite \"TRUE\"    ;# TRUE or FALSE - overwrite bus objects in emxSpinnerBusObjects.tcl if exists set bBusRelOverwrite \"TRUE\"    ;# TRUE or FALSE - overwrite bus rels in emxSpinnerBusRels.tcl if exists set bTriggerAdd \"OFF\"           ;# ON or OFF - turns global create triggers on or off for bus objects and connections set bTriggerMod \"OFF\"           ;# ON or OFF - turns global modify triggers on or off for bus objects and connections set bTriggerDel \"OFF\"           ;# ON or OFF - turns global delete triggers on or off for bus objects and connections set bTriggerChk \"OFF\"           ;# ON or OFF - turns global checkin triggers on or off for bus object files set sReplaceSymbolic \"&?%$ ()\"  ;# characters to be trimmed when creating symbolic names set sDelimiter \"tab\"            ;# data delimiter: select tab, pipe, comma, carot, tilde or newline set sRangeDelim \"pipe\"          ;# attr range delimiter (use different one than data delimiter!) set bShowModOnly \"TRUE\"         ;# TRUE or FALSE - only modifications are logged when set to TRUE set bStreamLog \"FALSE\"          ;# TRUE or FALSE - output log to screen if TRUE set bShowTransaction \"FALSE\"    ;# TRUE or FALSE - show transaction boundaries during logging set bCompile \"FALSE\"             ;# TRUE or FALSE - compile JPO's added or modified if TRUE set bOverlay \"FALSE\"             ;# TRUE or FALSE - skip"
 0 2 "3/6/2016 11:13:43 PM" creator "  modify program emxSpinnerSettings.tcl !pipe code \"#************************************************************************  set sParentChild \"child\"        ;# parent or child - use parent or child fields in roles and groups - cannot use both! set bUseAssignmentField \"FALSE\" ;# TRUE or FALSE - process person assignments set in role/group data set bUseAccessField \"FALSE\"     ;# TRUE or FALSE - process user access assignments in rules and policy states set bRetainBusObject \"TRUE\"     ;# TRUE or FALSE - retain bus objects current states when resequencing policy states set bImportOverwrite \"FALSE\"    ;# TRUE or FALSE - overwrite import if it exists set bBusObjOverwrite \"FALSE\"    ;# TRUE or FALSE - overwrite bus objects in emxSpinnerBusObjects.tcl if exists set bBusRelOverwrite \"FALSE\"    ;# TRUE or FALSE - overwrite bus rels in emxSpinnerBusRels.tcl if exists set bTriggerAdd \"OFF\"           ;# ON or OFF - turns global create triggers on or off for bus objects and connections set bTriggerMod \"OFF\"           ;# ON or OFF - turns global modify triggers on or off for bus objects and connections set bTriggerDel \"OFF\"           ;# ON or OFF - turns global delete triggers on or off for bus objects and connections set bTriggerChk \"OFF\"           ;# ON or OFF - turns global checkin triggers on or off for bus object files set sReplaceSymbolic \"&?%$ ()\"  ;# characters to be trimmed when creating symbolic names set sDelimiter \"tab\"            ;# data delimiter: select tab, pipe, comma, carot, tilde or newline set sRangeDelim \"pipe\"          ;# attr range delimiter (use different one than data delimiter!) set bShowModOnly \"TRUE\"         ;# TRUE or FALSE - only modifications are logged when set to TRUE set bStreamLog \"FALSE\"          ;# TRUE or FALSE - output log to screen if TRUE set bShowTransaction \"FALSE\"    ;# TRUE or FALSE - show transaction boundaries during logging set bCompile \"FALSE\"             ;# TRUE or FALSE - compile JPO's added or modified if TRUE set bOverlay \"FALSE\"             ;# TRUE or FALSE - s"
 0 2 "3/6/2016 11:20:13 PM" creator "  modify program emxSpinnerSettings.tcl !pipe code \"#************************************************************************  set sParentChild \"child\"        ;# parent or child - use parent or child fields in roles and groups - cannot use both! set bUseAssignmentField \"FALSE\" ;# TRUE or FALSE - process person assignments set in role/group data set bUseAccessField \"FALSE\"     ;# TRUE or FALSE - process user access assignments in rules and policy states set bRetainBusObject \"TRUE\"     ;# TRUE or FALSE - retain bus objects current states when resequencing policy states set bImportOverwrite \"TRUE\"    ;# TRUE or FALSE - overwrite import if it exists set bBusObjOverwrite \"FALSE\"    ;# TRUE or FALSE - overwrite bus objects in emxSpinnerBusObjects.tcl if exists set bBusRelOverwrite \"FALSE\"    ;# TRUE or FALSE - overwrite bus rels in emxSpinnerBusRels.tcl if exists set bTriggerAdd \"OFF\"           ;# ON or OFF - turns global create triggers on or off for bus objects and connections set bTriggerMod \"OFF\"           ;# ON or OFF - turns global modify triggers on or off for bus objects and connections set bTriggerDel \"OFF\"           ;# ON or OFF - turns global delete triggers on or off for bus objects and connections set bTriggerChk \"OFF\"           ;# ON or OFF - turns global checkin triggers on or off for bus object files set sReplaceSymbolic \"&?%$ ()\"  ;# characters to be trimmed when creating symbolic names set sDelimiter \"tab\"            ;# data delimiter: select tab, pipe, comma, carot, tilde or newline set sRangeDelim \"pipe\"          ;# attr range delimiter (use different one than data delimiter!) set bShowModOnly \"TRUE\"         ;# TRUE or FALSE - only modifications are logged when set to TRUE set bStreamLog \"FALSE\"          ;# TRUE or FALSE - output log to screen if TRUE set bShowTransaction \"FALSE\"    ;# TRUE or FALSE - show transaction boundaries during logging set bCompile \"FALSE\"             ;# TRUE or FALSE - compile JPO's added or modified if TRUE set bOverlay \"FALSE\"             ;# TRUE or FALSE - sk"
 0 2 "3/6/2016 11:24:31 PM" creator "  modify program emxSpinnerSettings.tcl !pipe;"
 0 2 "3/7/2016 9:28:07 AM" creator "  modify program emxSpinnerSettings.tcl !pipe code \"#************************************************************************  set sParentChild \"parent\"        ;# parent or child - use parent or child fields in roles and groups - cannot use both! set bUseAssignmentField \"FALSE\" ;# TRUE or FALSE - process person assignments set in role/group data set bUseAccessField \"FALSE\"     ;# TRUE or FALSE - process user access assignments in rules and policy states set bRetainBusObject \"TRUE\"     ;# TRUE or FALSE - retain bus objects current states when resequencing policy states set bImportOverwrite \"TRUE\"    ;# TRUE or FALSE - overwrite import if it exists set bBusObjOverwrite \"TRUE\"    ;# TRUE or FALSE - overwrite bus objects in emxSpinnerBusObjects.tcl if exists set bBusRelOverwrite \"TRUE\"    ;# TRUE or FALSE - overwrite bus rels in emxSpinnerBusRels.tcl if exists set bTriggerAdd \"OFF\"           ;# ON or OFF - turns global create triggers on or off for bus objects and connections set bTriggerMod \"OFF\"           ;# ON or OFF - turns global modify triggers on or off for bus objects and connections set bTriggerDel \"OFF\"           ;# ON or OFF - turns global delete triggers on or off for bus objects and connections set bTriggerChk \"OFF\"           ;# ON or OFF - turns global checkin triggers on or off for bus object files set sReplaceSymbolic \"&?%$ ()\"  ;# characters to be trimmed when creating symbolic names set sDelimiter \"tab\"            ;# data delimiter: select tab, pipe, comma, carot, tilde or newline set sRangeDelim \"pipe\"          ;# attr range delimiter (use different one than data delimiter!) set bShowModOnly \"TRUE\"         ;# TRUE or FALSE - only modifications are logged when set to TRUE set bStreamLog \"FALSE\"          ;# TRUE or FALSE - output log to screen if TRUE set bShowTransaction \"FALSE\"    ;# TRUE or FALSE - show transaction boundaries during logging set bCompile \"FALSE\"             ;# TRUE or FALSE - compile JPO's added or modified if TRUE set bOverlay \"FALSE\"             ;# TRUE or FALSE - ski"
 0 2 "3/7/2016 9:30:41 AM" creator "  modify program emxSpinnerSettings.tcl !pipe code \"#************************************************************************  set sParentChild \"parent\"        ;# parent or child - use parent or child fields in roles and groups - cannot use both! set bUseAssignmentField \"FALSE\" ;# TRUE or FALSE - process person assignments set in role/group data set bUseAccessField \"FALSE\"     ;# TRUE or FALSE - process user access assignments in rules and policy states set bRetainBusObject \"TRUE\"     ;# TRUE or FALSE - retain bus objects current states when resequencing policy states set bImportOverwrite \"TRUE\"    ;# TRUE or FALSE - overwrite import if it exists set bBusObjOverwrite \"TRUE\"    ;# TRUE or FALSE - overwrite bus objects in emxSpinnerBusObjects.tcl if exists set bBusRelOverwrite \"TRUE\"    ;# TRUE or FALSE - overwrite bus rels in emxSpinnerBusRels.tcl if exists set bTriggerAdd \"OFF\"           ;# ON or OFF - turns global create triggers on or off for bus objects and connections set bTriggerMod \"OFF\"           ;# ON or OFF - turns global modify triggers on or off for bus objects and connections set bTriggerDel \"OFF\"           ;# ON or OFF - turns global delete triggers on or off for bus objects and connections set bTriggerChk \"OFF\"           ;# ON or OFF - turns global checkin triggers on or off for bus object files set sReplaceSymbolic \"&?%$ ()\"  ;# characters to be trimmed when creating symbolic names set sDelimiter \"tab\"            ;# data delimiter: select tab, pipe, comma, carot, tilde or newline set sRangeDelim \"pipe\"          ;# attr range delimiter (use different one than data delimiter!) set bShowModOnly \"TRUE\"         ;# TRUE or FALSE - only modifications are logged when set to TRUE set bStreamLog \"FALSE\"          ;# TRUE or FALSE - output log to screen if TRUE set bShowTransaction \"FALSE\"    ;# TRUE or FALSE - show transaction boundaries during logging set bCompile \"FALSE\"             ;# TRUE or FALSE - compile JPO's added or modified if TRUE set bOverlay \"TRUE\"             ;# TRUE or FALSE - skip"
 0 2 "3/7/2016 9:48:27 AM" creator "  modify program emxSpinnerSettings.tcl !pipe code \"#************************************************************************  set sParentChild \"parent\"        ;# parent or child - use parent or child fields in roles and groups - cannot use both! set bUseAssignmentField \"FALSE\" ;# TRUE or FALSE - process person assignments set in role/group data set bUseAccessField \"FALSE\"     ;# TRUE or FALSE - process user access assignments in rules and policy states set bRetainBusObject \"TRUE\"     ;# TRUE or FALSE - retain bus objects current states when resequencing policy states set bImportOverwrite \"TRUE\"    ;# TRUE or FALSE - overwrite import if it exists set bBusObjOverwrite \"TRUE\"    ;# TRUE or FALSE - overwrite bus objects in emxSpinnerBusObjects.tcl if exists set bBusRelOverwrite \"TRUE\"    ;# TRUE or FALSE - overwrite bus rels in emxSpinnerBusRels.tcl if exists set bTriggerAdd \"OFF\"           ;# ON or OFF - turns global create triggers on or off for bus objects and connections set bTriggerMod \"OFF\"           ;# ON or OFF - turns global modify triggers on or off for bus objects and connections set bTriggerDel \"OFF\"           ;# ON or OFF - turns global delete triggers on or off for bus objects and connections set bTriggerChk \"OFF\"           ;# ON or OFF - turns global checkin triggers on or off for bus object files set sReplaceSymbolic \"&?%$ ()\"  ;# characters to be trimmed when creating symbolic names set sDelimiter \"tab\"            ;# data delimiter: select tab, pipe, comma, carot, tilde or newline set sRangeDelim \"pipe\"          ;# attr range delimiter (use different one than data delimiter!) set bShowModOnly \"TRUE\"         ;# TRUE or FALSE - only modifications are logged when set to TRUE set bStreamLog \"FALSE\"          ;# TRUE or FALSE - output log to screen if TRUE set bShowTransaction \"FALSE\"    ;# TRUE or FALSE - show transaction boundaries during logging set bCompile \"FALSE\"             ;# TRUE or FALSE - compile JPO's added or modified if TRUE set bOverlay \"FALSE\"             ;# TRUE or FALSE - ski"
 0 2 "3/7/2016 9:53:34 AM" creator "  modify program emxSpinnerSettings.tcl !pipe code \"#************************************************************************  set sParentChild \"parent\"        ;# parent or child - use parent or child fields in roles and groups - cannot use both! set bUseAssignmentField \"FALSE\" ;# TRUE or FALSE - process person assignments set in role/group data set bUseAccessField \"FALSE\"     ;# TRUE or FALSE - process user access assignments in rules and policy states set bRetainBusObject \"TRUE\"     ;# TRUE or FALSE - retain bus objects current states when resequencing policy states set bImportOverwrite \"TRUE\"    ;# TRUE or FALSE - overwrite import if it exists set bBusObjOverwrite \"FALSE\"    ;# TRUE or FALSE - overwrite bus objects in emxSpinnerBusObjects.tcl if exists set bBusRelOverwrite \"FALSE\"    ;# TRUE or FALSE - overwrite bus rels in emxSpinnerBusRels.tcl if exists set bTriggerAdd \"OFF\"           ;# ON or OFF - turns global create triggers on or off for bus objects and connections set bTriggerMod \"OFF\"           ;# ON or OFF - turns global modify triggers on or off for bus objects and connections set bTriggerDel \"OFF\"           ;# ON or OFF - turns global delete triggers on or off for bus objects and connections set bTriggerChk \"OFF\"           ;# ON or OFF - turns global checkin triggers on or off for bus object files set sReplaceSymbolic \"&?%$ ()\"  ;# characters to be trimmed when creating symbolic names set sDelimiter \"tab\"            ;# data delimiter: select tab, pipe, comma, carot, tilde or newline set sRangeDelim \"pipe\"          ;# attr range delimiter (use different one than data delimiter!) set bShowModOnly \"TRUE\"         ;# TRUE or FALSE - only modifications are logged when set to TRUE set bStreamLog \"FALSE\"          ;# TRUE or FALSE - output log to screen if TRUE set bShowTransaction \"FALSE\"    ;# TRUE or FALSE - show transaction boundaries during logging set bCompile \"FALSE\"             ;# TRUE or FALSE - compile JPO's added or modified if TRUE set bOverlay \"FALSE\"             ;# TRUE or FALSE - s"
 0 2 "3/7/2016 9:54:26 AM" creator "  modify program emxSpinnerSettings.tcl !pipe code \"#************************************************************************  set sParentChild \"parent\"        ;# parent or child - use parent or child fields in roles and groups - cannot use both! set bUseAssignmentField \"FALSE\" ;# TRUE or FALSE - process person assignments set in role/group data set bUseAccessField \"FALSE\"     ;# TRUE or FALSE - process user access assignments in rules and policy states set bRetainBusObject \"TRUE\"     ;# TRUE or FALSE - retain bus objects current states when resequencing policy states set bImportOverwrite \"TRUE\"    ;# TRUE or FALSE - overwrite import if it exists set bBusObjOverwrite \"FALSE\"    ;# TRUE or FALSE - overwrite bus objects in emxSpinnerBusObjects.tcl if exists set bBusRelOverwrite \"FALSE\"    ;# TRUE or FALSE - overwrite bus rels in emxSpinnerBusRels.tcl if exists set bTriggerAdd \"OFF\"           ;# ON or OFF - turns global create triggers on or off for bus objects and connections set bTriggerMod \"OFF\"           ;# ON or OFF - turns global modify triggers on or off for bus objects and connections set bTriggerDel \"OFF\"           ;# ON or OFF - turns global delete triggers on or off for bus objects and connections set bTriggerChk \"OFF\"           ;# ON or OFF - turns global checkin triggers on or off for bus object files set sReplaceSymbolic \"&?%$ ()\"  ;# characters to be trimmed when creating symbolic names set sDelimiter \"tab\"            ;# data delimiter: select tab, pipe, comma, carot, tilde or newline set sRangeDelim \"pipe\"          ;# attr range delimiter (use different one than data delimiter!) set bShowModOnly \"TRUE\"         ;# TRUE or FALSE - only modifications are logged when set to TRUE set bStreamLog \"FALSE\"          ;# TRUE or FALSE - output log to screen if TRUE set bShowTransaction \"FALSE\"    ;# TRUE or FALSE - show transaction boundaries during logging set bCompile \"FALSE\"             ;# TRUE or FALSE - compile JPO's added or modified if TRUE set bOverlay \"TRUE\"             ;# TRUE or FALSE - sk"
 0 2 "3/7/2016 10:03:59 AM" creator "mod property SpinnerAgent on program emxSpinnerSettings.tcl value '3/7/2016 10:03:59 AM'"
 0 2 "3/7/2016 10:03:59 AM" creator "mod program emxSpinnerSettings.tcl file ./Business/SourceFiles/emxSpinnerSettings.tcl"
 0 2 "3/7/2016 10:05:43 AM" creator "  modify program emxSpinnerSettings.tcl !pipe code \"#************************************************************************  set sParentChild \"child\"        ;# parent or child - use parent or child fields in roles and groups - cannot use both! set bUseAssignmentField \"FALSE\" ;# TRUE or FALSE - process person assignments set in role/group data set bUseAccessField \"FALSE\"     ;# TRUE or FALSE - process user access assignments in rules and policy states set bRetainBusObject \"TRUE\"     ;# TRUE or FALSE - retain bus objects current states when resequencing policy states set bImportOverwrite \"TRUE\"    ;# TRUE or FALSE - overwrite import if it exists set bBusObjOverwrite \"TRUE\"    ;# TRUE or FALSE - overwrite bus objects in emxSpinnerBusObjects.tcl if exists set bBusRelOverwrite \"TRUE\"    ;# TRUE or FALSE - overwrite bus rels in emxSpinnerBusRels.tcl if exists set bTriggerAdd \"OFF\"           ;# ON or OFF - turns global create triggers on or off for bus objects and connections set bTriggerMod \"OFF\"           ;# ON or OFF - turns global modify triggers on or off for bus objects and connections set bTriggerDel \"OFF\"           ;# ON or OFF - turns global delete triggers on or off for bus objects and connections set bTriggerChk \"OFF\"           ;# ON or OFF - turns global checkin triggers on or off for bus object files set sReplaceSymbolic \"&?%$ ()\"  ;# characters to be trimmed when creating symbolic names set sDelimiter \"tab\"            ;# data delimiter: select tab, pipe, comma, carot, tilde or newline set sRangeDelim \"pipe\"          ;# attr range delimiter (use different one than data delimiter!) set bShowModOnly \"TRUE\"         ;# TRUE or FALSE - only modifications are logged when set to TRUE set bStreamLog \"FALSE\"          ;# TRUE or FALSE - output log to screen if TRUE set bShowTransaction \"FALSE\"    ;# TRUE or FALSE - show transaction boundaries during logging set bCompile \"FALSE\"             ;# TRUE or FALSE - compile JPO's added or modified if TRUE set bOverlay \"FALSE\"             ;# TRUE or FALSE - skip"
 0 2 "3/7/2016 10:09:10 AM" creator "  modify program emxSpinnerSettings.tcl !pipe code \"#************************************************************************  set sParentChild \"child\"        ;# parent or child - use parent or child fields in roles and groups - cannot use both! set bUseAssignmentField \"FALSE\" ;# TRUE or FALSE - process person assignments set in role/group data set bUseAccessField \"FALSE\"     ;# TRUE or FALSE - process user access assignments in rules and policy states set bRetainBusObject \"TRUE\"     ;# TRUE or FALSE - retain bus objects current states when resequencing policy states set bImportOverwrite \"TRUE\"    ;# TRUE or FALSE - overwrite import if it exists set bBusObjOverwrite \"FALSE\"    ;# TRUE or FALSE - overwrite bus objects in emxSpinnerBusObjects.tcl if exists set bBusRelOverwrite \"FALSE\"    ;# TRUE or FALSE - overwrite bus rels in emxSpinnerBusRels.tcl if exists set bTriggerAdd \"OFF\"           ;# ON or OFF - turns global create triggers on or off for bus objects and connections set bTriggerMod \"OFF\"           ;# ON or OFF - turns global modify triggers on or off for bus objects and connections set bTriggerDel \"OFF\"           ;# ON or OFF - turns global delete triggers on or off for bus objects and connections set bTriggerChk \"OFF\"           ;# ON or OFF - turns global checkin triggers on or off for bus object files set sReplaceSymbolic \"&?%$ ()\"  ;# characters to be trimmed when creating symbolic names set sDelimiter \"tab\"            ;# data delimiter: select tab, pipe, comma, carot, tilde or newline set sRangeDelim \"pipe\"          ;# attr range delimiter (use different one than data delimiter!) set bShowModOnly \"TRUE\"         ;# TRUE or FALSE - only modifications are logged when set to TRUE set bStreamLog \"FALSE\"          ;# TRUE or FALSE - output log to screen if TRUE set bShowTransaction \"FALSE\"    ;# TRUE or FALSE - show transaction boundaries during logging set bCompile \"FALSE\"             ;# TRUE or FALSE - compile JPO's added or modified if TRUE set bOverlay \"TRUE\"             ;# TRUE or FALSE - ski"
 0 2 "3/7/2016 10:30:15 AM" creator "  modify program emxSpinnerSettings.tcl !pipe code \"#************************************************************************  set sParentChild \"child\"        ;# parent or child - use parent or child fields in roles and groups - cannot use both! set bUseAssignmentField \"FALSE\" ;# TRUE or FALSE - process person assignments set in role/group data set bUseAccessField \"FALSE\"     ;# TRUE or FALSE - process user access assignments in rules and policy states set bRetainBusObject \"TRUE\"     ;# TRUE or FALSE - retain bus objects current states when resequencing policy states set bImportOverwrite \"TRUE\"    ;# TRUE or FALSE - overwrite import if it exists set bBusObjOverwrite \"FALSE\"    ;# TRUE or FALSE - overwrite bus objects in emxSpinnerBusObjects.tcl if exists set bBusRelOverwrite \"FALSE\"    ;# TRUE or FALSE - overwrite bus rels in emxSpinnerBusRels.tcl if exists set bTriggerAdd \"OFF\"           ;# ON or OFF - turns global create triggers on or off for bus objects and connections set bTriggerMod \"OFF\"           ;# ON or OFF - turns global modify triggers on or off for bus objects and connections set bTriggerDel \"OFF\"           ;# ON or OFF - turns global delete triggers on or off for bus objects and connections set bTriggerChk \"OFF\"           ;# ON or OFF - turns global checkin triggers on or off for bus object files set sReplaceSymbolic \"&?%$ ()\"  ;# characters to be trimmed when creating symbolic names set sDelimiter \"tab\"            ;# data delimiter: select tab, pipe, comma, carot, tilde or newline set sRangeDelim \"pipe\"          ;# attr range delimiter (use different one than data delimiter!) set bShowModOnly \"TRUE\"         ;# TRUE or FALSE - only modifications are logged when set to TRUE set bStreamLog \"FALSE\"          ;# TRUE or FALSE - output log to screen if TRUE set bShowTransaction \"FALSE\"    ;# TRUE or FALSE - show transaction boundaries during logging set bCompile \"FALSE\"             ;# TRUE or FALSE - compile JPO's added or modified if TRUE set bOverlay \"FALSE\"             ;# TRUE or FALSE - sk"
 0 2 "3/7/2016 10:56:05 AM" creator "  modify program emxSpinnerSettings.tcl !pipe code \"#************************************************************************  set sParentChild \"child\"        ;# parent or child - use parent or child fields in roles and groups - cannot use both! set bUseAssignmentField \"FALSE\" ;# TRUE or FALSE - process person assignments set in role/group data set bUseAccessField \"FALSE\"     ;# TRUE or FALSE - process user access assignments in rules and policy states set bRetainBusObject \"TRUE\"     ;# TRUE or FALSE - retain bus objects current states when resequencing policy states set bImportOverwrite \"TRUE\"    ;# TRUE or FALSE - overwrite import if it exists set bBusObjOverwrite \"FALSE\"    ;# TRUE or FALSE - overwrite bus objects in emxSpinnerBusObjects.tcl if exists set bBusRelOverwrite \"FALSE\"    ;# TRUE or FALSE - overwrite bus rels in emxSpinnerBusRels.tcl if exists set bTriggerAdd \"OFF\"           ;# ON or OFF - turns global create triggers on or off for bus objects and connections set bTriggerMod \"OFF\"           ;# ON or OFF - turns global modify triggers on or off for bus objects and connections set bTriggerDel \"OFF\"           ;# ON or OFF - turns global delete triggers on or off for bus objects and connections set bTriggerChk \"OFF\"           ;# ON or OFF - turns global checkin triggers on or off for bus object files set sReplaceSymbolic \"&?%$ ()\"  ;# characters to be trimmed when creating symbolic names set sDelimiter \"tab\"            ;# data delimiter: select tab, pipe, comma, carot, tilde or newline set sRangeDelim \"pipe\"          ;# attr range delimiter (use different one than data delimiter!) set bShowModOnly \"TRUE\"         ;# TRUE or FALSE - only modifications are logged when set to TRUE set bStreamLog \"FALSE\"          ;# TRUE or FALSE - output log to screen if TRUE set bShowTransaction \"FALSE\"    ;# TRUE or FALSE - show transaction boundaries during logging set bCompile \"FALSE\"             ;# TRUE or FALSE - compile JPO's added or modified if TRUE set bOverlay \"TRUE\"             ;# TRUE or FALSE - ski"
 0 2 "3/7/2016 11:12:35 AM" creator "  modify program emxSpinnerSettings.tcl !pipe code \"#************************************************************************  set sParentChild \"child\"        ;# parent or child - use parent or child fields in roles and groups - cannot use both! set bUseAssignmentField \"FALSE\" ;# TRUE or FALSE - process person assignments set in role/group data set bUseAccessField \"FALSE\"     ;# TRUE or FALSE - process user access assignments in rules and policy states set bRetainBusObject \"TRUE\"     ;# TRUE or FALSE - retain bus objects current states when resequencing policy states set bImportOverwrite \"TRUE\"    ;# TRUE or FALSE - overwrite import if it exists set bBusObjOverwrite \"FALSE\"    ;# TRUE or FALSE - overwrite bus objects in emxSpinnerBusObjects.tcl if exists set bBusRelOverwrite \"FALSE\"    ;# TRUE or FALSE - overwrite bus rels in emxSpinnerBusRels.tcl if exists set bTriggerAdd \"OFF\"           ;# ON or OFF - turns global create triggers on or off for bus objects and connections set bTriggerMod \"OFF\"           ;# ON or OFF - turns global modify triggers on or off for bus objects and connections set bTriggerDel \"OFF\"           ;# ON or OFF - turns global delete triggers on or off for bus objects and connections set bTriggerChk \"OFF\"           ;# ON or OFF - turns global checkin triggers on or off for bus object files set sReplaceSymbolic \"&?%$ ()\"  ;# characters to be trimmed when creating symbolic names set sDelimiter \"tab\"            ;# data delimiter: select tab, pipe, comma, carot, tilde or newline set sRangeDelim \"pipe\"          ;# attr range delimiter (use different one than data delimiter!) set bShowModOnly \"TRUE\"         ;# TRUE or FALSE - only modifications are logged when set to TRUE set bStreamLog \"FALSE\"          ;# TRUE or FALSE - output log to screen if TRUE set bShowTransaction \"FALSE\"    ;# TRUE or FALSE - show transaction boundaries during logging set bCompile \"FALSE\"             ;# TRUE or FALSE - compile JPO's added or modified if TRUE set bOverlay \"FALSE\"             ;# TRUE or FALSE - sk"
 0 2 "3/15/2016 4:30:57 PM" creator "  modify program emxSpinnerSettings.tcl !pipe code \"#************************************************************************  set sParentChild \"child\"        ;# parent or child - use parent or child fields in roles and groups - cannot use both! set bUseAssignmentField \"FALSE\" ;# TRUE or FALSE - process person assignments set in role/group data set bUseAccessField \"FALSE\"     ;# TRUE or FALSE - process user access assignments in rules and policy states set bRetainBusObject \"TRUE\"     ;# TRUE or FALSE - retain bus objects current states when resequencing policy states set bImportOverwrite \"FALSE\"    ;# TRUE or FALSE - overwrite import if it exists set bBusObjOverwrite \"FALSE\"    ;# TRUE or FALSE - overwrite bus objects in emxSpinnerBusObjects.tcl if exists set bBusRelOverwrite \"FALSE\"    ;# TRUE or FALSE - overwrite bus rels in emxSpinnerBusRels.tcl if exists set bTriggerAdd \"OFF\"           ;# ON or OFF - turns global create triggers on or off for bus objects and connections set bTriggerMod \"OFF\"           ;# ON or OFF - turns global modify triggers on or off for bus objects and connections set bTriggerDel \"OFF\"           ;# ON or OFF - turns global delete triggers on or off for bus objects and connections set bTriggerChk \"OFF\"           ;# ON or OFF - turns global checkin triggers on or off for bus object files set sReplaceSymbolic \"&?%$ ()\"  ;# characters to be trimmed when creating symbolic names set sDelimiter \"tab\"            ;# data delimiter: select tab, pipe, comma, carot, tilde or newline set sRangeDelim \"pipe\"          ;# attr range delimiter (use different one than data delimiter!) set bShowModOnly \"TRUE\"         ;# TRUE or FALSE - only modifications are logged when set to TRUE set bStreamLog \"FALSE\"          ;# TRUE or FALSE - output log to screen if TRUE set bShowTransaction \"FALSE\"    ;# TRUE or FALSE - show transaction boundaries during logging set bCompile \"FALSE\"             ;# TRUE or FALSE - compile JPO's added or modified if TRUE set bOverlay \"FALSE\"             ;# TRUE or FALSE - s"
 0 2 "3/15/2016 4:31:05 PM" creator "  modify program emxSpinnerSettings.tcl !pipe;"
 0 2 "4/21/2016 9:45:47 AM" creator "  modify program emxSpinnerSettings.tcl !pipe code \"#************************************************************************  set sParentChild \"child\"        ;# parent or child - use parent or child fields in roles and groups - cannot use both! set bUseAssignmentField \"FALSE\" ;# TRUE or FALSE - process person assignments set in role/group data set bUseAccessField \"FALSE\"     ;# TRUE or FALSE - process user access assignments in rules and policy states set bRetainBusObject \"TRUE\"     ;# TRUE or FALSE - retain bus objects current states when resequencing policy states set bImportOverwrite \"TRUE\"    ;# TRUE or FALSE - overwrite import if it exists set bBusObjOverwrite \"TRUE\"    ;# TRUE or FALSE - overwrite bus objects in emxSpinnerBusObjects.tcl if exists set bBusRelOverwrite \"TRUE\"    ;# TRUE or FALSE - overwrite bus rels in emxSpinnerBusRels.tcl if exists set bTriggerAdd \"OFF\"           ;# ON or OFF - turns global create triggers on or off for bus objects and connections set bTriggerMod \"OFF\"           ;# ON or OFF - turns global modify triggers on or off for bus objects and connections set bTriggerDel \"OFF\"           ;# ON or OFF - turns global delete triggers on or off for bus objects and connections set bTriggerChk \"OFF\"           ;# ON or OFF - turns global checkin triggers on or off for bus object files set sReplaceSymbolic \"&?%$ ()\"  ;# characters to be trimmed when creating symbolic names set sDelimiter \"tab\"            ;# data delimiter: select tab, pipe, comma, carot, tilde or newline set sRangeDelim \"pipe\"          ;# attr range delimiter (use different one than data delimiter!) set bShowModOnly \"TRUE\"         ;# TRUE or FALSE - only modifications are logged when set to TRUE set bStreamLog \"FALSE\"          ;# TRUE or FALSE - output log to screen if TRUE set bShowTransaction \"FALSE\"    ;# TRUE or FALSE - show transaction boundaries during logging set bCompile \"FALSE\"             ;# TRUE or FALSE - compile JPO's added or modified if TRUE set bOverlay \"TRUE\"             ;# TRUE or FALSE - skip "
 0 2 "6/17/2016 11:27:29 AM" creator "  modify program emxSpinnerSettings.tcl !pipe code \"#************************************************************************  set sParentChild \"child\"        ;# parent or child - use parent or child fields in roles and groups - cannot use both! set bUseAssignmentField \"FALSE\" ;# TRUE or FALSE - process person assignments set in role/group data set bUseAccessField \"FALSE\"     ;# TRUE or FALSE - process user access assignments in rules and policy states set bRetainBusObject \"TRUE\"     ;# TRUE or FALSE - retain bus objects current states when resequencing policy states set bImportOverwrite \"TRUE\"    ;# TRUE or FALSE - overwrite import if it exists set bBusObjOverwrite \"TRUE\"    ;# TRUE or FALSE - overwrite bus objects in emxSpinnerBusObjects.tcl if exists set bBusRelOverwrite \"TRUE\"    ;# TRUE or FALSE - overwrite bus rels in emxSpinnerBusRels.tcl if exists set bTriggerAdd \"OFF\"           ;# ON or OFF - turns global create triggers on or off for bus objects and connections set bTriggerMod \"OFF\"           ;# ON or OFF - turns global modify triggers on or off for bus objects and connections set bTriggerDel \"OFF\"           ;# ON or OFF - turns global delete triggers on or off for bus objects and connections set bTriggerChk \"OFF\"           ;# ON or OFF - turns global checkin triggers on or off for bus object files set sReplaceSymbolic \"&?%$ ()\"  ;# characters to be trimmed when creating symbolic names set sDelimiter \"tab\"            ;# data delimiter: select tab, pipe, comma, carot, tilde or newline set sRangeDelim \"pipe\"          ;# attr range delimiter (use different one than data delimiter!) set bShowModOnly \"TRUE\"         ;# TRUE or FALSE - only modifications are logged when set to TRUE set bStreamLog \"FALSE\"          ;# TRUE or FALSE - output log to screen if TRUE set bShowTransaction \"FALSE\"    ;# TRUE or FALSE - show transaction boundaries during logging set bCompile \"FALSE\"             ;# TRUE or FALSE - compile JPO's added or modified if TRUE set bOverlay \"FALSE\"             ;# TRUE or FALSE - skip"
 0 2 "6/17/2016 12:12:44 PM" creator "  modify program emxSpinnerSettings.tcl !pipe code \"#************************************************************************  set sParentChild \"child\"        ;# parent or child - use parent or child fields in roles and groups - cannot use both! set bUseAssignmentField \"FALSE\" ;# TRUE or FALSE - process person assignments set in role/group data set bUseAccessField \"FALSE\"     ;# TRUE or FALSE - process user access assignments in rules and policy states set bRetainBusObject \"TRUE\"     ;# TRUE or FALSE - retain bus objects current states when resequencing policy states set bImportOverwrite \"TRUE\"    ;# TRUE or FALSE - overwrite import if it exists set bBusObjOverwrite \"TRUE\"    ;# TRUE or FALSE - overwrite bus objects in emxSpinnerBusObjects.tcl if exists set bBusRelOverwrite \"TRUE\"    ;# TRUE or FALSE - overwrite bus rels in emxSpinnerBusRels.tcl if exists set bTriggerAdd \"OFF\"           ;# ON or OFF - turns global create triggers on or off for bus objects and connections set bTriggerMod \"OFF\"           ;# ON or OFF - turns global modify triggers on or off for bus objects and connections set bTriggerDel \"OFF\"           ;# ON or OFF - turns global delete triggers on or off for bus objects and connections set bTriggerChk \"OFF\"           ;# ON or OFF - turns global checkin triggers on or off for bus object files set sReplaceSymbolic \"&?%$ ()\"  ;# characters to be trimmed when creating symbolic names set sDelimiter \"tab\"            ;# data delimiter: select tab, pipe, comma, carot, tilde or newline set sRangeDelim \"pipe\"          ;# attr range delimiter (use different one than data delimiter!) set bShowModOnly \"TRUE\"         ;# TRUE or FALSE - only modifications are logged when set to TRUE set bStreamLog \"FALSE\"          ;# TRUE or FALSE - output log to screen if TRUE set bShowTransaction \"FALSE\"    ;# TRUE or FALSE - show transaction boundaries during logging set bCompile \"FALSE\"             ;# TRUE or FALSE - compile JPO's added or modified if TRUE set bOverlay \"FALSE\"             ;# TRUE or FALSE - skip"
 0 2 "6/17/2016 12:13:56 PM" creator "  modify program emxSpinnerSettings.tcl !pipe code \"#************************************************************************  set sParentChild \"child\"        ;# parent or child - use parent or child fields in roles and groups - cannot use both! set bUseAssignmentField \"FALSE\" ;# TRUE or FALSE - process person assignments set in role/group data set bUseAccessField \"FALSE\"     ;# TRUE or FALSE - process user access assignments in rules and policy states set bRetainBusObject \"TRUE\"     ;# TRUE or FALSE - retain bus objects current states when resequencing policy states set bImportOverwrite \"TRUE\"    ;# TRUE or FALSE - overwrite import if it exists set bBusObjOverwrite \"TRUE\"    ;# TRUE or FALSE - overwrite bus objects in emxSpinnerBusObjects.tcl if exists set bBusRelOverwrite \"TRUE\"    ;# TRUE or FALSE - overwrite bus rels in emxSpinnerBusRels.tcl if exists set bTriggerAdd \"OFF\"           ;# ON or OFF - turns global create triggers on or off for bus objects and connections set bTriggerMod \"OFF\"           ;# ON or OFF - turns global modify triggers on or off for bus objects and connections set bTriggerDel \"OFF\"           ;# ON or OFF - turns global delete triggers on or off for bus objects and connections set bTriggerChk \"OFF\"           ;# ON or OFF - turns global checkin triggers on or off for bus object files set sReplaceSymbolic \"&?%$ ()\"  ;# characters to be trimmed when creating symbolic names set sDelimiter \"tab\"            ;# data delimiter: select tab, pipe, comma, carot, tilde or newline set sRangeDelim \"pipe\"          ;# attr range delimiter (use different one than data delimiter!) set bShowModOnly \"TRUE\"         ;# TRUE or FALSE - only modifications are logged when set to TRUE set bStreamLog \"FALSE\"          ;# TRUE or FALSE - output log to screen if TRUE set bShowTransaction \"FALSE\"    ;# TRUE or FALSE - show transaction boundaries during logging set bCompile \"FALSE\"             ;# TRUE or FALSE - compile JPO's added or modified if TRUE set bOverlay \"TRUE\"             ;# TRUE or FALSE - skip "
 0 2 "6/17/2016 12:15:17 PM" creator "  modify program emxSpinnerSettings.tcl !pipe code \"#************************************************************************  set sParentChild \"child\"        ;# parent or child - use parent or child fields in roles and groups - cannot use both! set bUseAssignmentField \"FALSE\" ;# TRUE or FALSE - process person assignments set in role/group data set bUseAccessField \"FALSE\"     ;# TRUE or FALSE - process user access assignments in rules and policy states set bRetainBusObject \"TRUE\"     ;# TRUE or FALSE - retain bus objects current states when resequencing policy states set bImportOverwrite \"TRUE\"    ;# TRUE or FALSE - overwrite import if it exists set bBusObjOverwrite \"TRUE\"    ;# TRUE or FALSE - overwrite bus objects in emxSpinnerBusObjects.tcl if exists set bBusRelOverwrite \"TRUE\"    ;# TRUE or FALSE - overwrite bus rels in emxSpinnerBusRels.tcl if exists set bTriggerAdd \"OFF\"           ;# ON or OFF - turns global create triggers on or off for bus objects and connections set bTriggerMod \"OFF\"           ;# ON or OFF - turns global modify triggers on or off for bus objects and connections set bTriggerDel \"OFF\"           ;# ON or OFF - turns global delete triggers on or off for bus objects and connections set bTriggerChk \"OFF\"           ;# ON or OFF - turns global checkin triggers on or off for bus object files set sReplaceSymbolic \"&?%$ ()\"  ;# characters to be trimmed when creating symbolic names set sDelimiter \"tab\"            ;# data delimiter: select tab, pipe, comma, carot, tilde or newline set sRangeDelim \"pipe\"          ;# attr range delimiter (use different one than data delimiter!) set bShowModOnly \"TRUE\"         ;# TRUE or FALSE - only modifications are logged when set to TRUE set bStreamLog \"FALSE\"          ;# TRUE or FALSE - output log to screen if TRUE set bShowTransaction \"FALSE\"    ;# TRUE or FALSE - show transaction boundaries during logging set bCompile \"FALSE\"             ;# TRUE or FALSE - compile JPO's added or modified if TRUE set bOverlay \"TRUE\"             ;# TRUE or FALSE - skip "
 0 2 "7/28/2016 10:51:01 AM" creator "  modify program emxSpinnerSettings.tcl !pipe code \"#************************************************************************  set sParentChild \"child\"        ;# parent or child - use parent or child fields in roles and groups - cannot use both! set bUseAssignmentField \"FALSE\" ;# TRUE or FALSE - process person assignments set in role/group data set bUseAccessField \"FALSE\"     ;# TRUE or FALSE - process user access assignments in rules and policy states set bRetainBusObject \"TRUE\"     ;# TRUE or FALSE - retain bus objects current states when resequencing policy states set bImportOverwrite \"TRUE\"    ;# TRUE or FALSE - overwrite import if it exists set bBusObjOverwrite \"TRUE\"    ;# TRUE or FALSE - overwrite bus objects in emxSpinnerBusObjects.tcl if exists set bBusRelOverwrite \"TRUE\"    ;# TRUE or FALSE - overwrite bus rels in emxSpinnerBusRels.tcl if exists set bTriggerAdd \"OFF\"           ;# ON or OFF - turns global create triggers on or off for bus objects and connections set bTriggerMod \"OFF\"           ;# ON or OFF - turns global modify triggers on or off for bus objects and connections set bTriggerDel \"OFF\"           ;# ON or OFF - turns global delete triggers on or off for bus objects and connections set bTriggerChk \"OFF\"           ;# ON or OFF - turns global checkin triggers on or off for bus object files set sReplaceSymbolic \"&?%$ ()\"  ;# characters to be trimmed when creating symbolic names set sDelimiter \"tab\"            ;# data delimiter: select tab, pipe, comma, carot, tilde or newline set sRangeDelim \"pipe\"          ;# attr range delimiter (use different one than data delimiter!) set bShowModOnly \"TRUE\"         ;# TRUE or FALSE - only modifications are logged when set to TRUE set bStreamLog \"FALSE\"          ;# TRUE or FALSE - output log to screen if TRUE set bShowTransaction \"FALSE\"    ;# TRUE or FALSE - show transaction boundaries during logging set bCompile \"FALSE\"             ;# TRUE or FALSE - compile JPO's added or modified if TRUE set bOverlay \"FALSE\"             ;# TRUE or FALSE - skip"
 0 2 "9/4/2016 8:28:19 PM" creator "  modify program emxSpinnerSettings.tcl !pipe code \"#************************************************************************  set sParentChild \"child\"        ;# parent or child - use parent or child fields in roles and groups - cannot use both! set bUseAssignmentField \"FALSE\" ;# TRUE or FALSE - process person assignments set in role/group data set bUseAccessField \"FALSE\"     ;# TRUE or FALSE - process user access assignments in rules and policy states set bRetainBusObject \"TRUE\"     ;# TRUE or FALSE - retain bus objects current states when resequencing policy states set bImportOverwrite \"TRUE\"    ;# TRUE or FALSE - overwrite import if it exists set bBusObjOverwrite \"TRUE\"    ;# TRUE or FALSE - overwrite bus objects in emxSpinnerBusObjects.tcl if exists set bBusRelOverwrite \"TRUE\"    ;# TRUE or FALSE - overwrite bus rels in emxSpinnerBusRels.tcl if exists set bTriggerAdd \"OFF\"           ;# ON or OFF - turns global create triggers on or off for bus objects and connections set bTriggerMod \"OFF\"           ;# ON or OFF - turns global modify triggers on or off for bus objects and connections set bTriggerDel \"OFF\"           ;# ON or OFF - turns global delete triggers on or off for bus objects and connections set bTriggerChk \"OFF\"           ;# ON or OFF - turns global checkin triggers on or off for bus object files set sReplaceSymbolic \"&?%$ ()\"  ;# characters to be trimmed when creating symbolic names set sDelimiter \"tab\"            ;# data delimiter: select tab, pipe, comma, carot, tilde or newline set sRangeDelim \"pipe\"          ;# attr range delimiter (use different one than data delimiter!) set bShowModOnly \"TRUE\"         ;# TRUE or FALSE - only modifications are logged when set to TRUE set bStreamLog \"FALSE\"          ;# TRUE or FALSE - output log to screen if TRUE set bShowTransaction \"FALSE\"    ;# TRUE or FALSE - show transaction boundaries during logging set bCompile \"FALSE\"             ;# TRUE or FALSE - compile JPO's added or modified if TRUE set bOverlay \"TRUE\"             ;# TRUE or FALSE - skip "
 0 2 "9/4/2016 8:44:00 PM" creator "  modify program emxSpinnerSettings.tcl !pipe code \"#************************************************************************  set sParentChild \"child\"        ;# parent or child - use parent or child fields in roles and groups - cannot use both! set bUseAssignmentField \"FALSE\" ;# TRUE or FALSE - process person assignments set in role/group data set bUseAccessField \"FALSE\"     ;# TRUE or FALSE - process user access assignments in rules and policy states set bRetainBusObject \"TRUE\"     ;# TRUE or FALSE - retain bus objects current states when resequencing policy states set bImportOverwrite \"TRUE\"    ;# TRUE or FALSE - overwrite import if it exists set bBusObjOverwrite \"TRUE\"    ;# TRUE or FALSE - overwrite bus objects in emxSpinnerBusObjects.tcl if exists set bBusRelOverwrite \"TRUE\"    ;# TRUE or FALSE - overwrite bus rels in emxSpinnerBusRels.tcl if exists set bTriggerAdd \"OFF\"           ;# ON or OFF - turns global create triggers on or off for bus objects and connections set bTriggerMod \"OFF\"           ;# ON or OFF - turns global modify triggers on or off for bus objects and connections set bTriggerDel \"OFF\"           ;# ON or OFF - turns global delete triggers on or off for bus objects and connections set bTriggerChk \"OFF\"           ;# ON or OFF - turns global checkin triggers on or off for bus object files set sReplaceSymbolic \"&?%$ ()\"  ;# characters to be trimmed when creating symbolic names set sDelimiter \"tab\"            ;# data delimiter: select tab, pipe, comma, carot, tilde or newline set sRangeDelim \"pipe\"          ;# attr range delimiter (use different one than data delimiter!) set bShowModOnly \"TRUE\"         ;# TRUE or FALSE - only modifications are logged when set to TRUE set bStreamLog \"FALSE\"          ;# TRUE or FALSE - output log to screen if TRUE set bShowTransaction \"FALSE\"    ;# TRUE or FALSE - show transaction boundaries during logging set bCompile \"FALSE\"             ;# TRUE or FALSE - compile JPO's added or modified if TRUE set bOverlay \"FALSE\"             ;# TRUE or FALSE - skip"
 0 2 "10/18/2016 6:44:20 PM" creator "  modify program emxSpinnerSettings.tcl !pipe code \"#************************************************************************  set sParentChild \"child\"        ;# parent or child - use parent or child fields in roles and groups - cannot use both! set bUseAssignmentField \"FALSE\" ;# TRUE or FALSE - process person assignments set in role/group data set bUseAccessField \"FALSE\"     ;# TRUE or FALSE - process user access assignments in rules and policy states set bRetainBusObject \"TRUE\"     ;# TRUE or FALSE - retain bus objects current states when resequencing policy states set bImportOverwrite \"TRUE\"    ;# TRUE or FALSE - overwrite import if it exists set bBusObjOverwrite \"TRUE\"    ;# TRUE or FALSE - overwrite bus objects in emxSpinnerBusObjects.tcl if exists set bBusRelOverwrite \"TRUE\"    ;# TRUE or FALSE - overwrite bus rels in emxSpinnerBusRels.tcl if exists set bTriggerAdd \"OFF\"           ;# ON or OFF - turns global create triggers on or off for bus objects and connections set bTriggerMod \"OFF\"           ;# ON or OFF - turns global modify triggers on or off for bus objects and connections set bTriggerDel \"OFF\"           ;# ON or OFF - turns global delete triggers on or off for bus objects and connections set bTriggerChk \"OFF\"           ;# ON or OFF - turns global checkin triggers on or off for bus object files set sReplaceSymbolic \"&?%$ ()\"  ;# characters to be trimmed when creating symbolic names set sDelimiter \"tab\"            ;# data delimiter: select tab, pipe, comma, carot, tilde or newline set sRangeDelim \"pipe\"          ;# attr range delimiter (use different one than data delimiter!) set bShowModOnly \"TRUE\"         ;# TRUE or FALSE - only modifications are logged when set to TRUE set bStreamLog \"FALSE\"          ;# TRUE or FALSE - output log to screen if TRUE set bShowTransaction \"FALSE\"    ;# TRUE or FALSE - show transaction boundaries during logging set bCompile \"FALSE\"             ;# TRUE or FALSE - compile JPO's added or modified if TRUE set bOverlay \"TRUE\"             ;# TRUE or FALSE - skip "
 0 2 "10/18/2016 8:58:20 PM" creator "  modify program emxSpinnerSettings.tcl !pipe code \"#************************************************************************  set sParentChild \"child\"        ;# parent or child - use parent or child fields in roles and groups - cannot use both! set bUseAssignmentField \"FALSE\" ;# TRUE or FALSE - process person assignments set in role/group data set bUseAccessField \"FALSE\"     ;# TRUE or FALSE - process user access assignments in rules and policy states set bRetainBusObject \"TRUE\"     ;# TRUE or FALSE - retain bus objects current states when resequencing policy states set bImportOverwrite \"TRUE\"    ;# TRUE or FALSE - overwrite import if it exists set bBusObjOverwrite \"TRUE\"    ;# TRUE or FALSE - overwrite bus objects in emxSpinnerBusObjects.tcl if exists set bBusRelOverwrite \"TRUE\"    ;# TRUE or FALSE - overwrite bus rels in emxSpinnerBusRels.tcl if exists set bTriggerAdd \"OFF\"           ;# ON or OFF - turns global create triggers on or off for bus objects and connections set bTriggerMod \"OFF\"           ;# ON or OFF - turns global modify triggers on or off for bus objects and connections set bTriggerDel \"OFF\"           ;# ON or OFF - turns global delete triggers on or off for bus objects and connections set bTriggerChk \"OFF\"           ;# ON or OFF - turns global checkin triggers on or off for bus object files set sReplaceSymbolic \"&?%$ ()\"  ;# characters to be trimmed when creating symbolic names set sDelimiter \"tab\"            ;# data delimiter: select tab, pipe, comma, carot, tilde or newline set sRangeDelim \"pipe\"          ;# attr range delimiter (use different one than data delimiter!) set bShowModOnly \"TRUE\"         ;# TRUE or FALSE - only modifications are logged when set to TRUE set bStreamLog \"FALSE\"          ;# TRUE or FALSE - output log to screen if TRUE set bShowTransaction \"FALSE\"    ;# TRUE or FALSE - show transaction boundaries during logging set bCompile \"FALSE\"             ;# TRUE or FALSE - compile JPO's added or modified if TRUE set bOverlay \"FALSE\"             ;# TRUE or FALSE - skip"
 0 2 "11/9/2016 11:32:21 AM" creator "  modify program emxSpinnerSettings.tcl !pipe code \"#************************************************************************  set sParentChild \"child\"        ;# parent or child - use parent or child fields in roles and groups - cannot use both! set bUseAssignmentField \"FALSE\" ;# TRUE or FALSE - process person assignments set in role/group data set bUseAccessField \"FALSE\"     ;# TRUE or FALSE - process user access assignments in rules and policy states set bRetainBusObject \"TRUE\"     ;# TRUE or FALSE - retain bus objects current states when resequencing policy states set bImportOverwrite \"TRUE\"    ;# TRUE or FALSE - overwrite import if it exists set bBusObjOverwrite \"TRUE\"    ;# TRUE or FALSE - overwrite bus objects in emxSpinnerBusObjects.tcl if exists set bBusRelOverwrite \"TRUE\"    ;# TRUE or FALSE - overwrite bus rels in emxSpinnerBusRels.tcl if exists set bTriggerAdd \"OFF\"           ;# ON or OFF - turns global create triggers on or off for bus objects and connections set bTriggerMod \"OFF\"           ;# ON or OFF - turns global modify triggers on or off for bus objects and connections set bTriggerDel \"OFF\"           ;# ON or OFF - turns global delete triggers on or off for bus objects and connections set bTriggerChk \"OFF\"           ;# ON or OFF - turns global checkin triggers on or off for bus object files set sReplaceSymbolic \"&?%$ ()\"  ;# characters to be trimmed when creating symbolic names set sDelimiter \"tab\"            ;# data delimiter: select tab, pipe, comma, carot, tilde or newline set sRangeDelim \"pipe\"          ;# attr range delimiter (use different one than data delimiter!) set bShowModOnly \"TRUE\"         ;# TRUE or FALSE - only modifications are logged when set to TRUE set bStreamLog \"FALSE\"          ;# TRUE or FALSE - output log to screen if TRUE set bShowTransaction \"FALSE\"    ;# TRUE or FALSE - show transaction boundaries during logging set bCompile \"FALSE\"             ;# TRUE or FALSE - compile JPO's added or modified if TRUE set bOverlay \"TRUE\"             ;# TRUE or FALSE - skip "
 0 2 "11/9/2016 12:57:52 PM" creator "  modify program emxSpinnerSettings.tcl !pipe code \"#************************************************************************  set sParentChild \"child\"        ;# parent or child - use parent or child fields in roles and groups - cannot use both! set bUseAssignmentField \"FALSE\" ;# TRUE or FALSE - process person assignments set in role/group data set bUseAccessField \"FALSE\"     ;# TRUE or FALSE - process user access assignments in rules and policy states set bRetainBusObject \"TRUE\"     ;# TRUE or FALSE - retain bus objects current states when resequencing policy states set bImportOverwrite \"TRUE\"    ;# TRUE or FALSE - overwrite import if it exists set bBusObjOverwrite \"TRUE\"    ;# TRUE or FALSE - overwrite bus objects in emxSpinnerBusObjects.tcl if exists set bBusRelOverwrite \"TRUE\"    ;# TRUE or FALSE - overwrite bus rels in emxSpinnerBusRels.tcl if exists set bTriggerAdd \"OFF\"           ;# ON or OFF - turns global create triggers on or off for bus objects and connections set bTriggerMod \"OFF\"           ;# ON or OFF - turns global modify triggers on or off for bus objects and connections set bTriggerDel \"OFF\"           ;# ON or OFF - turns global delete triggers on or off for bus objects and connections set bTriggerChk \"OFF\"           ;# ON or OFF - turns global checkin triggers on or off for bus object files set sReplaceSymbolic \"&?%$ ()\"  ;# characters to be trimmed when creating symbolic names set sDelimiter \"tab\"            ;# data delimiter: select tab, pipe, comma, carot, tilde or newline set sRangeDelim \"pipe\"          ;# attr range delimiter (use different one than data delimiter!) set bShowModOnly \"TRUE\"         ;# TRUE or FALSE - only modifications are logged when set to TRUE set bStreamLog \"FALSE\"          ;# TRUE or FALSE - output log to screen if TRUE set bShowTransaction \"FALSE\"    ;# TRUE or FALSE - show transaction boundaries during logging set bCompile \"FALSE\"             ;# TRUE or FALSE - compile JPO's added or modified if TRUE set bOverlay \"FALSE\"             ;# TRUE or FALSE - skip"
 0 2 "11/25/2016 3:37:48 PM" creator "  modify program emxSpinnerSettings.tcl !pipe code \"#************************************************************************  set sParentChild \"child\"        ;# parent or child - use parent or child fields in roles and groups - cannot use both! set bUseAssignmentField \"FALSE\" ;# TRUE or FALSE - process person assignments set in role/group data set bUseAccessField \"FALSE\"     ;# TRUE or FALSE - process user access assignments in rules and policy states set bRetainBusObject \"TRUE\"     ;# TRUE or FALSE - retain bus objects current states when resequencing policy states set bImportOverwrite \"TRUE\"    ;# TRUE or FALSE - overwrite import if it exists set bBusObjOverwrite \"TRUE\"    ;# TRUE or FALSE - overwrite bus objects in emxSpinnerBusObjects.tcl if exists set bBusRelOverwrite \"TRUE\"    ;# TRUE or FALSE - overwrite bus rels in emxSpinnerBusRels.tcl if exists set bTriggerAdd \"OFF\"           ;# ON or OFF - turns global create triggers on or off for bus objects and connections set bTriggerMod \"OFF\"           ;# ON or OFF - turns global modify triggers on or off for bus objects and connections set bTriggerDel \"OFF\"           ;# ON or OFF - turns global delete triggers on or off for bus objects and connections set bTriggerChk \"OFF\"           ;# ON or OFF - turns global checkin triggers on or off for bus object files set sReplaceSymbolic \"&?%$ ()\"  ;# characters to be trimmed when creating symbolic names set sDelimiter \"tab\"            ;# data delimiter: select tab, pipe, comma, carot, tilde or newline set sRangeDelim \"pipe\"          ;# attr range delimiter (use different one than data delimiter!) set bShowModOnly \"TRUE\"         ;# TRUE or FALSE - only modifications are logged when set to TRUE set bStreamLog \"FALSE\"          ;# TRUE or FALSE - output log to screen if TRUE set bShowTransaction \"FALSE\"    ;# TRUE or FALSE - show transaction boundaries during logging set bCompile \"FALSE\"             ;# TRUE or FALSE - compile JPO's added or modified if TRUE set bOverlay \"TRUE\"             ;# TRUE or FALSE - skip "
 0 2 "11/25/2016 3:53:21 PM" creator "  modify program emxSpinnerSettings.tcl !pipe code \"#************************************************************************  set sParentChild \"child\"        ;# parent or child - use parent or child fields in roles and groups - cannot use both! set bUseAssignmentField \"FALSE\" ;# TRUE or FALSE - process person assignments set in role/group data set bUseAccessField \"FALSE\"     ;# TRUE or FALSE - process user access assignments in rules and policy states set bRetainBusObject \"TRUE\"     ;# TRUE or FALSE - retain bus objects current states when resequencing policy states set bImportOverwrite \"TRUE\"    ;# TRUE or FALSE - overwrite import if it exists set bBusObjOverwrite \"TRUE\"    ;# TRUE or FALSE - overwrite bus objects in emxSpinnerBusObjects.tcl if exists set bBusRelOverwrite \"TRUE\"    ;# TRUE or FALSE - overwrite bus rels in emxSpinnerBusRels.tcl if exists set bTriggerAdd \"OFF\"           ;# ON or OFF - turns global create triggers on or off for bus objects and connections set bTriggerMod \"OFF\"           ;# ON or OFF - turns global modify triggers on or off for bus objects and connections set bTriggerDel \"OFF\"           ;# ON or OFF - turns global delete triggers on or off for bus objects and connections set bTriggerChk \"OFF\"           ;# ON or OFF - turns global checkin triggers on or off for bus object files set sReplaceSymbolic \"&?%$ ()\"  ;# characters to be trimmed when creating symbolic names set sDelimiter \"tab\"            ;# data delimiter: select tab, pipe, comma, carot, tilde or newline set sRangeDelim \"pipe\"          ;# attr range delimiter (use different one than data delimiter!) set bShowModOnly \"TRUE\"         ;# TRUE or FALSE - only modifications are logged when set to TRUE set bStreamLog \"FALSE\"          ;# TRUE or FALSE - output log to screen if TRUE set bShowTransaction \"FALSE\"    ;# TRUE or FALSE - show transaction boundaries during logging set bCompile \"FALSE\"             ;# TRUE or FALSE - compile JPO's added or modified if TRUE set bOverlay \"FALSE\"             ;# TRUE or FALSE - skip"
 0 2 "12/6/2016 5:02:12 PM" creator "  modify program emxSpinnerSettings.tcl !pipe code \"#************************************************************************  set sParentChild \"child\"        ;# parent or child - use parent or child fields in roles and groups - cannot use both! set bUseAssignmentField \"FALSE\" ;# TRUE or FALSE - process person assignments set in role/group data set bUseAccessField \"FALSE\"     ;# TRUE or FALSE - process user access assignments in rules and policy states set bRetainBusObject \"TRUE\"     ;# TRUE or FALSE - retain bus objects current states when resequencing policy states set bImportOverwrite \"TRUE\"    ;# TRUE or FALSE - overwrite import if it exists set bBusObjOverwrite \"TRUE\"    ;# TRUE or FALSE - overwrite bus objects in emxSpinnerBusObjects.tcl if exists set bBusRelOverwrite \"TRUE\"    ;# TRUE or FALSE - overwrite bus rels in emxSpinnerBusRels.tcl if exists set bTriggerAdd \"OFF\"           ;# ON or OFF - turns global create triggers on or off for bus objects and connections set bTriggerMod \"OFF\"           ;# ON or OFF - turns global modify triggers on or off for bus objects and connections set bTriggerDel \"OFF\"           ;# ON or OFF - turns global delete triggers on or off for bus objects and connections set bTriggerChk \"OFF\"           ;# ON or OFF - turns global checkin triggers on or off for bus object files set sReplaceSymbolic \"&?%$ ()\"  ;# characters to be trimmed when creating symbolic names set sDelimiter \"tab\"            ;# data delimiter: select tab, pipe, comma, carot, tilde or newline set sRangeDelim \"pipe\"          ;# attr range delimiter (use different one than data delimiter!) set bShowModOnly \"TRUE\"         ;# TRUE or FALSE - only modifications are logged when set to TRUE set bStreamLog \"FALSE\"          ;# TRUE or FALSE - output log to screen if TRUE set bShowTransaction \"FALSE\"    ;# TRUE or FALSE - show transaction boundaries during logging set bCompile \"FALSE\"             ;# TRUE or FALSE - compile JPO's added or modified if TRUE set bOverlay \"TRUE\"             ;# TRUE or FALSE - skip "
 0 2 "12/6/2016 5:19:29 PM" creator "  modify program emxSpinnerSettings.tcl !pipe code \"#************************************************************************  set sParentChild \"child\"        ;# parent or child - use parent or child fields in roles and groups - cannot use both! set bUseAssignmentField \"FALSE\" ;# TRUE or FALSE - process person assignments set in role/group data set bUseAccessField \"FALSE\"     ;# TRUE or FALSE - process user access assignments in rules and policy states set bRetainBusObject \"TRUE\"     ;# TRUE or FALSE - retain bus objects current states when resequencing policy states set bImportOverwrite \"TRUE\"    ;# TRUE or FALSE - overwrite import if it exists set bBusObjOverwrite \"TRUE\"    ;# TRUE or FALSE - overwrite bus objects in emxSpinnerBusObjects.tcl if exists set bBusRelOverwrite \"TRUE\"    ;# TRUE or FALSE - overwrite bus rels in emxSpinnerBusRels.tcl if exists set bTriggerAdd \"OFF\"           ;# ON or OFF - turns global create triggers on or off for bus objects and connections set bTriggerMod \"OFF\"           ;# ON or OFF - turns global modify triggers on or off for bus objects and connections set bTriggerDel \"OFF\"           ;# ON or OFF - turns global delete triggers on or off for bus objects and connections set bTriggerChk \"OFF\"           ;# ON or OFF - turns global checkin triggers on or off for bus object files set sReplaceSymbolic \"&?%$ ()\"  ;# characters to be trimmed when creating symbolic names set sDelimiter \"tab\"            ;# data delimiter: select tab, pipe, comma, carot, tilde or newline set sRangeDelim \"pipe\"          ;# attr range delimiter (use different one than data delimiter!) set bShowModOnly \"TRUE\"         ;# TRUE or FALSE - only modifications are logged when set to TRUE set bStreamLog \"FALSE\"          ;# TRUE or FALSE - output log to screen if TRUE set bShowTransaction \"FALSE\"    ;# TRUE or FALSE - show transaction boundaries during logging set bCompile \"FALSE\"             ;# TRUE or FALSE - compile JPO's added or modified if TRUE set bOverlay \"FALSE\"             ;# TRUE or FALSE - skip"
 0 2 "2/4/2017 9:48:04 AM" creator "  modify program emxSpinnerSettings.tcl !pipe code \"#************************************************************************  set sParentChild \"child\"        ;# parent or child - use parent or child fields in roles and groups - cannot use both! set bUseAssignmentField \"FALSE\" ;# TRUE or FALSE - process person assignments set in role/group data set bUseAccessField \"FALSE\"     ;# TRUE or FALSE - process user access assignments in rules and policy states set bRetainBusObject \"TRUE\"     ;# TRUE or FALSE - retain bus objects current states when resequencing policy states set bImportOverwrite \"TRUE\"    ;# TRUE or FALSE - overwrite import if it exists set bBusObjOverwrite \"TRUE\"    ;# TRUE or FALSE - overwrite bus objects in emxSpinnerBusObjects.tcl if exists set bBusRelOverwrite \"TRUE\"    ;# TRUE or FALSE - overwrite bus rels in emxSpinnerBusRels.tcl if exists set bTriggerAdd \"OFF\"           ;# ON or OFF - turns global create triggers on or off for bus objects and connections set bTriggerMod \"OFF\"           ;# ON or OFF - turns global modify triggers on or off for bus objects and connections set bTriggerDel \"OFF\"           ;# ON or OFF - turns global delete triggers on or off for bus objects and connections set bTriggerChk \"OFF\"           ;# ON or OFF - turns global checkin triggers on or off for bus object files set sReplaceSymbolic \"&?%$ ()\"  ;# characters to be trimmed when creating symbolic names set sDelimiter \"tab\"            ;# data delimiter: select tab, pipe, comma, carot, tilde or newline set sRangeDelim \"pipe\"          ;# attr range delimiter (use different one than data delimiter!) set bShowModOnly \"TRUE\"         ;# TRUE or FALSE - only modifications are logged when set to TRUE set bStreamLog \"FALSE\"          ;# TRUE or FALSE - output log to screen if TRUE set bShowTransaction \"FALSE\"    ;# TRUE or FALSE - show transaction boundaries during logging set bCompile \"FALSE\"             ;# TRUE or FALSE - compile JPO's added or modified if TRUE set bOverlay \"TRUE\"             ;# TRUE or FALSE - skip "
 0 2 "2/4/2017 10:05:03 AM" creator "  modify program emxSpinnerSettings.tcl !pipe code \"#************************************************************************  set sParentChild \"child\"        ;# parent or child - use parent or child fields in roles and groups - cannot use both! set bUseAssignmentField \"FALSE\" ;# TRUE or FALSE - process person assignments set in role/group data set bUseAccessField \"FALSE\"     ;# TRUE or FALSE - process user access assignments in rules and policy states set bRetainBusObject \"TRUE\"     ;# TRUE or FALSE - retain bus objects current states when resequencing policy states set bImportOverwrite \"TRUE\"    ;# TRUE or FALSE - overwrite import if it exists set bBusObjOverwrite \"TRUE\"    ;# TRUE or FALSE - overwrite bus objects in emxSpinnerBusObjects.tcl if exists set bBusRelOverwrite \"TRUE\"    ;# TRUE or FALSE - overwrite bus rels in emxSpinnerBusRels.tcl if exists set bTriggerAdd \"OFF\"           ;# ON or OFF - turns global create triggers on or off for bus objects and connections set bTriggerMod \"OFF\"           ;# ON or OFF - turns global modify triggers on or off for bus objects and connections set bTriggerDel \"OFF\"           ;# ON or OFF - turns global delete triggers on or off for bus objects and connections set bTriggerChk \"OFF\"           ;# ON or OFF - turns global checkin triggers on or off for bus object files set sReplaceSymbolic \"&?%$ ()\"  ;# characters to be trimmed when creating symbolic names set sDelimiter \"tab\"            ;# data delimiter: select tab, pipe, comma, carot, tilde or newline set sRangeDelim \"pipe\"          ;# attr range delimiter (use different one than data delimiter!) set bShowModOnly \"TRUE\"         ;# TRUE or FALSE - only modifications are logged when set to TRUE set bStreamLog \"FALSE\"          ;# TRUE or FALSE - output log to screen if TRUE set bShowTransaction \"FALSE\"    ;# TRUE or FALSE - show transaction boundaries during logging set bCompile \"FALSE\"             ;# TRUE or FALSE - compile JPO's added or modified if TRUE set bOverlay \"FALSE\"             ;# TRUE or FALSE - skip"
 0 2 "2/12/2017 4:32:36 PM" creator "  modify program emxSpinnerSettings.tcl !pipe code \"#************************************************************************  set sParentChild \"child\"        ;# parent or child - use parent or child fields in roles and groups - cannot use both! set bUseAssignmentField \"FALSE\" ;# TRUE or FALSE - process person assignments set in role/group data set bUseAccessField \"FALSE\"     ;# TRUE or FALSE - process user access assignments in rules and policy states set bRetainBusObject \"TRUE\"     ;# TRUE or FALSE - retain bus objects current states when resequencing policy states set bImportOverwrite \"TRUE\"    ;# TRUE or FALSE - overwrite import if it exists set bBusObjOverwrite \"TRUE\"    ;# TRUE or FALSE - overwrite bus objects in emxSpinnerBusObjects.tcl if exists set bBusRelOverwrite \"TRUE\"    ;# TRUE or FALSE - overwrite bus rels in emxSpinnerBusRels.tcl if exists set bTriggerAdd \"OFF\"           ;# ON or OFF - turns global create triggers on or off for bus objects and connections set bTriggerMod \"OFF\"           ;# ON or OFF - turns global modify triggers on or off for bus objects and connections set bTriggerDel \"OFF\"           ;# ON or OFF - turns global delete triggers on or off for bus objects and connections set bTriggerChk \"OFF\"           ;# ON or OFF - turns global checkin triggers on or off for bus object files set sReplaceSymbolic \"&?%$ ()\"  ;# characters to be trimmed when creating symbolic names set sDelimiter \"tab\"            ;# data delimiter: select tab, pipe, comma, carot, tilde or newline set sRangeDelim \"pipe\"          ;# attr range delimiter (use different one than data delimiter!) set bShowModOnly \"TRUE\"         ;# TRUE or FALSE - only modifications are logged when set to TRUE set bStreamLog \"FALSE\"          ;# TRUE or FALSE - output log to screen if TRUE set bShowTransaction \"FALSE\"    ;# TRUE or FALSE - show transaction boundaries during logging set bCompile \"FALSE\"             ;# TRUE or FALSE - compile JPO's added or modified if TRUE set bOverlay \"TRUE\"             ;# TRUE or FALSE - skip "
 0 2 "2/12/2017 5:19:57 PM" creator "  modify program emxSpinnerSettings.tcl !pipe code \"#************************************************************************  set sParentChild \"child\"        ;# parent or child - use parent or child fields in roles and groups - cannot use both! set bUseAssignmentField \"FALSE\" ;# TRUE or FALSE - process person assignments set in role/group data set bUseAccessField \"FALSE\"     ;# TRUE or FALSE - process user access assignments in rules and policy states set bRetainBusObject \"TRUE\"     ;# TRUE or FALSE - retain bus objects current states when resequencing policy states set bImportOverwrite \"TRUE\"    ;# TRUE or FALSE - overwrite import if it exists set bBusObjOverwrite \"TRUE\"    ;# TRUE or FALSE - overwrite bus objects in emxSpinnerBusObjects.tcl if exists set bBusRelOverwrite \"TRUE\"    ;# TRUE or FALSE - overwrite bus rels in emxSpinnerBusRels.tcl if exists set bTriggerAdd \"OFF\"           ;# ON or OFF - turns global create triggers on or off for bus objects and connections set bTriggerMod \"OFF\"           ;# ON or OFF - turns global modify triggers on or off for bus objects and connections set bTriggerDel \"OFF\"           ;# ON or OFF - turns global delete triggers on or off for bus objects and connections set bTriggerChk \"OFF\"           ;# ON or OFF - turns global checkin triggers on or off for bus object files set sReplaceSymbolic \"&?%$ ()\"  ;# characters to be trimmed when creating symbolic names set sDelimiter \"tab\"            ;# data delimiter: select tab, pipe, comma, carot, tilde or newline set sRangeDelim \"pipe\"          ;# attr range delimiter (use different one than data delimiter!) set bShowModOnly \"TRUE\"         ;# TRUE or FALSE - only modifications are logged when set to TRUE set bStreamLog \"FALSE\"          ;# TRUE or FALSE - output log to screen if TRUE set bShowTransaction \"FALSE\"    ;# TRUE or FALSE - show transaction boundaries during logging set bCompile \"FALSE\"             ;# TRUE or FALSE - compile JPO's added or modified if TRUE set bOverlay \"FALSE\"             ;# TRUE or FALSE - skip"
 0 2 "3/6/2017 4:58:07 PM" creator "  modify program emxSpinnerSettings.tcl !pipe code \"#************************************************************************  set sParentChild \"child\"        ;# parent or child - use parent or child fields in roles and groups - cannot use both! set bUseAssignmentField \"FALSE\" ;# TRUE or FALSE - process person assignments set in role/group data set bUseAccessField \"FALSE\"     ;# TRUE or FALSE - process user access assignments in rules and policy states set bRetainBusObject \"TRUE\"     ;# TRUE or FALSE - retain bus objects current states when resequencing policy states set bImportOverwrite \"TRUE\"    ;# TRUE or FALSE - overwrite import if it exists set bBusObjOverwrite \"TRUE\"    ;# TRUE or FALSE - overwrite bus objects in emxSpinnerBusObjects.tcl if exists set bBusRelOverwrite \"TRUE\"    ;# TRUE or FALSE - overwrite bus rels in emxSpinnerBusRels.tcl if exists set bTriggerAdd \"OFF\"           ;# ON or OFF - turns global create triggers on or off for bus objects and connections set bTriggerMod \"OFF\"           ;# ON or OFF - turns global modify triggers on or off for bus objects and connections set bTriggerDel \"OFF\"           ;# ON or OFF - turns global delete triggers on or off for bus objects and connections set bTriggerChk \"OFF\"           ;# ON or OFF - turns global checkin triggers on or off for bus object files set sReplaceSymbolic \"&?%$ ()\"  ;# characters to be trimmed when creating symbolic names set sDelimiter \"tab\"            ;# data delimiter: select tab, pipe, comma, carot, tilde or newline set sRangeDelim \"pipe\"          ;# attr range delimiter (use different one than data delimiter!) set bShowModOnly \"TRUE\"         ;# TRUE or FALSE - only modifications are logged when set to TRUE set bStreamLog \"FALSE\"          ;# TRUE or FALSE - output log to screen if TRUE set bShowTransaction \"FALSE\"    ;# TRUE or FALSE - show transaction boundaries during logging set bCompile \"FALSE\"             ;# TRUE or FALSE - compile JPO's added or modified if TRUE set bOverlay \"TRUE\"             ;# TRUE or FALSE - skip "
 0 2 "3/6/2017 5:21:28 PM" creator "  modify program emxSpinnerSettings.tcl !pipe code \"#************************************************************************  set sParentChild \"child\"        ;# parent or child - use parent or child fields in roles and groups - cannot use both! set bUseAssignmentField \"FALSE\" ;# TRUE or FALSE - process person assignments set in role/group data set bUseAccessField \"FALSE\"     ;# TRUE or FALSE - process user access assignments in rules and policy states set bRetainBusObject \"TRUE\"     ;# TRUE or FALSE - retain bus objects current states when resequencing policy states set bImportOverwrite \"TRUE\"    ;# TRUE or FALSE - overwrite import if it exists set bBusObjOverwrite \"TRUE\"    ;# TRUE or FALSE - overwrite bus objects in emxSpinnerBusObjects.tcl if exists set bBusRelOverwrite \"TRUE\"    ;# TRUE or FALSE - overwrite bus rels in emxSpinnerBusRels.tcl if exists set bTriggerAdd \"OFF\"           ;# ON or OFF - turns global create triggers on or off for bus objects and connections set bTriggerMod \"OFF\"           ;# ON or OFF - turns global modify triggers on or off for bus objects and connections set bTriggerDel \"OFF\"           ;# ON or OFF - turns global delete triggers on or off for bus objects and connections set bTriggerChk \"OFF\"           ;# ON or OFF - turns global checkin triggers on or off for bus object files set sReplaceSymbolic \"&?%$ ()\"  ;# characters to be trimmed when creating symbolic names set sDelimiter \"tab\"            ;# data delimiter: select tab, pipe, comma, carot, tilde or newline set sRangeDelim \"pipe\"          ;# attr range delimiter (use different one than data delimiter!) set bShowModOnly \"TRUE\"         ;# TRUE or FALSE - only modifications are logged when set to TRUE set bStreamLog \"FALSE\"          ;# TRUE or FALSE - output log to screen if TRUE set bShowTransaction \"FALSE\"    ;# TRUE or FALSE - show transaction boundaries during logging set bCompile \"FALSE\"             ;# TRUE or FALSE - compile JPO's added or modified if TRUE set bOverlay \"FALSE\"             ;# TRUE or FALSE - skip"
 0 2 "3/27/2017 3:41:29 PM" creator "mod property SpinnerAgent on program emxSpinnerSettings.tcl value '3/27/2017 3:41:29 PM'"
 0 2 "3/27/2017 3:41:29 PM" creator "mod program emxSpinnerSettings.tcl file ./Business/SourceFiles/emxSpinnerSettings.tcl"
 0 2 "3/27/2017 3:43:16 PM" creator "  modify program emxSpinnerSettings.tcl !pipe code \"#************************************************************************  set sParentChild \"parent\"        ;# parent or child - use parent or child fields in roles and groups - cannot use both! set bUseAssignmentField \"FALSE\" ;# TRUE or FALSE - process person assignments set in role/group data set bUseAccessField \"FALSE\"     ;# TRUE or FALSE - process user access assignments in rules and policy states set bRetainBusObject \"TRUE\"     ;# TRUE or FALSE - retain bus objects current states when resequencing policy states set bImportOverwrite \"FALSE\"    ;# TRUE or FALSE - overwrite import if it exists set bBusObjOverwrite \"TRUE\"    ;# TRUE or FALSE - overwrite bus objects in emxSpinnerBusObjects.tcl if exists set bBusRelOverwrite \"TRUE\"    ;# TRUE or FALSE - overwrite bus rels in emxSpinnerBusRels.tcl if exists set bTriggerAdd \"OFF\"           ;# ON or OFF - turns global create triggers on or off for bus objects and connections set bTriggerMod \"OFF\"           ;# ON or OFF - turns global modify triggers on or off for bus objects and connections set bTriggerDel \"OFF\"           ;# ON or OFF - turns global delete triggers on or off for bus objects and connections set bTriggerChk \"OFF\"           ;# ON or OFF - turns global checkin triggers on or off for bus object files set sReplaceSymbolic \"&?%$ ()\"  ;# characters to be trimmed when creating symbolic names set sDelimiter \"tab\"            ;# data delimiter: select tab, pipe, comma, carot, tilde or newline set sRangeDelim \"pipe\"          ;# attr range delimiter (use different one than data delimiter!) set bShowModOnly \"TRUE\"         ;# TRUE or FALSE - only modifications are logged when set to TRUE set bStreamLog \"FALSE\"          ;# TRUE or FALSE - output log to screen if TRUE set bShowTransaction \"FALSE\"    ;# TRUE or FALSE - show transaction boundaries during logging set bCompile \"TRUE\"             ;# TRUE or FALSE - compile JPO's added or modified if TRUE set bOverlay \"FALSE\"             ;# TRUE or FALSE - ski"

!MTRX!END

!MTRX!AD! program emxSpinnerScanner.tcl "3DEXPERIENCE R2015x(24.0.0.0)"
emxSpinnerScanner.tcl 0 "" "#########################################################################
#
# @progdoc      emxSpinnerScanner.tcl vM10.58
#
# @Description: Sets program emxSpinnerAgent.tcl into scan mode.
#
# @Parameters:  None
#
# @Usage:       Run this program for an MQL command window w/data files in directories:
#               . (current dir)         emxSpinnerAgent.tcl, emxSpinnerAccess.tcl programs
#               ./Business              Spinner[SCHEMA]Data.xls data files
#               ./Business/SourceFiles  Database program files  
#               ./Business/Policy       Policy access data files from Bus Doc Generator program
#               ./Business/Rule         Rule access data files from Bus Doc Generator program        
#               ./Export/[SCHEMA TYPE]  Export files from Bus Doc Generator program
#
# @progdoc      Copyright (c) MatrixOne Inc., October 7, 2003
#
#########################################################################
#
# @Modifications: Matt Osterman 03/04/2005 - Setup for executable version
#
#########################################################################
tcl;

eval {
   if {[info host] == \"mostermant43\" } {
      source \"c:/Program Files/TclPro1.3/win32-ix86/bin/prodebug.tcl\"
      set cmd \"debugger_eval\"
      set xxx [debugger_init]
   } else {
      set cmd \"eval\"
   }
}
$cmd {

   set bExecute TRUE
   if {[mql get env 0] == \"\"} {set bExecute FALSE}

   set sLocation \"\"
   if {$bExecute && [mql list program emxSpinnerAgent.tcl] != \"\"} {
      set sLocation database
   } elseif {$bExecute != \"TRUE\" && [file exists \"./emxSpinnerAgent.tcl\"] == 1} {
      set sLocation filesystem
   } else {
      if {$bExecute} {
         puts \"ERROR: Program execution halted. Program object 'emxSpinnerAgent.tcl' is missing from the database.\"
      } else {
         puts \"ERROR: Program execution halted. Program 'emxSpinnerAgent.tcl' is missing from directory '[pwd]'.\"
      }      	
      exit 1
      return
   } 
   mql set env SPINNERSCANMODE TRUE
   if {$sLocation == \"filesystem\"} {
      mql run emxSpinnerAgent.tcl
   } else {
      mql exec prog emxSpinnerAgent.tcl
   }
}

" 1 0 0 0 0 0 0 0 0 0 0 0 "" 0 0
 0 1
 SpinnerAgent NULL noname "3/27/2017 3:41:29 PM" 0
"12/6/2015 11:42:58 PM" "3/14/2018 3:57:25 PM"
7
 0 1 "12/6/2015 11:42:58 PM" creator "add program emxSpinnerScanner.tcl mql execute immediate !needsbusinessobject !downloadable !pipe !pooled nothidden file ./Business/SourceFiles/emxSpinnerScanner.tcl"
 0 2 "12/6/2015 11:42:58 PM" creator "add property SpinnerAgent on program emxSpinnerScanner.tcl value '12/6/2015 11:42:58 PM'"
 0 2 "12/6/2015 11:42:58 PM" creator "mod program emxSpinnerScanner.tcl description ''"
 0 2 "2/3/2016 5:21:02 PM" creator "mod property SpinnerAgent on program emxSpinnerScanner.tcl value '2/3/2016 5:21:02 PM'"
 0 2 "2/3/2016 5:21:02 PM" creator "mod program emxSpinnerScanner.tcl file ./Business/SourceFiles/emxSpinnerScanner.tcl"
 0 2 "3/27/2017 3:41:29 PM" creator "mod property SpinnerAgent on program emxSpinnerScanner.tcl value '3/27/2017 3:41:29 PM'"
 0 2 "3/27/2017 3:41:29 PM" creator "mod program emxSpinnerScanner.tcl file ./Business/SourceFiles/emxSpinnerScanner.tcl"

!MTRX!END

!MTRX!AD! program emxSpinner.tcl "3DEXPERIENCE R2015x(24.0.0.0)"
emxSpinner.tcl 0 "" "exec prog emxSpinnerAgent.tcl" 1 0 0 0 0 0 0 0 0 0 0 0 "" 0 0
 0 1
 SpinnerAgent NULL noname "12/6/2015 11:42:58 PM" 0
"12/6/2015 11:42:58 PM" "3/14/2018 3:57:25 PM"
3
 0 1 "12/6/2015 11:42:58 PM" creator "add program emxSpinner.tcl mql execute immediate !needsbusinessobject !downloadable !pipe !pooled nothidden file ./Business/SourceFiles/emxSpinner.tcl"
 0 2 "12/6/2015 11:42:58 PM" creator "add property SpinnerAgent on program emxSpinner.tcl value '12/6/2015 11:42:58 PM'"
 0 2 "12/6/2015 11:42:58 PM" creator "mod program emxSpinner.tcl description ''"

!MTRX!END

!MTRX!AD! program emxSpinnerInterface.tcl "3DEXPERIENCE R2015x(24.0.0.0)"
emxSpinnerInterface.tcl 0 "" "#########################################################################*10.80
#
# @progdoc      emxSpinnerInterface.tcl vM10.80 (Build 8.3.31)
#
# @Description: Procedures for running in Interfaces
#
# @Parameters:  Returns 0 if successful, 1 if not
#
# @Usage:       Utilized by emxSpinnerAgent.tcl
#
# @progdoc      Copyright (c) ENOVIA MatrixOne 2006
#
#########################################################################
#
# @Modifications: FirstName LastName MM/DD/YYYY - Modification
#
#########################################################################

# Procedure to check for and remove same types on derivative interfaces
   proc pDeleteTypeRel {sSchName sTypeRelName sTypeRel} {
      set lsDerived [pPrintQuery \"\" derived | spl]
      foreach sDerived $lsDerived {
         if {$sDerived != \"\" && [lsearch [split [pQuery \"\" \"print interface \\042$sDerived\\042 select $sTypeRel dump |\"] |] $sTypeRelName] > -1} {
            pMqlCmd \"mod interface \\042$sSchName\\042 remove $sTypeRel \\042$sTypeRelName\\042\"
         } else {
            set lsDerivative [split [pQuery \"\" \"print interface \\042$sSchName\\042 select derivative dump |\"] |]
            foreach sDerivative $lsDerivative {
               set slsTypeTest [pQuery \"\" \"print interface \\042$sDerivative\\042 select $sTypeRel dump |\"]
               if {[regsub -all \"$sTypeRelName\" $slsTypeTest \"\" slsTypeTest] > 1} {pMqlCmd \"mod interface \\042$sDerivative\\042 remove $sTypeRel \\042$sTypeRelName\\042\"}
            }
         }
      }
   }

# Procedure to analyze interfaces
proc pAnalyzeInterface {} {
   global aCol aDat lsAttributePlan lsAttributeActual lsAttrImmediate lsTypePlan lsTypeActual lsTypeDerivative lsRelPlan lsRelActual lsRelDerivative lsDerivedPlan lsDerivedActual bOverlay bAdd sMxVersion
   set lsDerivedPlan [pTrimList $aCol(2)]
   set aCol(3) [pCompareAttr $aCol(3) false true abstract true]
   set lsAttributePlan [pTrimList $aCol(5)]
   set lsTypePlan [pTrimList $aCol(6)]
   if {$sMxVersion >= 10.8} {set lsRelPlan [pTrimList $aCol(8)]}
   set lsDerivedActual [list ]
   set lsAttributeActual [list ]
   set lsTypeActual [list ]
   set lsRelActual [list ]
   if {$bAdd != \"TRUE\"} {
      set aDat(3) [pPrintQuery \"false\" abstract \"\" \"str\"]
      set lsDerivedActual [pPrintQuery \"\" derived | spl]
      set lsAttributeActual [pPrintQuery \"\" attribute | spl]
      set lsAttrImmediate [pPrintQuery \"\" immediateattribute | spl]
      set lsTypeActual [pPrintQuery \"\" type | spl]
      if {$sMxVersion >= 10.8} {set lsRelActual [pPrintQuery \"\" relationship | spl]} 
      if {[llength $lsDerivedActual] > 0} {
         set lsTypeDerivative [list ]
         set lsRelDerivative [list ]
         foreach sDerivedActual $lsDerivedActual {
            set lsTypeDerived [split [pQuery \"\" \"print interface \\042$sDerivedActual\\042 select type dump |\"] |]
            foreach sType $lsTypeActual {if {[lsearch $lsTypeDerived $sType] < 0 && [lsearch $lsTypeDerivative $sType] < 0} {lappend lsTypeDerivative $sType}}
            if {$sMxVersion >= 10.8} {
               set lsRelDerived [split [pQuery \"\" \"print interface \\042$sDerivedActual\\042 select relationship dump |\"] |]
               foreach sRel $lsRelActual {if {[lsearch $lsRelDerived $sRel] < 0 && [lsearch $lsRelDerivative $sRel] < 0} {lappend lsRelDerivative $sRel}}
            }
         }
      } else {
         set lsTypeDerivative $lsTypeActual
         set lsRelDerivative $lsRelActual
      }
   }
   if {$bOverlay} {
      pOverlay [list 3]
      set lsDerivedPlan [pOverlayList $lsDerivedPlan $lsDerivedActual]
      set lsAttributePlan [pOverlayList $lsAttributePlan $lsAttributeActual]
      set lsTypePlan [pOverlayList $lsTypePlan $lsTypeActual]
      if {$sMxVersion >= 10.8} {set lsRelPlan [pOverlayList $lsRelPlan $lsRelActual]}
   }
}

# Procedure to process interfaces
proc pProcessInterface {} {
   global aCol aDat bAdd lsDerivedPlan lsDerivedActual lsAttributePlan lsAttributeActual lsAttrImmediate lsTypePlan lsTypeActual lsTypeDerivative lsRelPlan lsRelActual lsRelDerivative resultappend sHidden sHiddenActual bUpdate bReg bScan sMxVersion
   set iExit 0
   if {$bAdd} {
      pMqlCmd \"add interface \\042$aCol(0)\\042 abstract $aCol(3) $sHidden\"
      if {[llength $lsDerivedPlan] > 0} {
         set slsDerivedPlan [join $lsDerivedPlan \"','\"]
         pMqlCmd \"mod interface \\042$aCol(0)\\042 derived '$slsDerivedPlan'\"
      }
      set sAppend \"\"
      foreach sAttr $lsAttributePlan {if {[pPrintQuery FALSE \"attribute\\133$sAttr\\135\" \"\" \"\"] == \"FALSE\"} {append sAppend \" add attribute \\042$sAttr\\042\"}}
      if {$sAppend != \"\"} {pMqlCmd \"mod interface \\042$aCol(0)\\042$sAppend\"}
      pPlanAdd $lsTypePlan interface $aCol(0) \"add type\" \"\"
      foreach sTypeP $lsTypePlan {pDeleteTypeRel $aCol(0) $sTypeP \"type\"}
      if {$sMxVersion >= 10.8} {
         pPlanAdd $lsRelPlan interface $aCol(0) \"add relationship\" \"\"
         foreach sRelP $lsRelPlan {pDeleteTypeRel $aCol(0) $sRelP \"relationship\"}
      }
   } else {
      if {$aCol(3) != $aDat(3) || $sHidden != $sHiddenActual} {pMqlCmd \"escape mod interface \\042$aCol(0)\\042 abstract $aCol(3) $sHidden\"}
      if {[llength $lsDerivedPlan] > 0} {
         if {[lsort -unique $lsDerivedPlan] != [lsort -unique $lsDerivedActual]} {
            set slsDerivedPlan [join $lsDerivedPlan \"','\"]
            pMqlCmd \"mod interface \\042$aCol(0)\\042 derived '$slsDerivedPlan'\"
         }
      } elseif {[llength $lsDerivedActual] > 0} {
         pMqlCmd \"mod interface \\042$aCol(0)\\042 remove derived\"
      }
      pPlanActualAddDel $lsAttrImmediate $lsAttributeActual $lsAttributePlan interface \"\" $aCol(0) \"remove attribute\" \"add attribute\" \"\"
      pPlanActualAddDel $lsTypeDerivative $lsTypeActual $lsTypePlan interface \"\" $aCol(0) \"remove type\" \"add type\" \"\"
      if {$sMxVersion >= 10.8} {pPlanActualAddDel $lsRelDerivative $lsRelActual $lsRelPlan interface \"\" $aCol(0) \"remove relationship\" \"add relationship\" \"\"}
   }
   return $iExit
}
" 1 0 0 0 0 0 0 0 0 0 0 0 "" 0 0
 0 1
 SpinnerAgent NULL noname "3/27/2017 3:41:29 PM" 0
"12/6/2015 11:42:58 PM" "3/14/2018 3:57:25 PM"
7
 0 1 "12/6/2015 11:42:58 PM" creator "add program emxSpinnerInterface.tcl mql execute immediate !needsbusinessobject !downloadable !pipe !pooled nothidden file ./Business/SourceFiles/emxSpinnerInterface.tcl"
 0 2 "12/6/2015 11:42:58 PM" creator "add property SpinnerAgent on program emxSpinnerInterface.tcl value '12/6/2015 11:42:58 PM'"
 0 2 "12/6/2015 11:42:58 PM" creator "mod program emxSpinnerInterface.tcl description ''"
 0 2 "2/3/2016 5:21:02 PM" creator "mod property SpinnerAgent on program emxSpinnerInterface.tcl value '2/3/2016 5:21:02 PM'"
 0 2 "2/3/2016 5:21:02 PM" creator "mod program emxSpinnerInterface.tcl file ./Business/SourceFiles/emxSpinnerInterface.tcl"
 0 2 "3/27/2017 3:41:29 PM" creator "mod property SpinnerAgent on program emxSpinnerInterface.tcl value '3/27/2017 3:41:29 PM'"
 0 2 "3/27/2017 3:41:29 PM" creator "mod program emxSpinnerInterface.tcl file ./Business/SourceFiles/emxSpinnerInterface.tcl"

!MTRX!END

!MTRX!AD! program emxSpinnerPage.tcl "3DEXPERIENCE R2015x(24.0.0.0)"
emxSpinnerPage.tcl 0 "" "#########################################################################*10.61
#
# @progdoc      emxSpinnerPage.tcl vM10.61 (Build 6.6.15)
#
# @Description: Procedures for running in Pages
#
# @Parameters:  Returns 0 if successful, 1 if not
#
# @Usage:       Utilized by emxSpinnerAgent.tcl
#
# @progdoc      Copyright (c) ENOVIA MatrixOne 2006
#
#########################################################################
#
# @Modifications: FirstName LastName MM/DD/YYYY - Modification
#
#########################################################################

# Procedure to analyze pages
proc pAnalyzePage {} {
   global aCol aDat bOverlay bAdd sContent sContentActual sContentTrim sMxVersion sSpinDir sPageFile sPageFilePlan
   regsub -all \"/\" $aCol(0) \"SLASH\" sPageFile
   set bFail FALSE
   if {[catch {set iPageFile [open \"$sSpinDir/Business/PageFiles/$sPageFile\" r]} sMsg] != 0} {
   	  set bFail TRUE
   	  set sErrorMsg \"Page file '$sSpinDir/Business/PageFiles/$sPageFile' is not present\"
   }
   if {$bFail} {
      pWriteErrorMsg \"\\nERROR: $sErrorMsg\"
      exit 1
      return
   } else {
      set sContent [read $iPageFile]
      set sContentTrim [string trim $sContent]
      close $iPageFile
   }
   if {$bAdd != \"TRUE\"} {
      set aDat(3) [pPrintQuery \"\" mime \"\" \"\"]
      set sContentActual \"\"
      set sContentActual [pPrintQuery \"\" content \"\" \"\"]
   }
   if {$bOverlay} {pOverlay [list 3]}
}

# Procedure to process pages
proc pProcessPage {} {
   global aCol aDat bAdd sContent sContentActual sContentTrim sSpinDir sHidden sHiddenActual sMxVersion bJPO sPageFile sPageFilePlan bAEF
   set bModProg FALSE
   if {$bAdd} {
      pMqlCmd \"add page \\042$aCol(0)\\042 mime \\042$aCol(3)\\042 $sHidden\"
   } else {
      if {$aCol(3) != $aDat(3) || $sHidden != $sHiddenActual} {pMqlCmd \"mod page \\042$aCol(0)\\042 mime \\042$aCol(3)\\042 $sHidden\"}
      if {[string first $sContentActual $sContent] == -1 || $sContentTrim != $sContentActual} {set bModProg TRUE}
   }
   if {$bAdd || $bModProg} {
      pMqlCmd \"mod page \\042$aCol(0)\\042 file \\042$sSpinDir/Business/PageFiles/$sPageFile\\042\"
   }
   return 0
}" 1 0 0 0 0 0 0 0 0 0 0 0 "" 0 0
 0 1
 SpinnerAgent NULL noname "3/27/2017 3:41:29 PM" 0
"12/6/2015 11:42:58 PM" "3/14/2018 3:57:25 PM"
7
 0 1 "12/6/2015 11:42:58 PM" creator "add program emxSpinnerPage.tcl mql execute immediate !needsbusinessobject !downloadable !pipe !pooled nothidden file ./Business/SourceFiles/emxSpinnerPage.tcl"
 0 2 "12/6/2015 11:42:58 PM" creator "add property SpinnerAgent on program emxSpinnerPage.tcl value '12/6/2015 11:42:58 PM'"
 0 2 "12/6/2015 11:42:58 PM" creator "mod program emxSpinnerPage.tcl description ''"
 0 2 "2/3/2016 5:21:02 PM" creator "mod property SpinnerAgent on program emxSpinnerPage.tcl value '2/3/2016 5:21:02 PM'"
 0 2 "2/3/2016 5:21:02 PM" creator "mod program emxSpinnerPage.tcl file ./Business/SourceFiles/emxSpinnerPage.tcl"
 0 2 "3/27/2017 3:41:29 PM" creator "mod property SpinnerAgent on program emxSpinnerPage.tcl value '3/27/2017 3:41:29 PM'"
 0 2 "3/27/2017 3:41:29 PM" creator "mod program emxSpinnerPage.tcl file ./Business/SourceFiles/emxSpinnerPage.tcl"

!MTRX!END

!MTRX!AD! program emxSpinnerExpression.tcl "3DEXPERIENCE R2015x(24.0.0.0)"
emxSpinnerExpression.tcl 0 "" "#########################################################################*10.62
#
# @progdoc      emxSpinnerExpression.tcl vM10.62 (Build 7.1.15)
#
# @Description: Procedures for running in Expressions
#
# @Parameters:  Returns 0 if successful, 1 if not
#
# @Usage:       Utilized by emxSpinnerAgent.tcl
#
# @progdoc      Copyright (c) ENOVIA MatrixOne 2007
#
#########################################################################
#
# @Modifications: FirstName LastName MM/DD/YYYY - Modification
#
#########################################################################

# Procedure to pass tcl-type variables in mql commands
   proc pRegSubMqlEscape {sEscape} {
      regsub -all \"\\134$\" $sEscape \"\\$\" sEscape
      regsub -all \"\\134{\" $sEscape \"\\134\\173\" sEscape
      regsub -all \"\\134}\" $sEscape \"\\134\\175\" sEscape
      regsub -all \"\\134\\133\" $sEscape \"\\134\\133\" sEscape
      regsub -all \"\\134\\135\" $sEscape \"\\134\\135\" sEscape
      regsub -all \"\\042\" $sEscape \"\\134\\042\" sEscape
      regsub -all \"\\047\" $sEscape \"\\134\\047\" sEscape
      return $sEscape
   }

# Procedure to analyze expressions
proc pAnalyzeExpression {} {
   global aCol aDat bOverlay bAdd
   if {$bAdd != \"TRUE\"} {
      set aDat(3) [pPrintQuery \"\" value \"\" \"\"]
   }
   if {$bOverlay} {
      pOverlay [list 3]
   }
}

# Procedure to process expressions
proc pProcessExpression {} {
   global aCol aDat bAdd sHidden sHiddenActual bUpdate bReg bScan resultappend
   set iExit 0
   set aCol(3) [pRegSubMqlEscape $aCol(3)]
   if {$bAdd} {
      pMqlCmd \"add expression \\042$aCol(0)\\042 value \\042$aCol(3)\\042 $sHidden\"
   } else {
      if {$aCol(3) != $aDat(3) || $sHidden != $sHiddenActual} {pMqlCmd \"mod expression \\042$aCol(0)\\042 value \\042$aCol(3)\\042 $sHidden\"}
   }
   return $iExit
}
" 1 0 0 0 0 0 0 0 0 0 0 0 "" 0 0
 0 1
 SpinnerAgent NULL noname "3/27/2017 3:41:29 PM" 0
"12/6/2015 11:42:58 PM" "3/14/2018 3:57:25 PM"
7
 0 1 "12/6/2015 11:42:58 PM" creator "add program emxSpinnerExpression.tcl mql execute immediate !needsbusinessobject !downloadable !pipe !pooled nothidden file ./Business/SourceFiles/emxSpinnerExpression.tcl"
 0 2 "12/6/2015 11:42:58 PM" creator "add property SpinnerAgent on program emxSpinnerExpression.tcl value '12/6/2015 11:42:58 PM'"
 0 2 "12/6/2015 11:42:58 PM" creator "mod program emxSpinnerExpression.tcl description ''"
 0 2 "2/3/2016 5:21:02 PM" creator "mod property SpinnerAgent on program emxSpinnerExpression.tcl value '2/3/2016 5:21:02 PM'"
 0 2 "2/3/2016 5:21:02 PM" creator "mod program emxSpinnerExpression.tcl file ./Business/SourceFiles/emxSpinnerExpression.tcl"
 0 2 "3/27/2017 3:41:29 PM" creator "mod property SpinnerAgent on program emxSpinnerExpression.tcl value '3/27/2017 3:41:29 PM'"
 0 2 "3/27/2017 3:41:29 PM" creator "mod program emxSpinnerExpression.tcl file ./Business/SourceFiles/emxSpinnerExpression.tcl"

!MTRX!END

!MTRX!AD! program emxSpinnerDimension.tcl "3DEXPERIENCE R2015x(24.0.0.0)"
emxSpinnerDimension.tcl 0 "" "#########################################################################*10.70
#
# @progdoc      emxSpinnerDimension.tcl vM10.70 (Build 7.4.1)
#
# @Description: Procedures for running in Dimensions w/Units
#
# @Parameters:  Returns 0 if successful, 1 if not
#
# @Usage:       Utilized by emxSpinnerAgent.tcl
#
# @progdoc      Copyright (c) ENOVIA MatrixOne 2007
#
#########################################################################
#
# @Modifications: FirstName LastName MM/DD/YYYY - Modification
#
#########################################################################

# Procedure to set setting names and values
   proc pSetSetting {sSchName slsStgName slsStgValue} {
      global lsStgNamePlan lsStgValuePlan lsStgNameActual lsStgValueActual aStgPlan aStgActual sRangeDelim aCol sLogFileError bOverlay bAdd lsDel
      set lsStgNamePlan [pTrimList $slsStgName]
      regsub -all \"\\134\\174\\134\\174\" $slsStgValue \"<OR>\" slsStgValue
      regsub -all \"&&\" $slsStgValue \"<AND>\" slsStgValue
      set lsStgValuePlanTemp [split $slsStgValue $sRangeDelim]
      set lsStgValuePlan \"\"
      foreach sStgValue $lsStgValuePlanTemp {
      	 regsub -all \"<OR>\" $sStgValue \"\\174\\174\" sStgValue
      	 regsub -all \"<AND>\" $sStgValue \"\\134\\&\\134\\&\" sStgValue
         regsub -all \"<PIPE>\" $sStgValue \"|\" sStgValue
         lappend lsStgValuePlan [string trim $sStgValue]
      }
      set lsStgNameActual [split [pQuery \"\" \"print dimension \\042$sSchName\\042 select unit\\134\\133$aCol(1)\\134\\135.setting.name dump |\"] |]
      set lsStgValueActual [split [pQuery \"\" \"print dimension \\042$sSchName\\042 select unit\\134\\133$aCol(1)\\134\\135.setting.value dump ^\"] ^]
      foreach sStgNameActual $lsStgNameActual sStgValueActual $lsStgValueActual {array set aStgActual [list $sStgNameActual $sStgValueActual]}
      if {[llength $lsStgNamePlan] != [llength $lsStgValuePlan]} {
         set iLogFileErr [open $sLogFileError a+]
         puts $iLogFileErr \"\\nERROR: 'dimension' '$sSchName' unit '$aCol(1)' setting name and value lists are not the same length\"
         close $iLogFileErr
         if {[llength $lsStgNamePlan] > [llength $lsStgValuePlan] && [string first \"<OR>\" $slsStgValue] > -1} {
            set iLogFileErr [open $sLogFileError a+]
            puts $iLogFileErr \"Be sure to leave a space between '|'s if null values are intended vs. double '|'s\"
            close $iLogFileErr
         }
         return 1
      }
      if {$bOverlay} {
      	 if {$lsStgNamePlan == \"<NULL>\"} {
      	    set lsStgNamePlan [list ]
      	    set lsStgValuePlan [list ]
      	 } elseif {$bAdd != \"TRUE\" && $lsStgNamePlan == \"\"} {
      	    set lsStgNamePlan $lsStgNameActual
      	    set lsStgValuePlan $lsStgValueActual
      	 } else {
      	    set lsTemp [pMergeList $lsStgNamePlan $lsStgValuePlan $lsStgNameActual $lsStgValueActual \"\"]
      	    set lsStgNamePlan [lindex $lsTemp 0]
      	    set lsStgValuePlan [lindex $lsTemp 1]
      	 }
      }
      foreach sStgNamePlan $lsStgNamePlan sStgValuePlan $lsStgValuePlan {array set aStgPlan [list $sStgNamePlan $sStgValuePlan]}
      return 0
   }

# Procedure to process setting names and values
   proc pSetting {sSchName sSchUnit} {
      global lsStgNameActual lsStgValueActual lsStgNamePlan lsStgValuePlan aStgActual aStgPlan
      foreach sStgNameA $lsStgNameActual sStgValueA $lsStgValueActual sStgNameP $lsStgNamePlan sStgValueP $lsStgValuePlan {
         if {$sStgNameA != \"\"} {
            if {[lsearch $lsStgNamePlan $sStgNameA] < 0} {
               pMqlCmd \"escape mod dimension \\042$sSchName\\042 mod unit \\042$sSchUnit\\042 remove setting \\042$sStgNameA\\042\"
            } elseif {$aStgPlan($sStgNameA) != $sStgValueA} {
               set sModSettingValue [pRegSubEvalEscape $aStgPlan($sStgNameA)]
               if {[string first \"\\047\" $sModSettingValue] < 0 && [string first \"javascript\" [string tolower $sModSettingValue]] < 0} {
                  pMqlCmd \"escape mod dimension \\042$sSchName\\042 mod unit \\042$sSchUnit\\042 setting \\042$sStgNameA\\042 '$sModSettingValue'\"
               } else {
                  pMqlCmd \"escape mod dimension \\042$sSchName\\042 mod unit \\042$sSchUnit\\042 setting \\042$sStgNameA\\042 \\042$sModSettingValue\\042\"
               }
               array set aStgActual [list $sStgNameA $aStgPlan($sStgNameA)]
            }
         }
         if {$sStgNameP != \"\"} {
            if {[lsearch $lsStgNameActual $sStgNameP] < 0} {
               set sModSettingValue [pRegSubEvalEscape $sStgValueP]
               if {[string first \"\\047\" $sModSettingValue] < 0 && [string first \"javascript\" [string tolower $sModSettingValue]] < 0} {
                  pMqlCmd \"escape mod dimension \\042$sSchName\\042 mod unit \\042$sSchUnit\\042 setting \\042$sStgNameP\\042 '$sModSettingValue'\"
               } else {
                  pMqlCmd \"escape mod dimension \\042$sSchName\\042 mod unit \\042$sSchUnit\\042 setting \\042$sStgNameP\\042 \\042$sModSettingValue\\042\"
               }
            } elseif {$aStgActual($sStgNameP) != $sStgValueP} {
               set sModSettingValue [pRegSubEvalEscape $sStgValueP]
               if {[string first \"\\047\" $sModSettingValue] < 0 && [string first \"javascript\" [string tolower $sModSettingValue]] < 0} {
                  pMqlCmd \"escape mod dimension \\042$sSchName\\042 mod unit \\042$sSchUnit\\042 setting \\042$sStgNameP\\042 '$sModSettingValue'\"
               } else {
                  pMqlCmd \"escape mod dimension \\042$sSchName\\042 mod unit \\042$sSchUnit\\042 setting \\042$sStgNameP\\042 \\042$sModSettingValue\\042\"
               }
               array set aStgActual [list $sStgNameP $sStgValueP]
            }
         }
      }
   }

# Procedure to set system names and units
   proc pSetSysNameUnit {sSchName slsSysName slsSysUnit} {
      global lsSysNamePlan lsSysUnitPlan lsSysNameActual lsSysUnitActual aSysPlan aSysActual sRangeDelim aCol sLogFileError bOverlay bAdd lsDel
      set lsSysNamePlan [pTrimList $slsSysName]
      set lsSysUnitPlan [pTrimList $slsSysUnit]
      set lsSysNameActual [list ]
      set lsSysUnitActual [list ]
      set lsPrint [split [pQuery \"\" \"print dimension \\042$aCol(0)\\042\"] \\n]
      set bTrip \"FALSE\"
      foreach sPrint $lsPrint {
         set sPrint [string trim $sPrint]
         if {[string range $sPrint 0 3] == \"unit\" && [string first $aCol(1) $sPrint] > 3} {
            set bTrip TRUE
         } elseif {$bTrip && [string range $sPrint 0 3] == \"unit\"} {
            break
         } elseif {$bTrip} {
            if {[string range $sPrint 0 5] == \"system\"} {
               regsub \"system\" $sPrint \"\" sPrint
               regsub \" to unit \" $sPrint \"\\|\" sPrint
               set lsSysNameUnit [split $sPrint \"|\"]
               lappend lsSysNameActual [string trim [lindex $lsSysNameUnit 0]]
               lappend lsSysUnitActual [string trim [lindex $lsSysNameUnit 1]]
            }
         }
      }
      foreach sSysNameActual $lsSysNameActual sSysUnitActual $lsSysUnitActual {array set aSysActual [list $sSysNameActual $sSysUnitActual]}
      if {[llength $lsSysNamePlan] != [llength $lsSysUnitPlan]} {
         set iLogFileErr [open $sLogFileError a+]
         puts $iLogFileErr \"\\nERROR: 'dimension' '$sSchName' unit '$aCol(1)' SystemName and SystemUnit lists are not the same length\"
         close $iLogFileErr
         return 1
      }
      if {$bOverlay} {
      	 if {$lsSysNamePlan == \"<NULL>\"} {
      	    set lsSysNamePlan [list ]
      	    set lsSysUnitPlan [list ]
      	 } elseif {$bAdd != \"TRUE\" && $lsSysNamePlan == \"\"} {
      	    set lsSysNamePlan $lsSysNameActual
      	    set lsSysUnitPlan $lsSysUnitActual
      	 } else {
      	    set lsTemp [pMergeList $lsSysNamePlan $lsSysUnitPlan $lsSysNameActual $lsSysUnitActual \"\"]
      	    set lsSysNamePlan [lindex $lsTemp 0]
      	    set lsSysUnitPlan [lindex $lsTemp 1]
      	 }
      }
      foreach sSysNamePlan $lsSysNamePlan sSysUnitPlan $lsSysUnitPlan {array set aSysPlan [list $sSysNamePlan $sSysUnitPlan]}
      return 0
   }

# Procedure to process system names and units
   proc pSysNameUnit {sSchName sSchUnit} {
      global lsSysNameActual lsSysUnitActual lsSysNamePlan lsSysUnitPlan aSysActual aSysPlan
      foreach sSysNameA $lsSysNameActual sSysUnitA $lsSysUnitActual sSysNameP $lsSysNamePlan sSysUnitP $lsSysUnitPlan {
         if {$sSysNameA != \"\"} {
            if {[lsearch $lsSysNamePlan $sSysNameA] < 0} {
               pMqlCmd \"escape mod dimension \\042$sSchName\\042 mod unit \\042$sSchUnit\\042 remove system \\042$sSysNameA\\042 to unit \\042$sSysUnitA\\042\"
            } elseif {$aSysPlan($sSysNameA) != $sSysUnitA} {
               pMqlCmd \"escape mod dimension \\042$sSchName\\042 mod unit \\042$sSchUnit\\042 add system \\042$sSysNameA\\042 to unit \\042$aSysPlan($sSysNameA)\\042\"
               array set aSysActual [list $sSysNameA $aSysPlan($sSysNameA)]
            }
         }
         if {$sSysNameP != \"\"} {
            if {[lsearch $lsSysNameActual $sSysNameP] < 0} {
               pMqlCmd \"escape mod dimension \\042$sSchName\\042 mod unit \\042$sSchUnit\\042 add system \\042$sSysNameP\\042 to unit \\042$sSysUnitP\\042\"
            } elseif {$aSysActual($sSysNameP) != $sSysUnitP} {
               pMqlCmd \"escape mod dimension \\042$sSchName\\042 mod unit \\042$sSchUnit\\042 add system \\042$sSysNameP\\042 to unit \\042$sSysUnitP\\042\"
               array set aSysActual [list $sSysNameP $sSysUnitP]
            }
         }
      }
   }

# Procedure to analyze dimensions
proc pAnalyzeDimension {} {
   global aCol aDat bOverlay bAdd sSchemaType lsUnitNamePlan lsUnitNameActual lsSysNameSysUnitPlan lsSysNameSysUnitActual lsStgNamePlan lsStgValuePlan lsStgNameActual lsStgValueActual aStgPlan aStgActual lsSysNamePlan lsSysUnitPlan lsSysNameActual lsSysUnitActual aSysPlan aSysActual sRangeDelim sLogFileError lsDel bRepeat
   switch $sSchemaType {
      dimension {
         set lsUnitNamePlan [pTrimList $aCol(3)]
         set lsUnitNameActual \"\"
         if {$bAdd != \"TRUE\"} {set lsUnitNameActual [split [pQuery \"\" \"print dimension \\042$aCol(0)\\042 select unit.name dump |\"] |]}
         if {$bOverlay} {set lsUnitNamePlan [pOverlayList $lsUnitNamePlan $lsUnitNameActual]}
      } unit {
         set bReturn [pSetSetting $aCol(0) $aCol(6) $aCol(7)]
         if {$bReturn} {
            puts \"\\nError - Review log file '$sLogFileError', correct problem(s) and restart\"
            return 1
         }
         set bReturn [pSetSysNameUnit $aCol(0) $aCol(8) $aCol(9)]
         if {$bReturn} {
            puts \"\\nError - Review log file '$sLogFileError', correct problem(s) and restart\"
            return 1
         }
         foreach iDat [list 2 3 4 5 10] sProperty [list label description multiplier offset \"default\"] {set aDat($iDat) [pQuery \"\" \"print dimension \\042$aCol(0)\\042 select unit\\134\\133$aCol(1)\\134\\135.$sProperty dump\"]}
         set aCol(10) [pCompareAttr $aCol(10) notdefault \"default\" true true]
         set aDat(10) [pCompareAttr $aDat(10) notdefault \"default\" true true]
         if {$bOverlay} {pOverlay [list 2 3 4 5]}
         pSetAction \"Modify dimension $aCol(0) unit $aCol(1)\"
      }
   }
   return 0
}

# Procedure to process dimensions
proc pProcessDimension {} {
   global aCol aDat bOverlay bAdd sHidden sHiddenActual sSchemaType lsUnitNamePlan lsUnitNameActual bEscQuote bScan sNumberActual lsStgNamePlan lsStgValuePlan lsStgNameActual lsStgValueActual aStgActual aStgPlan lsSysNamePlan lsSysUnitPlan lsSysNameActual lsSysUnitActual aSysPlan aSysActual sSpinStamp
   switch $sSchemaType {
      dimension {
         if {$bAdd} {
            pMqlCmd \"add dimension \\042$aCol(0)\\042 $sHidden\"
            pPlanAdd $lsUnitNamePlan $sSchemaType $aCol(0) \"add unit\" \"\"
         } else {
            pPlanActualAddDel $lsUnitNameActual \"\" $lsUnitNamePlan dimension \"\" $aCol(0) \"remove unit\" \"add unit\" \"\"
            if {$sHidden != $sHiddenActual} {pMqlCmd \"mod dimension \\042$aCol(0)\\042 $sHidden\"}
            set lsUnitNameActual [pPrintQuery \"\" \"unit.name\" | spl]
         }
      } unit {
         if {$aCol(2) != $aDat(2)} {
            set aCol(2) [pRegSubEvalEscape $aCol(2)]
            pMqlCmd \"mod dimension \\042$aCol(0)\\042 mod unit \\042$aCol(1)\\042 label \\042$aCol(2)\\042\"
         }
         if {$aCol(3) != $aDat(3)} {
            set aCol(3) [pRegSubEvalEscape $aCol(3)]
            pMqlCmd \"mod dimension \\042$aCol(0)\\042 mod unit \\042$aCol(1)\\042 unitdescription \\042$aCol(3)\\042\"
         }
         if {$aCol(4) != $aDat(4)} {
            pMqlCmd \"mod dimension \\042$aCol(0)\\042 mod unit \\042$aCol(1)\\042 multiplier \\042$aCol(4)\\042\"
         }
         if {$aCol(5) != $aDat(5)} {
            pMqlCmd \"mod dimension \\042$aCol(0)\\042 mod unit \\042$aCol(1)\\042 offset \\042$aCol(5)\\042\"
         }
         if {$aCol(10) != $aDat(10)} {
            pMqlCmd \"mod dimension \\042$aCol(0)\\042 mod unit \\042$aCol(1)\\042 $aCol(10)\"
         }
         pSetting $aCol(0) $aCol(1)
         pSysNameUnit $aCol(0) $aCol(1)
      }
   }
   return 0
}
" 1 0 0 0 0 0 0 0 0 0 0 0 "" 0 0
 0 1
 SpinnerAgent NULL noname "3/27/2017 3:41:29 PM" 0
"12/6/2015 11:42:58 PM" "3/14/2018 3:57:25 PM"
7
 0 1 "12/6/2015 11:42:58 PM" creator "add program emxSpinnerDimension.tcl mql execute immediate !needsbusinessobject !downloadable !pipe !pooled nothidden file ./Business/SourceFiles/emxSpinnerDimension.tcl"
 0 2 "12/6/2015 11:42:58 PM" creator "mod program emxSpinnerDimension.tcl description ''"
 0 2 "12/6/2015 11:42:58 PM" creator "add property SpinnerAgent on program emxSpinnerDimension.tcl value '12/6/2015 11:42:58 PM'"
 0 2 "2/3/2016 5:21:02 PM" creator "mod program emxSpinnerDimension.tcl file ./Business/SourceFiles/emxSpinnerDimension.tcl"
 0 2 "2/3/2016 5:21:02 PM" creator "mod property SpinnerAgent on program emxSpinnerDimension.tcl value '2/3/2016 5:21:02 PM'"
 0 2 "3/27/2017 3:41:29 PM" creator "mod program emxSpinnerDimension.tcl file ./Business/SourceFiles/emxSpinnerDimension.tcl"
 0 2 "3/27/2017 3:41:29 PM" creator "mod property SpinnerAgent on program emxSpinnerDimension.tcl value '3/27/2017 3:41:29 PM'"

!MTRX!END

!MTRX!AD! program emxExtractObjectsRels.tcl "3DEXPERIENCE R2015x(24.0.0.0)"
emxExtractObjectsRels.tcl 0 "" "#*******************************************************************************
# @progdoc        emxExtractObjectsRels.tcl v 1.1
#
# @Brief:         Generates business object and/or connection spinner files.
#
# @Description:   Generates business object and/or connection spinner files.
#
# @Parameters:    Business Object Name, Relationship Name
#
# @Returns:       Nothing   
#
# @Usage:         Run in MQL:
#		  exec prog emxExtractObjectsRels.tcl \"Type 1,Type N\" \"Rel 1,Rel N\"
#
#    Valid Examples:
#    a) Administrative lists	exec prog emxExtractObjectsRels.tcl
#    b) one type  - one rels	exec prog emxExtractObjectsRels.tcl \"ECO\" \"New Part / Part Revision\"
#    c) type list - no rels  	exec prog emxExtractObjectsRels.tcl \"Part,ECO,ECR\" \"\"
#    d) no types  - rel list	exec prog emxExtractObjectsRels.tcl \"\" \"Ref*\"
#    e) type list - rel list	exec prog emxExtractObjectsRels.tcl \"EC*\" \"Ref*,EBOM\"
#    f) bus objects by TNR    exec prog emxExtractObjectsRels.tcl \"EC*|ECR-123*|*\"
#
#    To generate templates only, add 'template' as the third parameter:
#	                        exec prog emxExtractObjectsRels.tcl \"*\" \"*\" template

# 
# @progdoc        Copyright (c) 2005, MatrixOne
#*******************************************************************************
# @Modifications:
#
# Matt Osterman 01/04/2005 - Originated
# Venkatesh Harikrishnan 04/04/2006 - Modified for the New Line Issue
# Matt Osterman 10/25/2006 - Added TNR capability for bus objects
#
#*******************************************************************************
tcl;

eval {
   set sHost [info host]

   if { $sHost == \"MOSTERMAN2K\" } {
      source \"c:/Program Files/TclPro1.3/win32-ix86/bin/prodebug.tcl\"
      set cmd \"debugger_eval\"
      set xxx [debugger_init]
   } else {
      set cmd \"eval\"
   }
}
$cmd {

################################################################################
#                   Business Objects
################################################################################
#*******************************************************************************
# Procedure:   pGet_BOAdmin
#
# Description: print details about the admin type and create spreadsheets
#
# Returns:     None.
#*******************************************************************************
   proc pGet_BOAdmin { sList } {
      global sDumpSchemaDirObjects bTemplate

      foreach sList1 $sList {
         set lsTNR [split $sList1 |]
         set sType [string trim [lindex $lsTNR 0]]
       	 set lsType [split [mql list type $sType] \\n]
         set sName [string trim [lindex $lsTNR 1]]
         set sRev  [string trim [lindex $lsTNR 2]]
         if {$sName == \"\"} {set sName \"*\"}
         if {$sRev == \"\"} {set sRev \"*\"}
         puts \"Start backup of Business Object $sList1 ...\"
         foreach sType $lsType {
# skip if abstract
            set sAbst [mql print type \"$sType\"]
            set i [ regsub \"abstract true\" $sAbst \"abstract true\" sCheck ]
            if {$i > 0} {
               set sFlag \"true\"
            } else {
               set sFlag \"false\"
            }
            if {\"$sFlag\" == \"false\" } {
               if {$bTemplate != \"TRUE\"} {
                  set sCmd \" mql temp query bus \\\"$sType\\\" \\\"$sName\\\" \\\"$sRev\\\" select name revision policy current vault owner description attribute.value dump \\\\\\t recordsep <NEWRECORD>\"
                  if { [ catch { eval $sCmd } sOutstr ] == 0 } {
                     regsub -all \"\\n\" $sOutstr {<NEWLINE>} sOutstr
                     regsub -all \"<NEWRECORD>\" $sOutstr  \"\\n\" sOutstr
                     regsub -all \"\\134\\134\" $sOutstr \"<BACKSLASH>\" sOutstr
                     if {$sOutstr != \"\"} {
                        set sFileName \"bo_$sType\\_$sName\\_$sRev\"
                        regsub -all \"\\134\\174\" $sFileName \"_\" sFileName
                        regsub -all \"\\134\\052\" $sFileName \"ALL\" sFileName
                        regsub -all \"/\" $sFileName \"SLASH\" sFileName
                        regsub -all \":\" $sFileName \"COLON\" sFileName
                        regsub -all \"<\" $sFileName \"LTHAN\" sFileName
                        regsub -all \">\" $sFileName \"GTHAN\" sFileName
                        set p_filename \"$sDumpSchemaDirObjects/$sFileName\\.xls\"
                        set p_file [open $p_filename w]
                        set sAttr1  [ mql print type \"$sType\" select attribute dump \\t ]
                        set lBos \"Type\\tName\\tRev\\tNew Name\\tNew Rev\\tPolicy\\tState\\tVault\\tOwner\\tdescription\\t$sAttr1\"
                        puts $p_file \"$lBos\"
                        puts $p_file $sOutstr
                        close $p_file
                     }
                  }
               } else {
                  set sFileName \"bo_$sType\"
                  regsub -all \"\\134\\174\" $sFileName \"PYPE\" sFileName
                  regsub -all \"/\" $sFileName \"SLASH\" sFileName
                  regsub -all \":\" $sFileName \"COLON\" sFileName
                  regsub -all \"<\" $sFileName \"LTHAN\" sFileName
                  regsub -all \">\" $sFileName \"GTHAN\" sFileName
                  set p_filename \"$sDumpSchemaDirObjects/$sFileName\\.xls\"
                  set p_file [open $p_filename w]
                  set sAttr1  [ mql print type \"$sType\" select attribute dump \\t ]
                  set lBos \"Type\\tName\\tRev\\tNew Name\\tNew Rev\\tPolicy\\tState\\tVault\\tOwner\\tdescription\\t$sAttr1\"
                  puts $p_file \"$lBos\"
                  close $p_file
               }
            }
         }
      }
   }

################################################################################
#                   Connections
################################################################################
#*******************************************************************************
# Procedure:   pGet_BOAdminRel
#
# Description: print details about the admin type and create spreadsheets
#
# Returns:     None.
#*******************************************************************************
   proc pGet_BOAdminRel { sList } {

      global sDumpSchemaDirRelationships bTemplate
      set lsRelRetain \"\"

      foreach sList1 $sList {
         set sSplitRel [split $sList1 ,]
         set sType     [ string trim [ lindex \"$sSplitRel\" 0 ] ]
         set sRel      [ string trim [ lindex \"$sSplitRel\" 1 ] ]
         set sValue1 \"$sRel\"
         set sValue2 [join $sValue1 _]
         set fname \"rel_$sValue2\"
         regsub -all \"/\" $fname \"_FWDSLASH_\" fname 
         set p_filename \"$sDumpSchemaDirRelationships/$fname\\.xls\"

         if {[lsearch $lsRelRetain $sRel] < 0} {
            puts \"Start backup of Business Object Relationship $sRel ...\"
            set p_file [open $p_filename w]
            set sAttr1  [ mql print relationship \"$sRel\" select attribute dump \\t ]
            set lBos \"FromType\\tFromName\\tFromRev\\tToType\\tToName\\tToRev\\tDirection\\tRelationship\\t$sAttr1\"
            lappend lsRelRetain $sRel
         } else {
            set p_file [open $p_filename a+]
	 }
	 if {$bTemplate != \"TRUE\"} {  
            set sQuery [ split [ mql temp query bus \"$sType\" * * where \"relationship\\[$sRel\\] == True\" select id dump ^ ] \\n ] 
            set sAttr1  [ mql print relationship \"$sRel\" select attribute dump \\t ]
   	
            foreach sValue $sQuery { 
               regsub -all \"\\{\" $sValue \"\" sValue1
               regsub -all \"\\}\" $sValue1 \"\" sType1
               set lsLine          [split \"$sType1\" \"^\" ] 
               set sFromType       [lindex \"$lsLine\" 0]
               set sFromName       [lindex \"$lsLine\" 1]
               set sFromRev        [lindex \"$lsLine\" 2]
 	          #Modified for the New Line Issue -- Start
               set sMsg  [ mql expand bus \"$sFromType\" \"$sFromName\" \"$sFromRev\" from relationship \"$sRel\" select relationship attribute.value dump ^ recordsep \"<NEWRECORD>\" ]  	
	             set sMsg [ string trimright $sMsg \"<NEWRECORD>\"]
	             regsub -all \"\\n\" $sMsg {<NEWLINE>} sMsg
	             regsub -all \"<NEWRECORD>\" $sMsg  \"\\n\" sMsg
	             set sExpand [split $sMsg \"\\n\"]
 	          #Modified for the New Line Issue -- End		
               foreach sExpand1 $sExpand { 
                  regsub -all \"\\{\" $sExpand1 \"\" sExpand2
                  regsub -all \"\\}\" $sExpand2 \"\" sExpand1
                  set lsLine2       [split \"$sExpand1\" \"^\" ] 
                  set sToDir        [lindex \"$lsLine2\" 2]
                  set sToType       [lindex \"$lsLine2\" 3]
                  set sToName       [lindex \"$lsLine2\" 4]
                  set sToRev        [lindex \"$lsLine2\" 5]
                  set sAttr2        [join [ lrange  \"$lsLine2\" 6 end ] \\t]
                  append lBos \"\\n$sFromType\\t$sFromName\\t$sFromRev\\t$sToType\\t$sToName\\t$sToRev\\t$sToDir\\t$sRel\\t$sAttr2\"
               }
            }
         } else {
            append lBos \"\\n\\t\\t\\t\\t\\t\\t\\t$sRel\"
         }
         puts $p_file \"$lBos\"
         close $p_file
         set lBos \"\"
      }
   }
# end of procedures

   set sSpinnerPath [mql get env SPINNERPATHBO]
   set sBusType [mql get env 1]
   set sRelType [mql get env 2]
   set sTemplate [string tolower [string trim [mql get env 3]]]
   set bTemplate FALSE
   if {$sTemplate == \"template\"} {set bTemplate TRUE}

   if {$sSpinnerPath == \"\"} {
      set sOS [string tolower $tcl_platform(os)];
      set sSuffix [clock format [clock seconds] -format \"%Y%m%d\"]
      
      if { [string tolower [string range $sOS 0 5]] == \"window\" } {
         set sSpinnerPath \"c:/temp/SpinnerAgent$sSuffix\";
      } else {
         set sSpinnerPath \"/tmp/SpinnerAgent$sSuffix\";
      }
   }

    set sDumpSchemaDirObjects [ file join $sSpinnerPath Objects ]
    file mkdir $sDumpSchemaDirObjects
    set sDumpSchemaDirRelationships [ file join $sSpinnerPath Relationships ]
    file mkdir $sDumpSchemaDirRelationships
    
    if {$sBusType == \"\" && $sRelType == \"\"} {
       set sBusType admin
       set sRelType admin
       if {[mql get env SPINNERPATHBO] == \"\"} {puts \"\\nAdministrative business objects & connections based on AEF 10.5 being extracted.\\nFor specific business objects or connections, invoke program in this manner:\\n  exec prog emxExtractObjectsRels.tcl \\\"Type 1,...,Type N\\\" \\\"Rel 1,...,Rel N\\\"\\nNotes: Wildcards are allowed. For TNR, separate with '|'s (e.g. EC*|ECR-101*|* )\\n  For templates, specify 'template' as 3rd parameter.\\n\"}
    } 

    if {$sBusType == \"admin\"} {
       set lsType [list \"eService Number Generator\" \"eService Object Generator\" \"eService Trigger Program Parameters\"]
       pGet_BOAdmin $lsType
    } elseif {$sBusType == \"\"} {
    } else {
       set lsType [split $sBusType ,]
       pGet_BOAdmin $lsType
    }

    if {$sRelType == \"admin\"} {
       set thelist [ list \"eService Object Generator,eService Number Generator\" \"eService Object Generator,eService Additional Object\"]
       pGet_BOAdminRel $thelist
    } elseif {$sRelType == \"\"} {
    } else {
       set lsRelType [split $sRelType ,]
       set lsRel \"\"

       foreach sRelType $lsRelType {
       	  set lsList [split [mql list relationship $sRelType] \\n]
       	  set lsRel [concat $lsRel $lsList]
       }

       foreach sRel $lsRel {
          set lsFromType [split [mql print rel $sRel select fromtype dump |] |]
          if {[lsearch $lsFromType all] >= 0} {
             set lsFromType [split [mql list type] \\n]
          }
          set thelist \"\"
          set lsFromList \"\"
          foreach sFromType $lsFromType {
             set sParent [mql print type $sFromType select derived dump]
             if {$sParent != \"\" && [lsearch $lsFromType $sParent] >= 0} {
             } else {
                lappend lsFromList $sFromType
             }
          } 
          foreach sFromList $lsFromList {
             lappend thelist \"$sFromList,$sRel\"
          }
          pGet_BOAdminRel $thelist
       }
    }
    puts \"\\nFiles loaded in directory: $sSpinnerPath\"
}
" 1 0 0 0 0 0 0 0 0 0 0 0 "" 0 0
 0 1
 SpinnerAgent NULL noname "3/27/2017 3:41:29 PM" 0
"12/6/2015 10:41:20 PM" "3/27/2017 3:41:29 PM"
9
 0 1 "12/6/2015 10:41:20 PM" creator "add program emxExtractObjectsRels.tcl mql execute immediate !needsbusinessobject !downloadable !pipe !pooled nothidden file ./Business/SourceFiles/emxExtractObjectsRels.tcl"
 0 2 "12/6/2015 10:41:20 PM" creator "mod program emxExtractObjectsRels.tcl description ''"
 0 2 "12/6/2015 10:41:20 PM" creator "add property SpinnerAgent on program emxExtractObjectsRels.tcl value '12/6/2015 10:41:20 PM'"
 0 2 "12/6/2015 11:31:49 PM" creator "mod program emxExtractObjectsRels.tcl file ./Business/SourceFiles/emxExtractObjectsRels.tcl"
 0 2 "12/6/2015 11:31:50 PM" creator "mod property SpinnerAgent on program emxExtractObjectsRels.tcl value '12/6/2015 11:31:49 PM'"
 0 2 "2/3/2016 5:21:02 PM" creator "mod program emxExtractObjectsRels.tcl file ./Business/SourceFiles/emxExtractObjectsRels.tcl"
 0 2 "2/3/2016 5:21:02 PM" creator "mod property SpinnerAgent on program emxExtractObjectsRels.tcl value '2/3/2016 5:21:02 PM'"
 0 2 "3/27/2017 3:41:29 PM" creator "mod program emxExtractObjectsRels.tcl file ./Business/SourceFiles/emxExtractObjectsRels.tcl"
 0 2 "3/27/2017 3:41:29 PM" creator "mod property SpinnerAgent on program emxExtractObjectsRels.tcl value '3/27/2017 3:41:29 PM'"

!MTRX!END

!MTRX!AD! program emxExpandStructure.tcl "3DEXPERIENCE R2015x(24.0.0.0)"
emxExpandStructure.tcl 0 "" "#*******************************************************************************
# @progdoc        emxExpandStructure.tcl v 2.0
#
# @Brief:         Generates structure for business object(s) with connections in Spinner data file format.
#
# @Description:   Generates structure for business object with connections in Spinner data file format.
#                 The Use Case is expanding a structure such as a Project Space, Part (Assembly) or Specification and
#                 picking up the desired reference relationships and objects hanging on the structure for migration
#                 to another environment or reporting purposes. 
#
# @Parameters:    Business Object Name(s), Primary Relationship Name, Optional Secondary Relationship Names
#
# @Returns:       Nothing
#
# @Usage:         Run in MQL: exec prog emxExpandStructure.tcl \"T|N|R\" \"P-REL|DIR|LVL\" \"S-REL(1)|BO,S-REL(N)|[BO] or *|[BO]\"
#
# USAGE:  exec prog emxExpandStructure.tcl \"[PARAM 1]\" \"[PARAM 2]\" \"[PARAM 3] (optional)\"
#
#          where [PARAM 1] is \" T | N | R \" 
#                          Object Type, Name and Revision - pipe separated, wildcards allowed
#                [PARAM 2] is \" P-REL | LVL | DIR \"
#                          P-REL the \"Primary Relationship Name\" for the structure being expanded
#                          LVL is the number of levels to expand with values '1', '2',..., 'all' (default 'all')
#                          DIR is the direction with values 'from' or 'to' (default 'from' if blank)
#                [PARAM 3] is \" S-REL(1) | BUSOBJ ,..., S-REL(N) | BUSOBJ\"
#                          S-REL is the Secondary Rel Name(s) for one level on expanded objects (comma-separated list)
#                          BUSOBJ is 'bo' to add bus objects or 'file' to include bus obj files from secondary rels.
#          valid examples:
#                   exec prog emxExpandStructure.tcl \"Part|Assembly One|1\" \"EBOM\" \"Alternate Part|bo, Reference Document|file\"
#                   exec prog emxExpandStructure.tcl \"Project Space|Project*|*\" \"SubTask\" \"Dependency,Project Access Key\"
#                   exec prog emxExpandStructure.tcl \"Part|Bolt, Lag, 3/4 inch|1\" \"EBOM|3|to\"
#
# @progdoc        Copyright (c) 2005, MatrixOne
#*******************************************************************************
# @Modifications:
#
# Matt Osterman 01/25/2007 - Originated
# Matt Osterman 10/25/2007 - Update to workaround objects w/attribute groups (interfaces)
#                            Attributes from interfaces do not get pulled due to migration issues
#
#*******************************************************************************

tcl;

eval {
   set sHost [info host]

   if { $sHost == \"mostermant43\" } {
      source \"c:/Program Files/TclPro1.3/win32-ix86/bin/prodebug.tcl\"
      set cmd \"debugger_eval\"
      set xxx [debugger_init]
   } else {
      set cmd \"eval\"
   }
}
$cmd {

set sDirections(1) {
This script generates structure for business objects with connections in Spinner data file format.
The Use Case is expanding a structure such as a Project Space, Part (Assembly) or Specification and
picking up the desired reference relationships and objects hanging on the structure for migration
to another environment, pulling up where used scenerios or for reporting purposes.
}
set sDirections(2) {
USAGE:  exec prog emxExpandStructure.tcl \"[PARAM 1]\" \"[PARAM 2]\" \"[PARAM 3] (optional)\"
%
where [PARAM 1] is \" T | N | R \" 
                     Object Type, Name and Revision - pipe separated, wildcards allowed
           [PARAM 2] is \" P-REL | LVL | DIR \"
                     P-REL the \"Primary Relationship Name\" for the structure being expanded
                     LVL is the number of levels to expand with values '1', '2',..., 'all' (default 'all')
                     DIR is the direction with values 'from' or 'to' (default 'from' if blank)
           [PARAM 3] is \" S-REL(1) | BUSOBJ ,..., S-REL(N) | BUSOBJ\"
                     S-REL is the Secondary Rel Name(s) for one level on expanded objects (comma-separated list)
                     BUSOBJ is 'bo' to add bus objects or 'file' to include bus obj files from secondary rels. 
valid examples:
         exec prog emxExpandStructure.tcl \"Part|Assembly One|1\" \"EBOM\" \"Alternate Part|bo, Reference Document|file\"
         exec prog emxExpandStructure.tcl \"Project Space|Project*|*\" \"SubTask\" \"Dependency,Project Access Key\"
         exec prog emxExpandStructure.tcl \"Part|Bolt, Lag, 3/4 inch|1\" \"EBOM|3|to\"
}

#*******************************************************************************
# Procedure:   pSet_Filename
#
# Description: Replaces special characters for valid filename
#
# Returns:     None.
#*******************************************************************************
   proc pSet_FileName {sType sName sRev sRel sBO} {
      if {$sBO == \"bo\"} {
         set sFileName \"bo_$sType\\-$sName\\-$sRev\\_$sRel\"
      } elseif {$sBO == \"rel\"} {
         set sFileName \"rel_$sRel\\_$sType\\-$sName\\-$sRev\"
      } elseif {$sBO == \"file1\"} {
         set sFileName \"file_$sType\\-$sName\\-$sRev\\_$sRel\"
      } elseif {$sBO == \"file2\"} {
         set sFileName \"file_$sType\\-$sName\\-$sRev\"
      } else {
         set sFileName \"_$sType\\-$sName\\-$sRev\"
      }
      regsub -all \"\\134\\052\" $sFileName \"ALL\" sFileName
      regsub -all \"\\134\\174\" $sFileName \"-\" sFileName
      regsub -all \"/\" $sFileName \"-\" sFileName
      regsub -all \":\" $sFileName \"-\" sFileName
      regsub -all \"<\" $sFileName \"-\" sFileName
      regsub -all \">\" $sFileName \"-\" sFileName
      regsub -all \" \" $sFileName \"\" sFileName
      return $sFileName
   }
# end of procedures

# main
   set sSpinnerPath [mql get env SPINNERPATHBO]
   set slsBusTNR [mql get env 1]
   set slsRelPrimary [mql get env 2]
   set slsRelSecondary [mql get env 3]
   set bChkErr FALSE
   
   if {$slsBusTNR == \"\" || [string tolower $slsBusTNR] == \"help\"} {
      puts \"$sDirections(1)$sDirections(2)\"
      exit 1
      return
   }

   set lsBusTNR [split $slsBusTNR |]
   set sBusType [string trim [lindex $lsBusTNR 0]]
   set sBusName [string trim [lindex $lsBusTNR 1]]
   set sBusRev [string trim [lindex $lsBusTNR 2]]
   set lsBus [split [mql temp query bus \"$sBusType\" \"$sBusName\" \"$sBusRev\" select id dump |] \\n]
   if {$lsBus == {}} {
      puts \"ERROR: No Business Objects for \\\"$sBusType\\\" \\\"$sBusName\\\" \\\"$sBusRev\\\" found.\"
      exit 1
      return
   }
   
   set lsRelPrimary [split $slsRelPrimary |]
   set sRelPrimary [string trim [lindex $lsRelPrimary 0]]
   set sRelPrimLvl [string trim [lindex $lsRelPrimary 1]]
   set sRelPrimLvl [string tolower $sRelPrimLvl]
   set sRelPrimDir [string trim [lindex $lsRelPrimary 2]]
   set sRelPrimDir [string tolower $sRelPrimDir]
   set sErrorMsg \"\"
   if {$slsRelPrimary == \"\"} {
      set sErrorMsg \"ERROR: No relationship parameters provided\"
   } elseif {$sRelPrimLvl != \"\" && $sRelPrimLvl != \"all\" && [string is integer $sRelPrimLvl] != 1} {
      set sErrorMsg \"ERROR: Relationship level parameter \\042$sRelPrimLvl\\042 not valid\"
   } elseif {[lsearch [list \"\" \"to\" \"from\"] $sRelPrimDir] < 0} {
      set sErrorMsg \"ERROR: Relationship direction parameter \\042$sRelPrimDir\\042 not valid\"
   }
   if {$sErrorMsg != \"\"} {
      puts \"$sDirections(2)\\n$sErrorMsg - see directions above then re-execute\"
      exit 1
      return
   } elseif {[mql list relationship \"$sRelPrimary\"] == \"\"} {
      puts \"ERROR: Relationship \\042$sRelPrimary\\042 not found in database.\"
      exit 1
      return
   }
   
   if {$sRelPrimLvl == \"\"} {set sRelPrimLvl \"all\"}
   if {$sRelPrimDir == \"\"} {set sRelPrimDir \"from\"}
   
   set lsRelSecondary {}
   if {$slsRelSecondary != \"\"} {
      set lsRelSecTemp [split $slsRelSecondary ,]
      foreach slsRelSecTemp $lsRelSecTemp {
         set lsRelSecTemp [split $slsRelSecTemp |]
         set sRelSec [string trim [lindex $lsRelSecTemp 0]]
         set sRelSecOpt [string trim [lindex $lsRelSecTemp 1]]
         set sRelSecOpt [string tolower $sRelSecOpt]
         if {[lsearch [list \"\" \"bo\" \"file\"] $sRelSecOpt] < 0} {
            puts \"$sDirections(2)\\nERROR: Secondary Relationship bus object parameter \\042$sRelSecOpt\\042 not valid - see directions above then re-execute\"
            exit 1
            return
         } elseif {$sRelSec == \"*\"} {
            puts \"$sDirections(2)\\nERROR: Secondary Relationship \\042*\\042 wildcard option not available - see directions above then re-execute\"
            exit 1
            return
         } elseif {[mql list relationship \"$sRelSec\"] == \"\"} {
            puts \"ERROR: Secondary Relationship \\042$sRelSec\\042 not found in database.\"
            exit 1
            return
         }
         lappend lsRelSecondary \"$sRelSec\"
         set sRelSecOption($sRelSec) $sRelSecOpt
      }
   }
   
   if {$sSpinnerPath == \"\"} {
      set sOS [string tolower $tcl_platform(os)];
      set sSuffix1 [clock format [clock seconds] -format \"%Y%m%d\"]
      set sSuffix2 [pSet_FileName $sBusType $sBusName $sBusRev \"\" \"path\"]
      
      if { [string tolower [string range $sOS 0 5]] == \"window\" } {
         set sSpinnerPath \"c:/temp/SpinnerAgent$sSuffix1$sSuffix2\";
      } else {
         set sSpinnerPath \"/tmp/SpinnerAgent$sSuffix1$sSuffix2\";
      }
   }

   set sDumpSchemaDirObjects [ file join $sSpinnerPath Objects ]
   file mkdir $sDumpSchemaDirObjects
   set sDumpSchemaDirFiles [ file join $sDumpSchemaDirObjects Files ]
   file mkdir $sDumpSchemaDirFiles
   set sDumpSchemaDirRelationships [ file join $sSpinnerPath Relationships ]
   file mkdir $sDumpSchemaDirRelationships
   set sDumpSchemaDirLogs [ file join $sSpinnerPath \"logs\" ]
   file mkdir $sDumpSchemaDirLogs
   set p_logfile \"$sDumpSchemaDirLogs/CheckoutError.log\"
   set p_errlog [open $p_logfile w]

# Primary Structure

   foreach slsBus $lsBus {
      set lslsBus [split $slsBus |]
      set sType [string trim [lindex $lslsBus 0]]
      set sName [string trim [lindex $lslsBus 1]]
      set sRev  [string trim [lindex $lslsBus 2]]
      puts \"Start backup of Business Object \\042$sType\\042 \\042$sName\\042 \\042$sRev\\042 Relationship \\042$sRelPrimary\\042 Structure...\"

      set sFileName [pSet_FileName $sType $sName $sRev $sRelPrimary \"bo\"]
      set p_filename \"$sDumpSchemaDirObjects/$sFileName\\.xls\"
      set p_file [open $p_filename w]
      
      set sAttr($sType)  [ mql print type \"$sType\" select attribute dump \\t ]
      puts $p_file \"Type\\tName\\tRev\\tChange Name\\tChange Rev\\tPolicy\\tState\\tVault\\tOwner\\tdescription\\t$sAttr($sType)\\t<HEADER>\"
      set sItemOne [mql temp query bus \"$sType\" \"$sName\" \"$sRev\" select name revision policy current vault owner description attribute.value dump \\t]
      regsub -all \"\\n\" $sItemOne {<NEWLINE>} sItemOne
      puts $p_file $sItemOne
      
      set sFileRel [pSet_FileName $sType $sName $sRev $sRelPrimary \"rel\"]
      set p_filerel \"$sDumpSchemaDirRelationships/$sFileRel\\.xls\"
      set p_rel [open $p_filerel w]

      set sAttrRel($sRelPrimary)  [ mql print relationship \"$sRelPrimary\" select attribute dump \\t ]
      puts $p_rel \"FromType\\tFromName\\tFromRev\\tToType\\tToName\\tToRev\\tDirection\\tRelationship\\t$sAttrRel($sRelPrimary)\"
      
      set slsStructure [mql expand bus \"$sType\" \"$sName\" \"$sRev\" rel \"$sRelPrimary\" $sRelPrimDir recurse to $sRelPrimLvl select bus name revision policy current vault owner description attribute.value select rel name $sRelPrimDir.type $sRelPrimDir.name $sRelPrimDir.revision attribute.value dump \\t recordsep <NEWRECORD>]
      regsub -all \"\\n\" $slsStructure {<NEWLINE>} slsStructure
      regsub -all \"<NEWRECORD>\" $slsStructure  \"\\n\" slsStructure
      set lsStructure [split $slsStructure \\n]
      set lsItem {}
      set lsItemRel {}
      foreach slsStructure $lsStructure {
         if {$slsStructure != \"\"} {
            set lslsStructure [split $slsStructure \\t]
            set sToType [lindex $lslsStructure 3]
            set sToName [lindex $lslsStructure 4]
            set sToRev [lindex $lslsStructure 5]
            if {[catch {set iEnd [expr 12 + $iAttr($sToType)]} sMsg] != 0} {
               set iAttr($sToType) [llength [split [mql print type $sToType select attribute dump |] |] ]
               set iEnd [expr 12 + $iAttr($sToType)]
            }
            lappend lsItem [join [lrange $lslsStructure 3 $iEnd] \\t]
            set iAttrRel [llength [split [mql print bus \"$sToType\" \"$sToName\" \"$sToRev\" select attribute dump |] |] ]
            set iEndRel [expr 12 + $iAttrRel]
            lappend lsItemRel [join [concat [lrange $lslsStructure [expr $iEndRel + 2] [expr $iEndRel + 4]] [lrange $lslsStructure 3 5] [lindex $lslsStructure 2] [list $sRelPrimary] [lrange $lslsStructure [expr $iEndRel + 5] end]] \\t]
         }
      }
      set lsItem [lsort -unique $lsItem]
      set sPreType $sType
      foreach sItem $lsItem {
         set sExpType [lindex [split $sItem \\t] 0]
         if {[catch {set sTest $sAttr($sExpType)} sMsg] != 0} {
            set sAttr($sExpType) [ mql print type \"$sExpType\" select attribute dump \\t ]
         }
         if {$sPreType == $sExpType} {
            puts $p_file $sItem
         } else {
           puts $p_file \"Type\\tName\\tRev\\t\\t\\tPolicy\\tState\\tVault\\tOwner\\tdescription\\t$sAttr($sExpType)\\t<HEADER>\"
           puts $p_file $sItem
         }
         set sPreType $sExpType
      }
      close $p_file
      puts $p_rel [join $lsItemRel \\n]
      close $p_rel

# Secondary Rels

      set lsItem [concat [list $sItemOne] $lsItem]
      foreach sRelSec $lsRelSecondary {
         puts \"Start backup of Secondary Rel \\042$sRelSec\\042 for Bus Object \\042$sType\\042 \\042$sName\\042 \\042$sRev\\042...\"
   
         set lsItemBus {}
         set lsItemRel {}
         foreach sItem $lsItem {
            set lslsItem [split $sItem \\t]
            set sExpType [lindex $lslsItem 0]
            set sExpName [lindex $lslsItem 1]
            set sExpRev [lindex $lslsItem 2]
            
            set slsStructure [mql expand bus \"$sExpType\" \"$sExpName\" \"$sExpRev\" rel \"$sRelSec\" recurse to 1 select bus name revision policy current vault owner description attribute.value select rel attribute.value dump \\t recordsep <NEWRECORD>]
            regsub -all \"\\n\" $slsStructure {<NEWLINE>} slsStructure
            regsub -all \"<NEWRECORD>\" $slsStructure  \"\\n\" slsStructure
            set lsStructure [split $slsStructure \\n]
            foreach slsStructure $lsStructure {
               if {$slsStructure != \"\"} {
                  set lslsStructure [split $slsStructure \\t]
                  set sToType [lindex $lslsStructure 3]
                  set sToName [lindex $lslsStructure 4]
                  set sToRev [lindex $lslsStructure 5]
                  if {[catch {set iEndBus [expr 12 + $iAttr($sToType)]} sMsg] != 0} {
                     set iAttr($sToType) [llength [split [mql print type $sToType select attribute dump |] |] ]
                     set iEndBus [expr 12 + $iAttr($sToType)]
                  }
                  if {$sRelSecOption($sRelSec) == \"bo\" || $sRelSecOption($sRelSec) == \"file\"} {
                     lappend lsItemBus [join [lrange $lslsStructure 3 $iEndBus] \\t]
                  }
                  set iAttrRel [llength [split [mql print bus \"$sToType\" \"$sToName\" \"$sToRev\" select attribute dump |] |] ]
                  set iEndRel [expr 12 + $iAttrRel]
                  if {$sRelSec != \"Classified Item\"} {
                     lappend lsItemRel [join [concat [list $sExpType $sExpName $sExpRev] [lrange $lslsStructure 3 5] [lindex $lslsStructure 2] [list $sRelSec] [lrange $lslsStructure [expr $iEndRel + 1] end]] \\t]
                  } else {
                     lappend lsItemRel [join [concat [list $sExpType $sExpName $sExpRev] [lrange $lslsStructure 3 5] [lindex $lslsStructure 2] [list $sRelSec] [lrange $lslsStructure [expr $iEndRel + 1] end] [list \"ON\"]] \\t]
                  }                     
               }
            }
         }
            
         if {$lsItemRel != {}} {
            set sFileRel [pSet_FileName $sType $sName $sRev $sRelSec \"rel\"]
            set p_filerel \"$sDumpSchemaDirRelationships/$sFileRel\\.xls\"
            set p_rel [open $p_filerel w]
            set sAttrRel($sRelSec)  [ mql print relationship \"$sRelSec\" select attribute dump \\t ]
            puts $p_rel \"FromType\\tFromName\\tFromRev\\tToType\\tToName\\tToRev\\tDirection\\tRelationship\\t$sAttrRel($sRelSec)\"
            puts $p_rel [join $lsItemRel \\n]
            close $p_rel
            
            if {$lsItemBus != {}} {
               set bWriteFile FALSE
               if {$sRelSecOption($sRelSec) == \"file\"} { 
                  set sFileFile [pSet_FileName $sType $sName $sRev $sRelSec \"file1\"]
                  set p_filefile \"$sDumpSchemaDirFiles/$sFileFile\\.xls\"
                  set p_file [open $p_filefile w]
                  puts $p_file \"Type\\tName\\tRevision\\tFormat\\tFile\\tPath\"
               }
               set sFileBus [pSet_FileName $sType $sName $sRev $sRelSec \"bo\"]
               set p_filebus \"$sDumpSchemaDirObjects/$sFileBus\\.xls\"
               set p_bus [open $p_filebus w]
               set lsItemBus [lsort -unique $lsItemBus]
               set sPreType \"\"
               foreach sItem $lsItemBus {
                  set lslsItem [split $sItem \\t]
                  set sExpType [lindex $lslsItem 0]
                  set sExpName [lindex $lslsItem 1]
                  set sExpRev [lindex $lslsItem 2]
                  if {[catch {set sTest $sAttr($sExpType)} sMsg] != 0} {
                     set sAttr($sExpType) [ mql print type \"$sExpType\" select attribute dump \\t ]
                  }
                  if {$sPreType == $sExpType} {
                     puts $p_bus $sItem
                  } else {
                     puts $p_bus \"Type\\tName\\tRev\\tChange Name\\tChange Rev\\tPolicy\\tState\\tVault\\tOwner\\tdescription\\t$sAttr($sExpType)\\t<HEADER>\"
                     puts $p_bus $sItem
                  }
                  set sPreType $sExpType
                  if {$sRelSecOption($sRelSec) == \"file\"} {
                     set lsFile [split [mql print bus \"$sExpType\" \"$sExpName\" \"$sExpRev\" select format.file.name dump |] |]
                     set lsFormat [split [mql print bus \"$sExpType\" \"$sExpName\" \"$sExpRev\" select format.file.format dump |] |]
                     if {$lsFile != {}} {
                        set sFileDir [pSet_FileName $sExpType $sExpName $sExpRev \"\" \"file2\"]
                        set sDumpSchemaDirBO [ file join $sDumpSchemaDirFiles $sFileDir ]
                        file mkdir $sDumpSchemaDirBO
                        set bCheckin FALSE
                        foreach sFile $lsFile sFormat $lsFormat {
                           if {[catch {
                              mql checkout bus \"$sExpType\" \"$sExpName\" \"$sExpRev\" server file $sFile \"$sDumpSchemaDirBO\"
                              set sFilePath \"./Objects/Files/$sFileDir/$sFile\"
                              puts $p_file \"$sExpType\\t$sExpName\\t$sExpRev\\t$sFormat\\t$sFilePath\"
                              set bWriteFile TRUE
                              set bCheckin TRUE
                           } sMsg ] != 0} {
                              puts \"WARNING: Error w/Bus Object \\\"$sExpType\\\" \\\"$sExpName\\\" \\\"$sExpRev\\\":\\n$sMsg\"
                              puts $p_errlog \"Error w/Bus Object \\\"$sExpType\\\" \\\"$sExpName\\\" \\\"$sExpRev\\\":\\n$sMsg\\n\"
                              set bChkErr TRUE                              
                           }
                        }
                        if {!$bCheckin} {file delete -force $sDumpSchemaDirBO}
                     }
                  }
                     
               }
               close $p_bus
               if {$sRelSecOption($sRelSec) == \"file\"} {
                  close $p_file
                  if {!$bWriteFile} {
                     file delete -force $p_filefile
                  }
               } 
            }
         }
      }
   }
   puts \"\\nFiles loaded in directory: $sSpinnerPath\"
   if {$bChkErr} {
      close $p_errlog
      puts \"Checkout errors recorded in log file $p_logfile\"
   }
}
" 1 0 0 0 0 0 0 0 0 0 0 0 "" 0 0
 0 1
 SpinnerAgent NULL noname "3/27/2017 3:41:29 PM" 0
"12/6/2015 10:41:20 PM" "3/27/2017 3:41:29 PM"
9
 0 1 "12/6/2015 10:41:20 PM" creator "add program emxExpandStructure.tcl mql execute immediate !needsbusinessobject !downloadable !pipe !pooled nothidden file ./Business/SourceFiles/emxExpandStructure.tcl"
 0 2 "12/6/2015 10:41:20 PM" creator "add property SpinnerAgent on program emxExpandStructure.tcl value '12/6/2015 10:41:20 PM'"
 0 2 "12/6/2015 10:41:20 PM" creator "mod program emxExpandStructure.tcl description ''"
 0 2 "12/6/2015 11:31:50 PM" creator "mod program emxExpandStructure.tcl file ./Business/SourceFiles/emxExpandStructure.tcl"
 0 2 "12/6/2015 11:31:50 PM" creator "mod property SpinnerAgent on program emxExpandStructure.tcl value '12/6/2015 11:31:50 PM'"
 0 2 "2/3/2016 5:21:02 PM" creator "mod program emxExpandStructure.tcl file ./Business/SourceFiles/emxExpandStructure.tcl"
 0 2 "2/3/2016 5:21:02 PM" creator "mod property SpinnerAgent on program emxExpandStructure.tcl value '2/3/2016 5:21:02 PM'"
 0 2 "3/27/2017 3:41:29 PM" creator "mod program emxExpandStructure.tcl file ./Business/SourceFiles/emxExpandStructure.tcl"
 0 2 "3/27/2017 3:41:29 PM" creator "mod property SpinnerAgent on program emxExpandStructure.tcl value '3/27/2017 3:41:29 PM'"

!MTRX!END

!MTRX!AD! program emxDumper_1.tcl "3DEXPERIENCE R2015x(24.0.0.0)"
emxDumper_1.tcl 0 "Generates HTML documentation for the current schema. Runs in command line mode" "tcl;


eval {

set sHost [info host]

if { $sHost == \"mostermant43\" } {
        source \"c:/Program Files/TclPro1.3/win32-ix86/bin/prodebug.tcl\"
	set cmd \"debugger_eval\"
	set xxx [debugger_init]

} else {
	puts \"Host not registered for TclDebugger\"
	set cmd \"eval\"
}

}

$cmd {

#main

# General Settings.
# Set the dir for the root level, if set to \"\" system temp is used.
# Use the / in path settings, tcl will resolve to the platform.
    set sRootDir \"c:/temp\"


# Set output dir is created under to the root dir.
    set sOutputDir \"Business_Model\"


# Set to 0 to create a new unique dir, 1 to overwrite the existing dir.
    set bOverWrite 0


# Output Status Messages, 0 Off, 1 On.
    set bStatus 1


# To suppress hidden information, 0 Off (not checked), 1 On.
    set bSuppressHidden 0


# To suppress adm information, 0 Off (not checked), 1 On.
    set bSuppressAdmReporting 0


# Settings for Schema Data, ie the html
# To generate schema, 0 Off, 1 On.
    set bDumpSchema 0

# Text to place on the title page.
    set sHeaderTitle \"Schema Agent\"

# Under Development.
# Generate SVG images, 0 Off, 1 On.
    set bSVG 0

# To generate Program code listing, 0 Off, 1 On.
    set bExtendedProgram 1

# To generate detailed Policy Tables, 0 Off, 1 On.
    set bExtendedPolicy 1


# Settings for the Spinner Data output
# To generate spreadsheet data, 0 Off, 1 On.
    set bDumpSpinner 1


# Under Development
# Settings for the Dumping MQL, 0 Off, 1 On.
    set bDumpMQL 0


# Developers Mode, allows data filters to be applied to limit ouptut data.
# When set to 1 will use file input to set data to report on.
# When set to 0 will use the database and report all schema.

    set aInclude(bMode) 0

    set aInclude(sDir) \"c:/temp/developer/include\"
    set aInclude(sMask) \"*.xls\"
    set aInclude(sDelimit) \"\\t\"

# The exclude list will remove objects from the output after the list are built.


    set aExclude(bMode) 0

    set aExclude(sDir) \"c:/temp/developer/exclude\"
    set aExclude(sMask) \"*.xls\"
    set aExclude(sDelimit) \"\\t\"



    ###########################################################################
    # Do Not edit below this line
    #

    # create OutPut Directory
    if { $sRootDir == \"\" } {
        if { $tcl_platform(platform) == \"windows\" } {
            set Temp_Directory $env(TEMP)
        } elseif { $tcl_platform(platform) == \"unix\" } {
            set Temp_Directory $env(TMPDIR)
        }
    } else {
        set Temp_Directory $sRootDir
    }

    if { $bOverWrite } {
        set Out_Directory [file nativename \"$Temp_Directory/${sOutputDir}\"]
        if { [ file isdirectory $Out_Directory ] == 1 } {
            if {$bStatus} {puts \"Delete existing directories ...\"}
            set lDirDelete [ list ]
            set lDel [ list Images Policy Programs Spinner ]
            foreach i $lDel {
                lappend lDirDelete [ file join $Out_Directory $i ]
            }
            set lFiles [ glob -nocomplain [ file join $Out_Directory *.html ] ]
            if { [llength $lFiles] != 0 } {
                set lDirDelete [concat $lDirDelete $lFiles ]
            }
            foreach sDirDelete $lDirDelete {
                if { [ catch { file delete -force $sDirDelete } sMsg] } {
                    puts stderr \"Unable to delete $sDirDelete, Message:\\n$sMsg\"
                    exit 1
                } else {
                    if {$bStatus} {puts \"Directory $sDirDelete Deleted.\"}
                }
            }
        }
    } else {
        set Out_Directory [file nativename \"$Temp_Directory/${sOutputDir}_[clock format [clock seconds] -format \"%Y%m%d%-%H%M%S\"]\"]
    }

    if { $bStatus } { puts \"OutPut dir set to $Out_Directory\" }

    eval [ mql print program emxSchema_Dumper.tcl select code dump ]

    mql verbose off
    
    # Initialize arrays
    array set Attribute_Types {}
    array set Attribute_Relationships {}
    array set Format_Policies {}
    array set Location_Store {}
    array set Location_Site {}
    array set Store_Policy {}
    array set Statistic {}
    array set aAdmin {}
    array set aDirs {}

    Generate \"\"

    exit 0

}
" 1 0 0 0 0 0 0 0 0 0 0 0 "" 0 0
 0 1
 SpinnerAgent NULL noname "3/27/2017 3:41:27 PM" 0
"12/6/2015 10:41:19 PM" "12/29/2017 7:11:29 PM"
10
 0 1 "12/6/2015 10:41:19 PM" creator "add program emxDumper_1.tcl mql execute immediate !needsbusinessobject !downloadable !pipe !pooled nothidden file ./Business/SourceFiles/emxDumper_1.tcl"
 0 2 "12/6/2015 10:41:19 PM" creator "mod program emxDumper_1.tcl description 'Generates HTML documentation for the current schema. Runs in command line mode'"
 0 2 "12/6/2015 10:41:19 PM" creator "add property SpinnerAgent on program emxDumper_1.tcl value '12/6/2015 10:41:19 PM'"
 0 2 "12/6/2015 11:31:49 PM" creator "mod program emxDumper_1.tcl file ./Business/SourceFiles/emxDumper_1.tcl"
 0 2 "12/6/2015 11:31:49 PM" creator "mod property SpinnerAgent on program emxDumper_1.tcl value '12/6/2015 11:31:49 PM'"
 0 2 "2/3/2016 5:21:00 PM" creator "mod program emxDumper_1.tcl file ./Business/SourceFiles/emxDumper_1.tcl"
 0 2 "2/3/2016 5:21:00 PM" creator "mod property SpinnerAgent on program emxDumper_1.tcl value '2/3/2016 5:21:00 PM'"
 0 2 "3/27/2017 3:41:27 PM" creator "mod program emxDumper_1.tcl file ./Business/SourceFiles/emxDumper_1.tcl"
 0 2 "3/27/2017 3:41:27 PM" creator "mod property SpinnerAgent on program emxDumper_1.tcl value '3/27/2017 3:41:27 PM'"
 0 2 "12/29/2017 7:11:29 PM" creator "  modify program emxDumper_1.tcl !pipe code \"tcl;   eval {  set sHost [info host]  if { $sHost == \"mostermant43\" } { source \"c:/Program Files/TclPro1.3/win32-ix86/bin/prodebug.tcl\" set cmd \"debugger_eval\" set xxx [debugger_init]  } else { puts \"Host not registered for TclDebugger\" set cmd \"eval\" }  }  $cmd {   set sRootDir \"c:/temp\"   set sOutputDir \"Business_Model\"   set bOverWrite 0   set bStatus 1   set bSuppressHidden 0   set bSuppressAdmReporting 0   set bDumpSchema 0  set sHeaderTitle \"Schema Agent\"  set bSVG 0  set bExtendedProgram 1  set bExtendedPolicy 1   set bDumpSpinner 1   set bDumpMQL 0    set aInclude(bMode) 0  set aInclude(sDir) \"c:/temp/developer/include\" set aInclude(sMask) \"*.xls\" set aInclude(sDelimit) \"\\t\"    set aExclude(bMode) 0  set aExclude(sDir) \"c:/temp/developer/exclude\" set aExclude(sMask) \"*.xls\" set aExclude(sDelimit) \"\\t\"    ########################################################################### # Do Not edit below this line #  # create OutPut Directory if { $sRootDir == \"\" } { if { $tcl_platform(platform) == \"windows\" } { set Temp_Directory $env(TEMP) } elseif { $tcl_platform(platform) == \"unix\" } { set Temp_Directory $env(TMPDIR) } } else { set Temp_Directory $sRootDir }  if { $bOverWrite } { set Out_Directory [file nativename \"$Temp_Directory/${sOutputDir}\"] if { [ file isdirectory $Out_Directory ] == 1 } { if {$bStatus} {puts \"Delete existing directories ...\"} set lDirDelete [ list ] set lDel [ list Images Policy Programs Spinner ] foreach i $lDel { lappend lDirDelete [ file join $Out_Directory $i ] } set lFiles [ glob -nocomplain [ file join $Out_Directory *.html ] ] if { [llength $lFiles] != 0 } { set lDirDelete [concat $lDirDelete $lFiles ] } foreach sDirDelete $lDirDelete { if { [ catch { file delete -force $sDirDelete } sMsg] } { puts stderr \"Unable to delete $sDirDelete, Message:\\n$sMsg\" exit 1 } else { if {$bStatus} {puts \"Directory $sDirDelete Deleted.\"} } } } } else { set Out_Directory [file nativename \"$Temp_Directory/${sOutputDir}_[clock format [clock"

!MTRX!END

!MTRX!AD! program emxSchema_Dumper.tcl "3DEXPERIENCE R2015x(24.0.0.0)"
emxSchema_Dumper.tcl 0 "" "################################################################################
#
#  Version 10.8.0 (Build 8.3.31)
#  Modified by M.Osterman to add 10.8 features 
#  Spinner dumper routines
################################################################################



################################################################################
# Add_Value_Element_To_Array
#   Add value element to array
#
#   Parameters :
#       array_name
#       element
#       value
#   Return : none
#
proc Add_Value_Element_To_Array { array_tab element value } {
    upvar $array_tab $array_tab
    set array_name $array_tab

    if { [array exists $array_name] != 1 } {
        set ${array_name}($element) [list $value]
    } else {
        if { [lsearch -exact [array names $array_name] $element] != -1 } {
            lappend ${array_name}($element) $value
        } else {
            set ${array_name}($element) [list $value]
        }
    }
    return
}


################################################################################
# Replace_Space
#   Replace space characters by underscore
#
#   Parameters :
#       string
#   Return :
#       string
#
proc Replace_Space { string } {
    regsub -all -- \" \" $string \"_\" string
    return $string
}
#End Replace_Space


################################################################################
# pGenTrig
#   Processes Trigger data that contains { and } one char at a time.
#   Note: Make sure { and } match, even in comments!!!!
#
#   Parameters :
#       string
#   Return :
#       string
#

proc pGenTrig { sData } {

    set temp_data \"\"
    set sData [ string trim $sData ]
    set nLen [ string length $sData ]
    
    for {set x 8} {$x<$nLen} {incr x} {
    
        set i [string index $sData $x]
        
        if { $i == \":\" } {
            append temp_data $sTag \" \"
            set sTag \"\"
        } elseif { $i == \"(\" } {
            set bInside TRUE
            append temp_data $sTag \" \"
            set sTag \"\"
        } elseif { $i == \")\" } {
            set bInside FALSE
            append temp_data $sTag
            set sTag \"\"
        } elseif { $i == \",\" && $bInside ==\"FALSE\" } {
            append temp_data \"<BR>\"
            set sTag \"\"
        } else {
            append sTag $i
        }
    }
    return $temp_data
}
# End pGenTrig


################################################################################
# pCheckHidden
#   Test to see if hidden should be enforced.
#
#   Parameters :
#       
#   Return :
#       list
#
proc pCheckHidden { lContent sType } {

    upvar aAdmin aAdmin
    
    set lOk [ list ]
    set lAllowed $aAdmin($sType)
    
    foreach sName $lContent {
        if { [lsearch $lAllowed $sName] != \"-1\" } {
        #add to list
            lappend lOk $sName
        }
    }
    return $lOk
}
#End pCheckHidden


################################################################################
# Generate_type
#   Generate HTML page for types
#
#   Parameters : none
#   Return : none
#
proc Generate_type {} {
    upvar  Attribute_Types Attribute_Types
    upvar aAdmin aAdmin
    global Out_Directory Out_Directory
    global Image_Directory Image_Directory
    global sDumpProperties
    global bDumpSchema
    global bDumpSpinner
    global bSuppressHidden

    set lProp [list ]

    # Get definition instances
    set Object \"type\"
    set Instances $aAdmin($Object)

    # Head of HTML page
    set Page_Content \"
        <HTML>
        <HEAD>
        <TITLE>$Object</TITLE>
        </HEAD>
        <BODY>
    \"

    # Body of HTML page
    foreach instance $Instances {
        if {[catch {set Content [lrange [split [mql print $Object $instance] \\n] 1 end]} sMsg] != 0} {continue}

        # Get type icon
        set Icon_Filename \"[Replace_Space $instance].gif\"
        catch { mql icon type \"$instance\" file \"$Icon_Filename\" dir $Image_Directory }
        if { [file exists $Image_Directory/$Icon_Filename] == 0 } {
            set Icon_Filename matrix_type.gif
        }

        append Page_Content \"
            <A NAME=\\\"[Replace_Space $instance]\\\">
            <TABLE BORDER=0>
            <TR>
            <TD ALIGN=RIGHT BGCOLOR=#F5F5F5 WIDTH=150><IMG ALIGN=ABSBOTTOM SRC=Images/$Icon_Filename BORDER=0 HSPACE=15><FONT SIZE=+1>$Object</FONT></TD>
            <TD ALIGN=LEFT BGCOLOR=#F5F5F5 VALIGN=BOTTOM><FONT SIZE=+1>$instance</FONT></TD>
            </TR>
            </A>\"

        foreach item $Content {

            # Case 'inherited method'
            if { [string match \"*inherited method*\" $item] == 1 } {
                set item [split $item]
                set item_name [join [lrange $item 2 3]]
                set item_content [split [lrange $item 4 end] ,]
                set temp_item \"\"
                foreach program $item_content {
                    append temp_item \"<A HREF=\\\"program.html#[Replace_Space $program]\\\">$program</A> \"
                }
                set item_content $temp_item

            # Case 'inherited attribute'
            } elseif { [string match \"*inherited attribute*\" $item] == 1 } {
                set item [split $item]
                set item_name [join [lrange $item 2 3]]
                set item_content [split [lrange $item 4 end] ,]
                set temp_item \"\"
                if {$bSuppressHidden} {set item_content [ pCheckHidden $item_content attribute ]}
                foreach attribute $item_content {
                    append temp_item \"<A HREF=\\\"attribute.html#[Replace_Space $attribute]\\\">$attribute</A>  \"

                    # Update Attribute_Types array
                    Add_Value_Element_To_Array Attribute_Types $attribute $instance
                }
                set item_content $temp_item

            # Case 'inherited form'
            } elseif { [string match \"*inherited form*\" $item] == 1 } {
                set item [split $item]
                set item_name [join [lrange $item 2 3]]
                set item_content [split [lrange $item 4 end] ,]
                set temp_item \"\"
                foreach form $item_content {
                    append temp_item \"<A HREF=\\\"form.html#[Replace_Space $form]\\\">$form</A>  \"
                }
                set item_content $temp_item

            # Case 'inherited trigger'
            } elseif { [string match \"*inherited trigger*\" $item] == 1 } {
                set sTrigger $item
                set item [split $item]
                set item_name [join [lrange $item 2 3]]
                set item_content [split [lrange $item 4 end] ,]
                if { [ string match \"*\\{*\\}*\" $sTrigger ] == 0 } {
                    set item_content [Generate_TriggerLinks $item_content $Object $instance]
                } else {
                    set item_content [pGenTrig $sTrigger]
                }

            } else {
                set sTrigger $item
                set item [split $item]
                set item_name [lindex $item 2]

                # Case 'attribute'
                if { $item_name == \"attribute\" } {
                    set item_content [split [lrange $item 3 end] ,]
                    set temp_item \"\"
                    if {$bSuppressHidden} {set item_content [pCheckHidden $item_content attribute]}
                    foreach attribute $item_content {
                        append temp_item \"<A HREF=\\\"attribute.html#[Replace_Space $attribute]\\\">$attribute</A>  \"

                        # Update Attribute_Types arrays
                        Add_Value_Element_To_Array Attribute_Types $attribute $instance
                    }
                    set item_content $temp_item

                # Case 'method'
                } elseif { $item_name == \"method\" } {
                    set item_content [split [lrange $item 3 end] ,]
                    set temp_item \"\"
                    if {$bSuppressHidden} {set item_content [pCheckHidden $item_content program]}
                    foreach program $item_content {
                        append temp_item \"<A HREF=\\\"program.html#[Replace_Space $program]\\\">$program</A>  \"
                    }
                    set item_content $temp_item

                # Case 'form'
                } elseif { $item_name == \"form\" } {
                    set item_content [split [lrange $item 3 end] ,]
                    set temp_item \"\"
                    foreach form $item_content {
                        append temp_item \"<A HREF=\\\"form.html#[Replace_Space $form]\\\">$form</A>  \"
                    }
                    set item_content $temp_item

                # Case 'policy'
                } elseif { $item_name == \"policy\" } {
                    set item_content [split [lrange $item 3 end] ,]
                    set temp_item \"\"
                    foreach policy $item_content {
                        append temp_item \"<A HREF=\\\"policy.html#[Replace_Space $policy]\\\">$policy</A>  \"
                    }
                    set item_content $temp_item

                # Case 'trigger'
                } elseif { $item_name == \"trigger\" } {
                    set item_content [split [lrange $item 3 end] ,]
                    if { [ string match \"*\\{*\\}*\" $sTrigger ] == 0 } {
                        set item_content [Generate_TriggerLinks $item_content $Object $instance]
                    } else {
                        set item_content [pGenTrig $sTrigger]
                    }

                # Case 'derivative'
                } elseif { $item_name == \"derivative\" } {
                    set item_content [split [mql print type $instance select derivative dump |] |]
                    set temp_item \"\"
                    foreach type $item_content {
                        append temp_item \"<A HREF=\\\"type.html#[Replace_Space $type]\\\">$type</A>  \"
                    }
                    set item_content $temp_item

                # Case 'derived'
                } elseif { $item_name == \"derived\" } {
                    set item_content [join [lrange $item 3 end]]
                    set item_content \"<A HREF=\\\"type.html#[Replace_Space $item_content]\\\">$item_content</A>\"

                # Case 'property'
                # Extract property name and property value
                } elseif { $item_name == \"property\" } {
                    set property [lrange $item 3 end]
                    set value_index [lsearch -exact $property \"value\"]
                    if { $value_index != -1 } {
                        set item_name [join [lrange $property 0 [expr $value_index -1]]]
                        set item_content [join [lrange $property [expr $value_index +1] end]]
                    } else {
                        set item_content [join [lrange $item 3 end]]
                    }
                    lappend lProp \"$item_name \\t $item_content\"

                # Default case
                } else {
                    set item_content [join [lrange $item 3 end]]
                }
            }

            append Page_Content \"<TR>
                  <TD ALIGN=RIGHT BGCOLOR=#DCDCDC WIDTH=150><B><FONT SIZE=-1>$item_name</B></FONT></TD>
                  <TD ALIGN=LEFT><FONT SIZE=-1>$item_content</FONT></TD>
                </TR>\"
        }

        if { [ llength $lProp ] > 0 } {
            set lProp [ join $lProp \\n ]
#            if { $bDumpSpinner } { pfile_write [ file join $sDumpProperties ${Object}_${instance}.xls ] $lProp }
        }
        set lProp [list ]

        set From_Rel [split [mql print type $instance select fromrel dump |] |]
        set temp \"\"
        foreach relation $From_Rel {
            append temp \"<A HREF=\\\"relationship.html#[Replace_Space $relation]\\\">$relation</A>  \"
        }
        set From_Rel $temp
        append Page_Content \"<TR>
                          <TD ALIGN=RIGHT BGCOLOR=#DCDCDC WIDTH=150><B><FONT SIZE=-1>from relation</B></FONT></TD>
                         <TD ALIGN=LEFT><FONT SIZE=-1>$From_Rel</FONT></TD>
                        </TR>\"
        set To_Rel [split [mql print type $instance select torel dump |] |]
        set temp \"\"
        foreach relation $To_Rel {
            append temp \"<A HREF=\\\"relationship.html#[Replace_Space $relation]\\\">$relation</A>  \"
        }
        set To_Rel $temp
        append Page_Content \"<TR>
              <TD ALIGN=RIGHT BGCOLOR=#DCDCDC WIDTH=150><B><FONT SIZE=-1>to relation</B></FONT></TD>
              <TD ALIGN=LEFT><FONT SIZE=-1>$To_Rel</FONT></TD>
              </TR>\"

        append Page_Content \"\\n</TABLE><BR><BR>\"
    }

    append Page_Content \"
        </BODY>
        </HTML>
    \"


        if { $bDumpSchema } { 
           if {$Object != \"index\"} {
              pfile_write [ file join $Out_Directory ${Object}.html ] $Page_Content
           } else {
              pfile_write [ file join $Out_Directory index_.html ] $Page_Content
           }
        }
              
}

################################################################################
# Generate_attribute
#   Generate HTML page for attributes
#
#   Parameters : none
#   Return : none
#
proc Generate_attribute {} {
    upvar Attribute_Types Attribute_Types
    upvar Attribute_Relationships Attribute_Relationships
    upvar aAdmin aAdmin
    
    global Out_Directory

    global sDumpProperties
    global bDumpSchema
    global bDumpSpinner

    # Get definition instances
    set Object \"attribute\"
    set Instances $aAdmin($Object)
    
    set lProp [ list ]

    # Head of HTML page
    set Page_Content \"
        <HTML>
        <HEAD>
        <TITLE>$Object</TITLE>
        </HEAD>
        <BODY>
    \"

    # Body of HTML page
    foreach instance $Instances {

        if {[catch {set Content [lrange [split [mql print $Object $instance] \\n] 1 end]} sMsg] != 0} {continue}

        append Page_Content \"
            <A NAME=\\\"[Replace_Space $instance]\\\">
            <TABLE BORDER=0>
            <TR>
            <TD ALIGN=RIGHT BGCOLOR=#F5F5F5 WIDTH=150><FONT SIZE=+1>$Object</FONT></TD>
            <TD ALIGN=LEFT BGCOLOR=#F5F5F5><FONT SIZE=+1>$instance</FONT></TD>
            </TR>
            </A>\"

        foreach item $Content {
            set sTrigger $item
            set item [split $item]
            set item_name [lindex $item 2]

            # Case 'property'
            # Extract property name and property value
            if { $item_name == \"property\" } {
                set property [lrange $item 3 end]
                set value_index [lsearch -exact $property \"value\"]
                if { $value_index != -1 } {
                    set item_name [join [lrange $property 0 [expr $value_index -1]]]
                    set item_content [join [lrange $property [expr $value_index +1] end]]
                } else {
                    set item_content [join [lrange $item 3 end]]
                }

            lappend lProp \"$item_name \\t $item_content\"

            # Case 'trigger'
            } elseif { $item_name == \"trigger\" } {
                set item_content [split [lrange $item 3 end] ,]
                if { [ string match \"*\\{*\\}*\" $sTrigger ] == 0 } {
                    set item_content [Generate_TriggerLinks $item_content $Object $instance]
                } else {
                    set item_content [pGenTrig $sTrigger]
                }

            # Default case
            } else {
                set item_content [join [lrange $item 3 end]]
            }
            append Page_Content \"<TR>
                  <TD ALIGN=RIGHT BGCOLOR=#DCDCDC WIDTH=150><B><FONT SIZE=-1>$item_name</B></FONT></TD>
                  <TD ALIGN=LEFT><FONT SIZE=-1>$item_content</FONT></TD>
                </TR>\"
        }
        
        if { [ llength $lProp ] > 0 } {
            set lProp [ join $lProp \\n ]
#            if { $bDumpSpinner } { pfile_write [ file join $sDumpProperties ${Object}_${instance}.xls ] $lProp }
        }
        set lProp [list ]

        # Types using current attribute
        set Parent_Types \"\"
        if { [lsearch -exact [array names Attribute_Types] $instance] != -1 } {
            foreach type $Attribute_Types($instance) {
                append Parent_Types \"<A HREF=\\\"type.html#[Replace_Space $type]\\\">$type</A>  \"
            }
            append Page_Content \"<TR>
                      <TD ALIGN=RIGHT BGCOLOR=#DCDCDC WIDTH=150><B><FONT SIZE=-1>Used in type(s)</B></FONT></TD>
                      <TD ALIGN=LEFT><FONT SIZE=-1>$Parent_Types</FONT></TD>
                    </TR>\"
        }

        # Relationships using current attribute
        set Parent_Relationship \"\"
        if { [lsearch -exact [array names Attribute_Relationships] $instance] != -1 } {
            foreach relation $Attribute_Relationships($instance) {
                append Parent_Relationship \"<A HREF=\\\"relationship.html#[Replace_Space $relation]\\\">$relation</A>  \"
            }
            append Page_Content \"<TR>
                      <TD ALIGN=RIGHT BGCOLOR=#DCDCDC WIDTH=150><B><FONT SIZE=-1>Used in relationship(s)</B></FONT></TD>
                      <TD ALIGN=LEFT><FONT SIZE=-1>$Parent_Relationship</FONT></TD>
                    </TR>\"
        }

        append Page_Content \"\\n</TABLE><BR><BR>\"
    }

    append Page_Content \"
        </BODY>
        </HTML>
    \"

        if { $bDumpSchema } { pfile_write [ file join $Out_Directory ${Object}.html ] $Page_Content }
}



################################################################################
# Generate_relationship
#   Generate HTML page for relationship
#
#   Parameters : none
#   Return : none
#
proc Generate_relationship {} {
    upvar Attribute_Types Attribute_Types
    upvar Attribute_Relationships Attribute_Relationships
    upvar aAdmin aAdmin

    global Out_Directory
    global sDumpProperties
    global bDumpSchema
    global bDumpSpinner
    global bSuppressHidden

    set lProp [list ]

    # Get definition instances
    set Object \"relationship\"
    set Instances $aAdmin($Object)

    # Head of HTML page
    set Page_Content \"
        <HTML>
        <HEAD>
        <TITLE>$Object</TITLE>
        </HEAD>
        <BODY>
    \"

    # Body of HTML page
    foreach instance $Instances {

        if {[catch {set Content [lrange [split [mql print $Object $instance] \\n] 1 end]} sMsg] != 0} {continue}

        append Page_Content \"
            <A NAME=\\\"[Replace_Space $instance]\\\">
            <TABLE BORDER=0>
            <TR>
            <TD ALIGN=RIGHT BGCOLOR=#F5F5F5 WIDTH=150><FONT SIZE=+1>$Object</FONT></TD>
            <TD ALIGN=LEFT BGCOLOR=#F5F5F5><FONT SIZE=+1>$instance</FONT></TD>
            </TR>
            </A>\"

        foreach item $Content {
            set sTrigger $item
            set item [split $item]
            set item_name [lindex $item 2]
            set skip_line FALSE

            # Case 'trigger'
            if { $item_name == \"trigger\" } {
                set item_content [split [lrange $item 3 end] ,]
                if { [ string match \"*\\{*\\}*\" $sTrigger ] == 0 } {
                    set item_content [Generate_TriggerLinks $item_content $Object $instance]
                } else {
                    set item_content [pGenTrig $sTrigger]
                }

            # Case 'attribute'
            } elseif { $item_name == \"attribute\" } {
                set item_content [split [lrange $item 3 end] ,]
                set temp_item \"\"
                if {$bSuppressHidden} {set item_content [pCheckHidden $item_content attribute]}
                foreach attribute $item_content {
                    append temp_item \"<A HREF=\\\"attribute.html#[Replace_Space $attribute]\\\">$attribute</A>\"

                    # Update Attribute_Relationships array
                    Add_Value_Element_To_Array Attribute_Relationships $attribute $instance
                }
                set item_content $temp_item

            # Case 'from' and 'to'
            } elseif { ($item_name == \"from\") || ($item_name == \"to\") } {
                set item_content [split [mql print relationship $instance select ${item_name}type dump |] |]
                set temp_item \"\"
                foreach type $item_content {
                    append temp_item \"<A HREF=\\\"type.html#[Replace_Space $type]\\\">$type</A> \"
                }
                set item_content $temp_item

            # Case 'type'
            } elseif { [string match \"*type*\" [join [lrange $item 3 end]]] == 1 } {
                set skip_line TRUE

            # Case 'property'
            # Extract property name and property value
            } elseif { $item_name == \"property\" } {
                set property [lrange $item 3 end]
                set value_index [lsearch -exact $property \"value\"]
                if { $value_index != -1 } {
                    set item_name [join [lrange $property 0 [expr $value_index -1]]]
                    set item_content [join [lrange $property [expr $value_index +1] end]]
                } else {
                    set item_content [join [lrange $item 3 end]]
                }
                lappend lProp \"$item_name \\t $item_content\"
                    
            # Default case
            } else {
                set item_content [join [lrange $item 3 end]]
            }

            # Skip 'type' line
            if { $skip_line == \"FALSE\" } {
                append Page_Content \"<TR>
                      <TD ALIGN=RIGHT BGCOLOR=#DCDCDC WIDTH=150><B><FONT SIZE=-1>$item_name</B></FONT></TD>
                      <TD ALIGN=LEFT><FONT SIZE=-1>$item_content</FONT></TD>
                    </TR>\"
            }
            if { [ llength $lProp ] > 0 } {
                set lProp [ join $lProp \\n ]
#                if { $bDumpSpinner } { pfile_write [ file join $sDumpProperties ${Object}_${instance}.xls ] $lProp }
            }
            set lProp [list ]
        }

        append Page_Content \"\\n</TABLE><BR><BR>\"
    }

    append Page_Content \"
        </BODY>
        </HTML>
    \"

        if { $bDumpSchema } { pfile_write [ file join $Out_Directory ${Object}.html ] $Page_Content }
}

################################################################################
# Generate_policy
#   Generate HTML page for policy
#
#   Parameters : none
#   Return : none
#
proc Generate_policy {} {
    upvar Format_Policies Format_Policies
    upvar Store_Policy Store_Policy
    upvar aAdmin aAdmin

    global bExtendedPolicy
    global Out_Directory
    global sDumpProperties
    global bDumpSchema
    global bDumpSpinner
    global bSVG
    
    set lProp [list ]

    # Get definition instances
    set Object \"policy\"
    set Instances $aAdmin($Object)

    # Head of HTML page
    set Page_Content \"
        <HTML>
        <HEAD>
        <TITLE>$Object</TITLE>
        </HEAD>
        <BODY>
    \"

    # Body of HTML page
    foreach instance $Instances {

        if {[catch {set Content [lrange [split [mql print $Object $instance] \\n] 1 end]} sMsg] != 0} {continue}

        set sNoSpace [Replace_Space $instance]

        append Page_Content \"
            <A NAME=\\\"$sNoSpace\\\"
            <h1><B>$Object $instance</B></h1>
            </A>\"


        if {$bSVG} {
            append Page_Content \"
                <center>
                <object type=\\\"image/svg-xml\\\" width=\\\"700\\\" height=\\\"200\\\" data=\\\"Images/${sNoSpace}.svg\\\">
                Should not happen
                </object>
                </center>
            \"
        #Get the lifecycle state names.
        set lPolicyStateName [split [mql print policy \"$instance\" select state dump |] |]
        set sText \"\"
        set x 10
        set y 10
        foreach sStateName $lPolicyStateName {

            append sText \"<use x=\\\"$x\\\" y=\\\"$y\\\" xlink:href=\\\"#rect\\\"/>
                <text x=\\\"[expr $x + 5]\\\" y=\\\"[expr $y + 15]\\\"
                font-size=\\\"10\\\"
                font-family=\\\"Arial\\\"
                fill=\\\"black\\\"
                text-anchor=\\\"start\\\"
                dominant-baseline=\\\"mathematical\\\">$sStateName</text>\"
                incr x 150
        }

        # Create lifecycle
            set sDataSVG \"<?xml version=\\\"1.0\\\" encoding=\\\"iso-8859-1\\\"?>
<!DOCTYPE svg PUBLIC \\\"-//W3C//DTD SVG 20000303 Stylable//EN\\\"
\\\"http://www.w3.org/TR/2000/03/WD-SVG-20000303/DTD/svg-20000303-stylable.dtd\\\">
<svg xml:space=\\\"preserve\\\" width=\\\"5.0in\\\" height=\\\"2.5in\\\">
<defs>
    <rect id=\\\"rect\\\" width=\\\"90\\\" height=\\\"30\\\" fill=\\\"none\\\" stroke=\\\"blue\\\" stroke-width=\\\"2\\\"
/>
</defs>
$sText
</svg>
            \"
            pfile_write [file join $Out_Directory Images ${sNoSpace}.svg] $sDataSVG
        }

        append Page_Content \"
            <TABLE BORDER=0>
        \"


#        append Page_Content \"
#            <A NAME=\\\"[Replace_Space $instance]\\\">
#            <TABLE BORDER=0>
#            <TR>
#            <TD ALIGN=RIGHT BGCOLOR=#F5F5F5 WIDTH=150><FONT SIZE=+1>$Object</FONT></TD>
#            <TD ALIGN=LEFT BGCOLOR=#F5F5F5><FONT SIZE=+1>$instance</FONT></TD>
#            </TR>
#            </A>
#        \"

        if { $bExtendedPolicy == \"1\" } {
            append Page_Content \"
                <TR>
                <TD ALIGN=RIGHT BGCOLOR=#DCDCDC><B><FONT SIZE=-1>State Access Info</B></FONT></TD>
                <TD ALIGN=LEFT BGCOLOR=#F5F5F5><FONT SIZE=-1><A HREF=\\\"Policy/[Replace_Space $instance].html\\\">$instance</A></FONT></TD>
                </TR>\"
        }

        set sCurrentState \"\"
        foreach item $Content {

            set sTrigger $item
            set item [split $item]
            set item_name [lindex $item 2]
            set sub_item_name [lindex $item 4]

            # Case 'type'
            if { $item_name == \"type\" } {
                set item_content [split [lrange $item 3 end] ,]
                set temp_item \"\"
                foreach type $item_content {
                    append temp_item \"<A HREF=\\\"type.html#[Replace_Space $type]\\\">$type</A>  \"
                }
                set item_content $temp_item

            # Case 'store'
            } elseif { $item_name == \"store\" } {
                set item_content [split [lrange $item 3 end] ,]
                Add_Value_Element_To_Array Store_Policy $item_content $instance
                set temp_item \"\"
                foreach store $item_content {
                    append temp_item \"<A HREF=\\\"store.html#[Replace_Space $store]\\\">$store</A>  \"
                }
                set item_content $temp_item

            # Case 'format'
            } elseif { $item_name == \"format\" } {
                set item_content [split [lrange $item 3 end] ,]
                set temp_item \"\"
                foreach format $item_content {
                    append temp_item \"<A HREF=\\\"format.html#[Replace_Space $format]\\\">$format</A>  \"

                    # Update Format_Policies
                    Add_Value_Element_To_Array Format_Policies $format $instance
                }
                set item_content $temp_item

            # Case 'defaultformat'
            } elseif { $item_name == \"defaultformat\" } {
                set item_content [join [lrange $item 3 end]]
                set item_content \"<A HREF=\\\"format.html#[Replace_Space $item_content]\\\">$item_content</A>\"

            # Case 'trigger'
            } elseif { $sub_item_name == \"trigger\" } {
                set item_content [split [lrange $item 5 end] ,]
                if { [ string match \"*\\{*\\}*\" $sTrigger ] == 0 } {
                    set item_content [Generate_TriggerLinks $item_content $Object $instance]
                } else {
                    set item_content [pGenTrig $sTrigger]
                }

            # Case 'property'
            # Extract property name and property value
            } elseif { $item_name == \"property\" } {
                set property [lrange $item 3 end]
                set value_index [lsearch -exact $property \"value\"]
                if { $value_index != -1 } {
                    set item_name [join [lrange $property 0 [expr $value_index -1]]]
                    set item_content [join [lrange $property [expr $value_index +1] end]]
                } else {
                    set item_content [join [lrange $item 3 end]]
                }
                lappend lProp \"$item_name \\t $item_content\"
                    
            } elseif { $item_name == \"state\" } {
#                set sCurrentState $item_content
                set item_content [join [lrange $item 3 end]]
            # Default case
            } else {
                set item_content [join [lrange $item 3 end]]
            }
            append Page_Content \"<TR>
                  <TD ALIGN=RIGHT BGCOLOR=#DCDCDC><B><FONT SIZE=-1>$item_name</B></FONT></TD>
                  <TD ALIGN=LEFT><FONT SIZE=-1>$item_content</FONT></TD>
                </TR>\"
        }
        if { [ llength $lProp ] > 0 } {
            set lProp [ join $lProp \\n ]
#            if { $bDumpSpinner } { pfile_write [ file join $sDumpProperties ${Object}_${instance}.xls ] $lProp }
        }
        set lProp [list ]
        append Page_Content \"\\n</TABLE><BR><BR>\"
    }

    append Page_Content \"
        </BODY>
        </HTML>
    \"

        if { $bDumpSchema } { pfile_write [ file join $Out_Directory ${Object}.html ] $Page_Content }
}



################################################################################
# Generate_program
#   Generate HTML page for program
#
#   Parameters : none
#   Return : none
#
proc Generate_program {} {
    upvar Out_Directory Out_Directory
    upvar aAdmin aAdmin
    global bExtendedProgram
    global sDumpProperties
    global bDumpSchema
    global bDumpSpinner

    set lProp [list ]
    # Get definition instances
    set Object \"program\"
    set Instances $aAdmin($Object)

    # Head of HTML page
    set Page_Content \"
        <HTML>
        <HEAD>
        <TITLE>$Object</TITLE>
        </HEAD>
        <BODY>
    \"

    # Body of HTML page
    foreach instance $Instances {
        append Page_Content \"
            <A NAME=\\\"[Replace_Space $instance]\\\">
            <TABLE BORDER=0>
            <TR>
            <TD ALIGN=RIGHT BGCOLOR=#F5F5F5 WIDTH=150><FONT SIZE=+1>$Object</FONT></TD>
            <TD ALIGN=LEFT BGCOLOR=#F5F5F5><FONT SIZE=+1>$instance</FONT></TD>
            </TR>
            </A>\"

        set Selectables {description hidden ismqlprogram doesneedcontext code iswizardprogram doesuseinterface execute isamethod isafunction type downloadable property}

        foreach item_name $Selectables {

            # Case 'code'
            if { $item_name == \"code\" && $bExtendedProgram == \"1\" } {
                if {[catch {set item_content [mql print program $instance select $item_name dump]} sMsg] != 0} {continue}
                regsub -all -- \\\" $item_content \\\\\\\" item_content

                # Create a file containing the code
                regsub -all -- \"/\" $instance \"_\" program_filename
                regsub -all -- \" \" $program_filename \"_\" program_filename
                regsub -all -- \":\" $program_filename \"_\" program_filename
                regsub -all -- \"\\134\\174\" $program_filename \"_\" program_filename
                regsub -all -- \">\" $program_filename \"_\" program_filename
                regsub -all -- \"<\" $program_filename \"_\" program_filename
                set program_filename Programs/${program_filename}.txt
                set program_file [open $Out_Directory/$program_filename w+]
                puts $program_file $item_content
                close $program_file

                append Page_Content \"<TR>
                      <TD ALIGN=RIGHT BGCOLOR=#DCDCDC><B><FONT SIZE=-1>$item_name</B></FONT></TD>
                      <TD ALIGN=LEFT><FONT SIZE=-1><A HREF=\\\"${program_filename}\\\">See code</A></FONT></TD>
                    </TR>\"

#            } elseif { $item_name == \"code\" && $bExtendedProgram == \"0\" } {
#                append Page_Content \"<TR>
#                      <TD ALIGN=RIGHT BGCOLOR=#DCDCDC><B><FONT SIZE=-1>$item_name</B></FONT></TD>
#                      <TD ALIGN=LEFT><FONT SIZE=-1>Code</FONT></TD>
#                    </TR>\"
            # Case 'type'
            } elseif { $item_name == \"type\" } {
                set item_content [split [mql print program $instance select $item_name dump |] |]
                set temp_item \"\"
                foreach type $item_content {
                    append temp_item \"<A HREF=\\\"type.html#[Replace_Space $type]\\\">$type</A>  \"
                }
                set item_content $temp_item
                append Page_Content \"<TR>
                      <TD ALIGN=RIGHT BGCOLOR=#DCDCDC><B><FONT SIZE=-1>$item_name</B></FONT></TD>
                      <TD ALIGN=LEFT><FONT SIZE=-1>$item_content</FONT></TD>
                    </TR>\"


            # Case 'property'
            # Extract property name and property value
            } elseif { $item_name == \"property\" } {
                set propertydata [split [mql print program $instance select property dump |] | ]
foreach property $propertydata {
#                set property [lrange $item 3 end ]
                set value_index [lsearch -exact $property \"value\"]
                if { $value_index != -1 } {
                    set item_name [join [lrange $property 0 [expr $value_index -1]]]
                    set item_content [join [lrange $property [expr $value_index +1] end]]
                } else {
                    set item_content [join $property]
                }
                lappend lProp \"$item_name \\t $item_content\"
                append Page_Content \"<TR>
                      <TD ALIGN=RIGHT BGCOLOR=#DCDCDC><B><FONT SIZE=-1>$item_name</B></FONT></TD>
                      <TD ALIGN=LEFT><FONT SIZE=-1>$item_content</FONT></TD>
                    </TR>\"
}


            # Default case
            } else {
                set item_content [mql print program $instance select $item_name dump]
                append Page_Content \"<TR>
                      <TD ALIGN=RIGHT BGCOLOR=#DCDCDC><B><FONT SIZE=-1>$item_name</B></FONT></TD>
                      <TD ALIGN=LEFT><FONT SIZE=-1>$item_content</FONT></TD>
                    </TR>\"
            }
            
        if { [ llength $lProp ] > 0 } {
            set lProp [ join $lProp \\n ]
#            if { $bDumpSpinner } { pfile_write [ file join $sDumpProperties ${Object}_${instance}.xls ] $lProp }
        }
        set lProp [list ]
            
        }

        append Page_Content \"\\n</TABLE><BR><BR>\"
    }

    append Page_Content \"
        </BODY>
        </HTML>
    \"

    if { $bDumpSchema } { pfile_write [ file join $Out_Directory ${Object}.html ] $Page_Content }
}

################################################################################
# Generate_group
#   Generate HTML page for groups
#
#   Parameters : none
#   Return : none
#
proc Generate_group {} {

    global bExtendedPolicy
    global Out_Directory
    global sDumpProperties
    global bDumpSchema
    global bDumpSpinner
    upvar aAdmin aAdmin
    set lProp [list ]

    # Get definition instances
    set Object \"group\"
    set Instances $aAdmin($Object)

    # Head of HTML page
    set Page_Content \"
        <HTML>
        <HEAD>
        <TITLE>$Object</TITLE>
        </HEAD>
        <BODY>
    \"

    # Body of HTML page
    foreach instance $Instances {

        if {[catch {set Content [lrange [split [mql print $Object $instance] \\n] 1 end]} sMsg] != 0} {continue}

        append Page_Content \"
            <A NAME=\\\"[Replace_Space $instance]\\\">
            <TABLE BORDER=0>
            <TR>
            <TD ALIGN=RIGHT BGCOLOR=#F5F5F5 WIDTH=150><FONT SIZE=+1>$Object</FONT></TD>
            <TD ALIGN=LEFT BGCOLOR=#F5F5F5><FONT SIZE=+1>$instance</FONT></TD>
            </TR>
            </A>\"

        if { $bExtendedPolicy == \"1\" } {
            append Page_Content \"
                <TR>
                <TD ALIGN=RIGHT BGCOLOR=#DCDCDC><B><FONT SIZE=-1>Group Access Info</B></FONT></TD>
                <TD ALIGN=LEFT BGCOLOR=#F5F5F5><FONT SIZE=-1><A HREF=\\\"Policy/[Replace_Space $instance].html\\\">$instance</A></FONT></TD>
                </TR>\"
        }

        set Person_List FALSE
        foreach item $Content {
            set item [split $item]
            set item_name [lindex $item 2]

            # Case 'child' or 'parent'
            if { ($item_name == \"child\") || ($item_name == \"parent\") } {
                set item_content [join [lrange $item 3 end]]
                set item_content \"<FONT SIZE=-1><A HREF=\\\"group.html#[Replace_Space $item_content]\\\">$item_content</FONT></A>\"

            # Case 'assign' or 'people'
            # Do it one time
            } elseif { ($item_name == \"assign\") || ($item_name == \"people\") } {
                if { $Person_List == \"FALSE\" } {
                    set persons [split [mql print group $instance select person dump |] |]
                    set item_content \"\"
                    foreach person $persons {
                        append item_content \"<FONT SIZE=-1><A HREF=\\\"person.html#[Replace_Space $person]\\\">$person</FONT></A> \"
                    }
                    set Person_List TRUE
                } else {
                    continue
                }

            # Case 'property'
            # Extract property name and property value
            } elseif { $item_name == \"property\" } {
                set property [lrange $item 3 end]
                set value_index [lsearch -exact $property \"value\"]
                if { $value_index != -1 } {
                    set item_name [join [lrange $property 0 [expr $value_index -1]]]
                    set item_content [join [lrange $property [expr $value_index +1] end]]
                } else {
                    set item_content [join [lrange $item 3 end]]
                }
                lappend lProp \"$item_name \\t $item_content\"
                
            # Default case
            } else {
                set item_content [join [lrange $item 3 end]]
            }
            append Page_Content \"<TR>
                  <TD ALIGN=RIGHT BGCOLOR=#DCDCDC><B><FONT SIZE=-1>$item_name</B></FONT></TD>
                  <TD ALIGN=LEFT><FONT SIZE=-1>$item_content</FONT></TD>
                </TR>\"
        }
        if { [ llength $lProp ] > 0 } {
            set lProp [ join $lProp \\n ]
#            if { $bDumpSpinner } { pfile_write [ file join $sDumpProperties ${Object}_${instance}.xls ] $lProp }
        }
        set lProp [list ]
        append Page_Content \"\\n</TABLE><BR><BR>\"
    }

    append Page_Content \"
        </BODY>
        </HTML>
    \"

        if { $bDumpSchema } { pfile_write [ file join $Out_Directory ${Object}.html ] $Page_Content }
}

################################################################################
# Generate_role
#   Generate HTML page for role
#
#   Parameters : none
#   Return : none
#
proc Generate_role {} {

    upvar aAdmin aAdmin
    global bExtendedPolicy
    global Out_Directory
    global sDumpProperties
    global bDumpSchema
    global bDumpSpinner
    
    set lProp [list ]

    # Get definition instances
    set Object \"role\"
    set Instances $aAdmin($Object)

    # Head of HTML page
    set Page_Content \"
        <HTML>
        <HEAD>
        <TITLE>$Object</TITLE>
        </HEAD>
        <BODY>
    \"


    # Body of HTML page
    foreach instance $Instances {

        if {[catch {set Content [lrange [split [mql print $Object $instance] \\n] 1 end]} sMsg] != 0} {continue}

        append Page_Content \"
            <A NAME=\\\"[Replace_Space $instance]\\\">
            <TABLE BORDER=0>
            <TR>
            <TD ALIGN=RIGHT BGCOLOR=#F5F5F5 WIDTH=150><FONT SIZE=+1>$Object</FONT></TD>
            <TD ALIGN=LEFT BGCOLOR=#F5F5F5><FONT SIZE=+1>$instance</FONT></TD>
            </TR>
            </A>\"

        if { $bExtendedPolicy == \"1\" } {
            append Page_Content \"
                <TR>
                <TD ALIGN=RIGHT BGCOLOR=#DCDCDC><B><FONT SIZE=-1>Role Access Info</B></FONT></TD>
                <TD ALIGN=LEFT BGCOLOR=#F5F5F5><FONT SIZE=-1><A HREF=\\\"Policy/[Replace_Space $instance].html\\\">$instance</A></FONT></TD>
                </TR>\"
        }

        set Person_List FALSE
        foreach item $Content {
            set item [split $item]
            set item_name [lindex $item 2]

            # Case 'child' or 'parent'
            if { ($item_name == \"child\") || ($item_name == \"parent\") } {
                set item_content [join [lrange $item 3 end]]
                set item_content \"<FONT SIZE=-1><A HREF=\\\"role.html#[Replace_Space $item_content]\\\">$item_content</FONT></A>\"

            # Case 'assign' or 'people'
            # Do it one time
            } elseif { ($item_name == \"assign\") || ($item_name == \"people\") } {
                if { $Person_List == \"FALSE\" } {
                    set persons [split [mql print role $instance select person dump |] |]
                    set item_content \"\"
                    foreach person $persons {
                        append item_content \"<FONT SIZE=-1><A HREF=\\\"person.html#[Replace_Space $person]\\\">$person</FONT></A> \"
                    }
                    set Person_List TRUE
                } else {
                    continue
                }

            # Case 'property'
            # Extract property name and property value
            } elseif { $item_name == \"property\" } {
                set property [lrange $item 3 end]
                set value_index [lsearch -exact $property \"value\"]
                if { $value_index != -1 } {
                    set item_name [join [lrange $property 0 [expr $value_index -1]]]
                    set item_content [join [lrange $property [expr $value_index +1] end]]
                } else {
                    set item_content [join [lrange $item 3 end]]
                }
                lappend lProp \"$item_name \\t $item_content\"
                
            # Default case
            } else {
                set item_content [join [lrange $item 3 end]]
            }
            append Page_Content \"<TR>
                  <TD ALIGN=RIGHT BGCOLOR=#DCDCDC><B><FONT SIZE=-1>$item_name</B></FONT></TD>
                  <TD ALIGN=LEFT><FONT SIZE=-1>$item_content</FONT></TD>
                </TR>\"
        }
        if { [ llength $lProp ] > 0 } {
            set lProp [ join $lProp \\n ]
#            if { $bDumpSpinner } { pfile_write [ file join $sDumpProperties ${Object}_${instance}.xls ] $lProp }
        }
        set lProp [list ]
        append Page_Content \"\\n</TABLE><BR><BR>\"
    }

    append Page_Content \"
        </BODY>
        </HTML>
    \"

        if { $bDumpSchema } { pfile_write [ file join $Out_Directory ${Object}.html ] $Page_Content }
}

################################################################################
# Generate_person
#   Generate HTML page for person
#
#   Parameters : none
#   Return : none
#
proc Generate_person {} {

    upvar aAdmin aAdmin
    upvar aDirs aDirs
    
    global bExtendedPolicy
    global lExtendedPersonData

    global Out_Directory
    global sDirSpinnerExport
    global sDumpProperties
    global bDumpSchema
    global bDumpSpinner

    set sDelimit \"\\t\"
    set lPerson [list ]
    set lProp [list ]
    set lPersonData [ list name fullname comment address phone fax email vault \\
        site type assign_role assign_group ]
    lappend lPerson [join $lPersonData $sDelimit]

    # Get definition instances
    set Object \"person\"
    set Instances $aAdmin($Object)

    # Head of HTML page
    set Page_Content \"
        <HTML>
        <HEAD>
        <TITLE>$Object</TITLE>
        </HEAD>
        <BODY>
    \"

    # Body of HTML page
    foreach instance $Instances {
        set aData(name) $instance
        
        if {[catch {set Content [mql print $Object $instance]} sMsg] != 0} {continue}

        regsub -all -- {\\{} $Content { LEFTBRACE } Content
        regsub -all -- {\\}} $Content { RIGHTBRACE } Content

        set Content [lrange [split $Content \\n] 1 end]
        set lAssign_Role [list ]
        set lAssign_Group [list ]

        append Page_Content \"
            <A NAME=\\\"[Replace_Space $instance]\\\">
            <TABLE BORDER=0>
            <TR>
            <TD ALIGN=RIGHT BGCOLOR=#F5F5F5 WIDTH=150><FONT SIZE=+1>$Object</FONT></TD>
            <TD ALIGN=LEFT BGCOLOR=#F5F5F5><FONT SIZE=+1>$instance</FONT></TD>
            </TR>
            </A>\"

        if { $bExtendedPolicy == \"1\"  && [lsearch $lExtendedPersonData $instance] != \"-1\" } {
            append Page_Content \"
                <TR>
                <TD ALIGN=RIGHT BGCOLOR=#DCDCDC><B><FONT SIZE=-1>Person Access Info</B></FONT></TD>
                <TD ALIGN=LEFT BGCOLOR=#F5F5F5><FONT SIZE=-1><A HREF=\\\"Policy/[Replace_Space $instance].html\\\">$instance</A></FONT></TD>
                </TR>\"
        }

        foreach item $Content {
            set item [string trimleft $item]
            set lItem [split $item]
            set item_name [lindex $lItem 0]
#            set item_content [lrange $item 1 end]
#            Change to allow for special char strings
            set nFirstWS [string first \" \" $item]
            set item_content [string range $item [expr $nFirstWS + 1] end]
            set item_content_html $item_content
            set aData($item_name) $item_content
            # Case assign
            if { $item_name == \"assign\" } {
                set user [lrange $item 2 end]
                set group_role [lindex $lItem 1]
                set item_content_html  \"<A HREF=\\\"${group_role}.html#[Replace_Space $user]\\\">$user</A>\"
                if {$group_role == \"group\"} {
                    lappend lAssign_Group $user
                } elseif {$group_role == \"role\"} {
                    lappend lAssign_Role $user
                }
            # Case lattice
            } elseif { $item_name == \"lattice\" } {
                set vault [lrange $item 1 end]
                set aData(vault) $vault
                set item_content_html  \"<A HREF=\\\"vault.html#[Replace_Space $vault]\\\">$vault</A>\"
            # Case 'property'
            # Extract property name and property value
            } elseif { $item_name == \"property\" } {
                set property [lrange $item 1 end]
                set value_index [lsearch -exact $property \"value\"]
                if { $value_index != -1 } {
                    set item_name [join [lrange $property 0 [expr $value_index -1]]]
                    set item_content [join [lrange $property [expr $value_index +1] end]]
                    set item_content_html $item_content
                } else {
                    set item_content [join [lrange $lItem 1 end]]
                    set item_content_html $item_content
                }
                lappend lProp \"$item_name \\t $item_content\"
            }
            append Page_Content \"<TR>
                  <TD ALIGN=RIGHT BGCOLOR=#DCDCDC><B><FONT SIZE=-1>$item_name</B></FONT></TD>
                  <TD ALIGN=LEFT><FONT SIZE=-1>$item_content_html</FONT></TD>
                </TR>\"
        }
        append Page_Content \"\\n</TABLE><BR><BR>\"
#        if {$bDumpSpinner} { mql export $Object $instance !mail !set into file [file join $aDirs(sDirSpinnerExport${Object}) ${instance}.exp] }
        if {[llength $lAssign_Role] == 0} {
            set aData(assign_role) \"\"
        } else {
            set lAssign_Role [lsort -dictionary $lAssign_Role]
            set sAssign_Role [join $lAssign_Role |]
            regsub -all -- {\\|} $sAssign_Role { | } sAssign_Role
            set aData(assign_role) $sAssign_Role
        }
        if {[llength $lAssign_Group] == 0} {
            set aData(assign_group) \"\"
        } else {
            set lAssign_Group [lsort -dictionary $lAssign_Group]
            set sAssign_Group [join $lAssign_Group |]
            regsub -all -- {\\|} $sAssign_Group { | } sAssign_Group
            set aData(assign_group) $sAssign_Group
        }

        set lDataEach [list ]
        foreach sPersonData $lPersonData {
            if { [ info exists aData($sPersonData) ] == 1 } {
                lappend lDataEach $aData($sPersonData)
            } else {
                lappend lDataEach \"\"
            }
        }
        lappend lPerson [join $lDataEach $sDelimit]
    }

    append Page_Content \"
        </BODY>
        </HTML>
    \"

    if {$bDumpSpinner} {pfile_write [file join $aDirs(sDumpSchemaDirBusiness) \\
        SpinnerPersonData.xls] [join $lPerson \"\\n\"]}
    if {$bDumpSchema} {pfile_write [file join $Out_Directory ${Object}.html] \\
        $Page_Content}
    return 0
}
# End Generate_person


################################################################################
# Generate_wizard
#   Generate HTML page for wizard
#
#   Parameters : none
#   Return : none
#
proc Generate_wizard {} {

    upvar Out_Directory Out_Directory
    upvar aAdmin aAdmin
    upvar aDirs aDirs
    global sDirSpinnerExport
    global bExtendedProgram
    global sDumpProperties
    global bDumpSchema
    global bDumpSpinner

    set lProp [list ]

    # Get definition instances
    set Object \"wizard\"
    set Instances $aAdmin($Object)

    # Head of HTML page
    set Page_Content \"
        <HTML>
        <HEAD>
        <TITLE>$Object</TITLE>
        </HEAD>
        <BODY>
    \"

    # Body of HTML page
    foreach instance $Instances {
        append Page_Content \"
            <A NAME=\\\"[Replace_Space $instance]\\\">
            <TABLE BORDER=0>
            <TR>
            <TD ALIGN=RIGHT BGCOLOR=#F5F5F5 WIDTH=150><FONT SIZE=+1>$Object</FONT></TD>
            <TD ALIGN=LEFT BGCOLOR=#F5F5F5><FONT SIZE=+1>$instance</FONT></TD>
            </TR>
            </A>\"

        set Selectables {description hidden ismqlprogram doesneedcontext code iswizardprogram doesuseinterface execute isamethod isafunction type downloadable property}

        # Remove execute donwloadable type selectables for Matrix version prior to 8

        foreach item_name $Selectables {

            # Case 'code'
            if { $item_name == \"code\" && $bExtendedProgram == \"1\" } {
                if {[catch {set item_content [mql print program $instance select $item_name dump]} sMsg] != 0} {continue}
                regsub -all -- \\\" $item_content \\\\\\\" item_content

                # Create a file containing the code
                regsub -all -- \"/\" $instance \"_\" program_filename
                regsub -all -- \" \" $program_filename \"_\" program_filename
                set program_filename Programs/${program_filename}.txt
                set program_file [open $Out_Directory/$program_filename w+]
                puts $program_file $item_content
                close $program_file

                append Page_Content \"<TR>
                      <TD ALIGN=RIGHT BGCOLOR=#DCDCDC><B><FONT SIZE=-1>$item_name</B></FONT></TD>
                      <TD ALIGN=LEFT><FONT SIZE=-1><A HREF=\\\"${program_filename}\\\">See code</A></FONT></TD>
                    </TR>\"

            # Case 'type'
            } elseif { $item_name == \"type\" } {
                set item_content [split [mql print program $instance select $item_name dump |] |]
                set temp_item \"\"
                foreach type $item_content {
                    append temp_item \"<A HREF=\\\"type.html#[Replace_Space $type]\\\">$type</A>  \"
                }
                set item_content $temp_item
                append Page_Content \"<TR>
                      <TD ALIGN=RIGHT BGCOLOR=#DCDCDC><B><FONT SIZE=-1>$item_name</B></FONT></TD>
                      <TD ALIGN=LEFT><FONT SIZE=-1>$item_content</FONT></TD>
                    </TR>\"

            # Case 'property'
            # Extract property name and property value
            } elseif { $item_name == \"property\" } {
                set property [split [mql print program $instance select property dump]]
                set value_index [lsearch -exact $property \"value\"]
                if { $value_index != -1 } {
                    set item_name [join [lrange $property 0 [expr $value_index -1]]]
                    set item_content [join [lrange $property [expr $value_index +1] end]]
                } else {
                    set item_content [join $property]
                }
                lappend lProp \"$item_name \\t $item_content\"
                
                append Page_Content \"<TR>
                      <TD ALIGN=RIGHT BGCOLOR=#DCDCDC><B><FONT SIZE=-1>$item_name</B></FONT></TD>
                      <TD ALIGN=LEFT><FONT SIZE=-1>$item_content</FONT></TD>
                    </TR>\"

            # Default case
            } else {
                set item_content [mql print program $instance select $item_name dump]
                append Page_Content \"<TR>
                      <TD ALIGN=RIGHT BGCOLOR=#DCDCDC><B><FONT SIZE=-1>$item_name</B></FONT></TD>
                      <TD ALIGN=LEFT><FONT SIZE=-1>$item_content</FONT></TD>
                    </TR>\"
            }
        }

        # Frame infos
        # Get all lines printed after the 'frame' info
        set Content [lrange [split [mql print $Object $instance] \\n] 1 end]
        set Frame_Infos FALSE
        foreach item $Content {
            set item [split $item]
            set item_name [lindex $item 2]
            set sub_item_name_1 [lindex $item 4]
            set sub_item_name_2 [lindex $item 6]
            set sub_item_name \"\"

            if { $item_name == \"frame\" } {
                set Frame_Infos TRUE
            }

            if { $Frame_Infos == \"TRUE\" } {

                # Program used by wizard
                if { ($sub_item_name_1 == \"epilogue\") || ($sub_item_name_1 == \"prologue\") } {
                    set program_event $sub_item_name_1
                    set program_name [lindex $item 6]
                    set program_parameters [join [lrange $item 10 end]]
                    set item_content \"<FONT SIZE=-1>$program_event </FONT><FONT SIZE=-1><A HREF=\\\"program.html#[Replace_Space $program_name]\\\">$program_name </FONT></A> <FONT SIZE=-1>$program_parameters</FONT></TD></TR>\"

                } elseif { ($sub_item_name_2 == \"load\") || ($sub_item_name_2 == \"validate\") } {
                    set program_event $sub_item_name_2
                    set program_name [lindex $item 8]
                    set program_parameters [join [lrange $item 12 end]]
                    set item_content \"<FONT SIZE=-1>$program_event </FONT><FONT SIZE=-1><A HREF=\\\"program.html#[Replace_Space $program_name]\\\">$program_name </FONT></A> <FONT SIZE=-1>$program_parameters</FONT></TD></TR>\"

                # Other frame infos
                } else {
                    set item_content [join [lrange $item 3 end]]
                }
                append Page_Content \"<TR>
                      <TD ALIGN=RIGHT BGCOLOR=#DCDCDC><B><FONT SIZE=-1>$item_name</B></FONT></TD>
                      <TD ALIGN=LEFT><FONT SIZE=-1>$item_content</FONT></TD>
                    </TR>\"
            }
            
            if { [ llength $lProp ] > 0 } {
                set lProp [ join $lProp \\n ]
#                if { $bDumpSpinner } { pfile_write [ file join $sDumpProperties ${Object}_${instance}.xls ] $lProp }
            }
            set lProp [list ]
        }
        if {$bDumpSpinner} { mql export program $instance into file [file join $aDirs(sDirSpinnerExport${Object}) ${instance}.exp] }
        append Page_Content \"\\n</TABLE><BR><BR>\"
    }

    append Page_Content \"
        </BODY>
        </HTML>
    \"

    if { $bDumpSchema } { pfile_write [ file join $Out_Directory ${Object}.html ] $Page_Content }
    return 0
}

################################################################################
# Generate_format
#   Generate HTML page for format
#
#   Parameters :
#   Return : none
#
proc Generate_format {} {
    upvar Format_Policies Format_Policies
    upvar aAdmin aAdmin
    
    global Out_Directory
    global sDumpProperties
    global bDumpSchema
    global bDumpSpinner
    
    set lProp [list ]

    # Get definition instances
    set Object \"format\"
    set Instances $aAdmin($Object)

    # Head of HTML page
    set Page_Content \"
        <HTML>
        <HEAD>
        <TITLE>$Object</TITLE>
        </HEAD>
        <BODY>
    \"

    # Body of HTML page
    foreach instance $Instances {
        if {[catch {set Content [lrange [split [mql print $Object $instance] \\n] 1 end]} sMsg] != 0} {continue}

        append Page_Content \"
            <A NAME=\\\"[Replace_Space $instance]\\\">
            <TABLE BORDER=0>
            <TR>
            <TD ALIGN=RIGHT BGCOLOR=#F5F5F5 WIDTH=150><FONT SIZE=+1>$Object</FONT></TD>
            <TD ALIGN=LEFT BGCOLOR=#F5F5F5><FONT SIZE=+1>$instance</FONT></TD>
            </TR>
            </A>\"

        foreach item $Content {
            set item [split $item]
            set item_name [lindex $item 2]

            # Case 'view' 'edit' 'print'
            if { ($item_name == \"view\") || ($item_name == \"edit\") || ($item_name == \"print\") } {
                set item_content [join [lrange $item 3 end]]
                set item_content \"<A HREF=\\\"program.html#[Replace_Space $item_content]\\\">$item_content</A> \"

            # Case 'property'
            # Extract property name and property value
            } elseif { $item_name == \"property\" } {
                set property [lrange $item 3 end]
                set value_index [lsearch -exact $property \"value\"]
                if { $value_index != -1 } {
                    set item_name [join [lrange $property 0 [expr $value_index -1]]]
                    set item_content [join [lrange $property [expr $value_index +1] end]]
                } else {
                    set item_content [join [lrange $item 3 end]]
                }
                lappend lProp \"$item_name \\t $item_content\"
                
            # Default case
            } else {
                set item_content [join [lrange $item 3 end]]
            }
                append Page_Content \"<TR>
                      <TD ALIGN=RIGHT BGCOLOR=#DCDCDC><B><FONT SIZE=-1>$item_name</B></FONT></TD>
                      <TD ALIGN=LEFT><FONT SIZE=-1>$item_content</FONT></TD>
                    </TR>\"
        }
        if { [ llength $lProp ] > 0 } {
            set lProp [ join $lProp \\n ]
#            if { $bDumpSpinner } { pfile_write [ file join $sDumpProperties ${Object}_${instance}.xls ] $lProp }
        }
        set lProp [list ]
        # Used by policies
        set item_content \"\"
        if { [lsearch -exact [array names Format_Policies] $instance] != -1 } {
            foreach policy $Format_Policies($instance) {
                append item_content \"<A HREF=policy.html#[Replace_Space $policy]\\\">$policy</A> \"
            }
        } else {
            set item_content \"\"
        }
        append Page_Content \"<TR>
                  <TD ALIGN=RIGHT BGCOLOR=#DCDCDC><B><FONT SIZE=-1>Used by policies</B></FONT></TD>
                  <TD ALIGN=LEFT><FONT SIZE=-1>$item_content</FONT></TD>
                </TR>\"

        append Page_Content \"\\n</TABLE><BR><BR>\"
    }

    append Page_Content \"
        </BODY>
        </HTML>
    \"

        if { $bDumpSchema } { pfile_write [ file join $Out_Directory ${Object}.html ] $Page_Content }
}

################################################################################
# Generate_association
#   Generate HTML page for association
#
#   Parameters : none
#   Return : none
#
proc Generate_association {} {

    upvar aAdmin aAdmin

    global Out_Directory
    global sDumpProperties
    global bDumpSchema
    global bDumpSpinner
    global bExtendedPolicy
    
    set lProp [list ]

    # Get definition instances
    set Object \"association\"
    set Instances $aAdmin($Object)

    # Head of HTML page
    set Page_Content \"
        <HTML>
        <HEAD>
        <TITLE>$Object</TITLE>
        </HEAD>
        <BODY>
    \"

    # Body of HTML page
    foreach instance $Instances {

        if {[catch {set Content [lrange [split [mql print $Object $instance] \\n] 1 end]} sMsg] != 0} {continue}

        append Page_Content \"
            <A NAME=\\\"[Replace_Space $instance]\\\">
            <TABLE BORDER=0>
            <TR>
            <TD ALIGN=RIGHT BGCOLOR=#F5F5F5 WIDTH=150><FONT SIZE=+1>$Object</FONT></TD>
            <TD ALIGN=LEFT BGCOLOR=#F5F5F5><FONT SIZE=+1>$instance</FONT></TD>
            </TR>
            </A>\"

        if { $bExtendedPolicy == \"1\" } {
            append Page_Content \"
                <TR>
                <TD ALIGN=RIGHT BGCOLOR=#DCDCDC><B><FONT SIZE=-1>Association Access Info</B></FONT></TD>
                <TD ALIGN=LEFT BGCOLOR=#F5F5F5><FONT SIZE=-1><A HREF=\\\"Policy/[Replace_Space $instance].html\\\">$instance</A></FONT></TD>
                </TR>\"
        }

        set Person_List FALSE
        foreach item $Content {
            set item [split $item]
            set item_name [lindex $item 2]

            if { $Person_List != \"TRUE\" } {

                # Case List of persons :
                # line content is just : 'List of persons who belongs to association'
                if { $item_name == \"List\" } {
                    set Person_List TRUE
                    set item_name \"List of persons\"
                    set item_content \"\"

                # Case 'property'
                # Extract property name and property value
                } elseif { $item_name == \"property\" } {
                    set property [lrange $item 3 end]
                    set value_index [lsearch -exact $property \"value\"]
                    if { $value_index != -1 } {
                        set item_name [join [lrange $property 0 [expr $value_index -1]]]
                        set item_content [join [lrange $property [expr $value_index +1] end]]
                    } else {
                        set item_content [join [lrange $item 3 end]]
                    }
                    lappend lProp \"$item_name \\t $item_content\"
                    
                # Default case
                } else {
                    set item_content [join [lrange $item 3 end]]
                }

            # Line content is just a name of person
            } else {
                set item_content $item_name
                set item_name \"\"
            }

            append Page_Content \"<TR>
                  <TD ALIGN=RIGHT BGCOLOR=#DCDCDC><B><FONT SIZE=-1>$item_name</B></FONT></TD>
                  <TD ALIGN=LEFT><FONT SIZE=-1>$item_content</FONT></TD>
                </TR>\"
        }
        if { [ llength $lProp ] > 0 } {
            set lProp [ join $lProp \\n ]
#            if { $bDumpSpinner } { pfile_write [ file join $sDumpProperties ${Object}_${instance}.xls ] $lProp }
        }
        set lProp [list ]
        append Page_Content \"\\n</TABLE><BR><BR>\"
    }

    append Page_Content \"
        </BODY>
        </HTML>
    \"

        if { $bDumpSchema } { pfile_write [ file join $Out_Directory ${Object}.html ] $Page_Content }
}

################################################################################
# Generate_process
#   Generate HTML page for process
#
#   Parameters :
#   Return : none
#
proc Generate_process {} {

    upvar aAdmin aAdmin
    upvar aDirs aDirs
    global Out_Directory
    global sDirSpinnerExport
    global sDumpProperties
    global bDumpSchema
    global bDumpSpinner
    
    set lProp [list ]

    # Get definition instances
    set Object \"process\"
    set Instances $aAdmin($Object)

    # Head of HTML page
    set Page_Content \"
        <HTML>
        <HEAD>
        <TITLE>$Object</TITLE>
        </HEAD>
        <BODY>
    \"

    # Body of HTML page
    foreach instance $Instances {
        if {[catch {set Content [lrange [split [mql print $Object $instance] \\n] 1 end]} sMsg] != 0} {continue}

        append Page_Content \"
            <A NAME=\\\"[Replace_Space $instance]\\\">
            <TABLE BORDER=0>
            <TR>
            <TD ALIGN=RIGHT BGCOLOR=#F5F5F5 WIDTH=150><FONT SIZE=+1>$Object</FONT></TD>
            <TD ALIGN=LEFT BGCOLOR=#F5F5F5><FONT SIZE=+1>$instance</FONT></TD>
            </TR>
            </A>\"

        foreach item $Content {
            set item [split [string trimleft $item]]
            set item_name [lindex $item 0]

            # Case 'property'
            # Extract property name and property value
            if { $item_name == \"property\" } {
                set property [lrange $item 3 end]
                set value_index [lsearch -exact $property \"value\"]
                if { $value_index != -1 } {
                    set item_name [join [lrange $property 0 [expr $value_index -1]]]
                    set item_content [join [lrange $property [expr $value_index +1] end]]
                } else {
                    set item_content [join [lrange $item 3 end]]
                }
                lappend lProp \"$item_name \\t $item_content\"
                
            # Default case
            } else {
                set item_content [join [lrange $item 1 end]]
            }

            append Page_Content \"<TR>
                  <TD ALIGN=RIGHT BGCOLOR=#DCDCDC><B><FONT SIZE=-1>$item_name</B></FONT></TD>
                  <TD ALIGN=LEFT><FONT SIZE=-1>$item_content</FONT></TD>
                </TR>\"
        }
        if { [ llength $lProp ] > 0 } {
            set lProp [ join $lProp \\n ]
#            if { $bDumpSpinner } { pfile_write [ file join $sDumpProperties ${Object}_${instance}.xls ] $lProp }
        }
        set lProp [list ]
        if {$bDumpSpinner} { mql export $Object $instance into file [file join $aDirs(sDirSpinnerExport${Object}) ${instance}.exp] }
        append Page_Content \"\\n</TABLE><BR><BR>\"
    }

    append Page_Content \"
        </BODY>
        </HTML>
    \"

    if { $bDumpSchema } { pfile_write [ file join $Out_Directory ${Object}.html ] $Page_Content }
    return 0
}

################################################################################
# Generate_form
#   Generate HTML page for forms
#
#   Parameters : none
#   Return : none
#
proc Generate_form {} {

    upvar aAdmin aAdmin
    upvar aDirs aDirs
    global Out_Directory
    global sDirSpinnerExport
    global sDumpProperties
    global bDumpSchema
    global bDumpSpinner

    set lProp [list ]

    # Get definition instances
    set Object \"form\"
    set Instances $aAdmin($Object)

    # Head of HTML page
    set Page_Content \"
        <HTML>
        <HEAD>
        <TITLE>$Object</TITLE>
        </HEAD>
        <BODY>
    \"

    # Body of HTML page
    foreach instance $Instances {
    
        if {[mql print $Object $instance select web dump] == \"TRUE\"} {
            continue
        }
    
        set Content [lrange [split [mql print $Object $instance] \\n] 1 end]

        append Page_Content \"
            <A NAME=\\\"[Replace_Space $instance]\\\">
            <TABLE BORDER=0>
            <TR>
            <TD ALIGN=RIGHT BGCOLOR=#F5F5F5 WIDTH=150><FONT SIZE=+1>$Object</FONT></TD>
            <TD ALIGN=LEFT BGCOLOR=#F5F5F5><FONT SIZE=+1>$instance</FONT></TD>
            </TR>
            </A>\"

        foreach item $Content {
            set item [split $item]
            set item_name [lindex $item 2]

            if { $item_name == \"type\" } {
                set item_content [string trimleft [join [lrange $item 3 end]]]
                set item_content \"<A HREF=\\\"type.html#[Replace_Space ${item_content}]\\\">${item_content}</A>\"

            # Case 'property'
            # Extract property name and property value
            } elseif { $item_name == \"property\" } {
                set property [lrange $item 3 end]
                set value_index [lsearch -exact $property \"value\"]
                if { $value_index != -1 } {
                    set item_name [join [lrange $property 0 [expr $value_index -1]]]
                    set item_content [join [lrange $property [expr $value_index +1] end]]
                } else {
                    set item_content [join [lrange $item 3 end]]
                }
                lappend lProp \"$item_name \\t $item_content\"
                
            # Default case
            } else {
                set item_content [join [lrange $item 3 end]]
            }
            append Page_Content \"<TR>
                  <TD ALIGN=RIGHT BGCOLOR=#DCDCDC><B><FONT SIZE=-1>$item_name</B></FONT></TD>
                  <TD ALIGN=LEFT><FONT SIZE=-1>$item_content</FONT></TD>
                </TR>\"
        }
        if { [ llength $lProp ] > 0 } {
            set lProp [ join $lProp \\n ]
#            if { $bDumpSpinner } { pfile_write [ file join $sDumpProperties ${Object}_${instance}.xls ] $lProp }
        }
        set lProp [list ]
        
        #export to file, change any spec char.
        set sInstanceFileName [pRemSpecChar $instance]
        if {$bDumpSpinner} { mql export $Object $instance into file [file join $aDirs(sDirSpinnerExport${Object}) ${sInstanceFileName}.exp] }
        append Page_Content \"\\n</TABLE><BR><BR>\"
    }

    append Page_Content \"
        </BODY>
        </HTML>
    \"

    if { $bDumpSchema } { pfile_write [ file join $Out_Directory ${Object}.html ] $Page_Content }
    return 0
}


################################################################################
# Generate_vault
#   Generate HTML page for vault
#   
#   Parameters :
#       category
#   Return : none
#
proc Generate_vault {  } {

    global sDumpSchemaDirSystem
    global Out_Directory
    global sDumpProperties
    global bDumpSchema
    global bDumpSpinner

    upvar aAdmin aAdmin
    
    set sDelimit \"\\t\"

    set lProp [list ]

    # Get definition instances
    set Object vault
    set Instances $aAdmin($Object)

    set lVaultLocal [list name \"Registry Name\" description indexspace tablespace]
    set lDumpLocal [ list [ join $lVaultLocal $sDelimit ] ]
    set lVaultRemote [list name \"Registry Name\" description server]
    set lDumpRemote [ list [ join $lVaultRemote $sDelimit ] ]
    set lVaultForeign [list name \"Registry Name\" description interface file]
    set lDumpForeign [ list [ join $lVaultForeign $sDelimit ] ]

    # Head of HTML page
    set Page_Content \"
        <HTML>
        <HEAD>
        <TITLE>$Object</TITLE>
        </HEAD>
        <BODY>
    \"

    # Body of HTML page   
    foreach instance $Instances {
        if {[catch {set Content [lrange [split [mql print $Object $instance] \\n] 1 end]} sMsg] != 0} {continue}
        
        append Page_Content \"
            <A NAME=\\\"[Replace_Space $instance]\\\">
            <TABLE BORDER=0>
            <TR>
            <TD ALIGN=RIGHT BGCOLOR=#F5F5F5 WIDTH=150><FONT SIZE=+1>$Object</FONT></TD>
            <TD ALIGN=LEFT BGCOLOR=#F5F5F5><FONT SIZE=+1>$instance</FONT></TD>
            </TR>
            </A>\"

        set aVault(name) $instance
        set sOriginalName [mql print $Object $instance select property\\[original name\\].value dump]
        array set aVault \"\\\"Registry Name\\\" \\\"$sOriginalName\\\"\"
        set aVault(server) \"\"
        set aVault(interface) \"\"
        set aVault(map) \"\"

        foreach item $Content {
            set item [ string trim $item ]
            # Case 'data tablespace'
            if { [string match \"*data tablespace*\" $item] == 1 } {
                set item [split $item]
                set item_name [join [lrange $item 0 1]]
                set item_content [join [lrange $item 2 end] ]
                set aVault(tablespace) $item_content
            # Case 'index tablespace'
            } elseif { [string match \"*index tablespace*\" $item] == 1 } {
                set item [split $item]
                set item_name [join [lrange $item 0 1]]
                set item_content [join [lrange $item 2 end] ]
                set aVault(indexspace) $item_content
           # Case 'total number of business objects'
            } elseif { [string match \"*total number of business objects*\" $item] == 1 } {
                set item [split $item]
                set item_name [join [lrange $item 0 4]]
                set item_content [join [lrange $item 5 end] ]
            } else {
            set item [split $item]
            set item_name [lindex $item 0]
            # Property case
            # Extract property name and property value
            if { $item_name == \"property\" } {
                set property [lrange $item 1 end]
                set value_index [lsearch -exact $property \"value\"]
                if { $value_index != -1 } {
                    set item_name [join [lrange $property 0 [expr $value_index -1]]]
                    set item_content [join [lrange $property [expr $value_index +1] end]]
                } else {
                    set item_content [join [lrange $item 1 end]]
                }
                lappend lProp \"$item_name \\t $item_content\"
            } elseif { $item_name == \"description\" } {
                set item_content [join [lrange $item 1 end]]
                set aVault(description) $item_content
            } elseif {$item_name == \"map\"} {
                set item_content [mql print vault $aVault(name) select map dump]
                set aVault(file) [file join . System $aVault(name).map]
                pfile_write [file join $sDumpSchemaDirSystem $aVault(name).map] $item_content
            } elseif {$item_name == \"interface\"} {
                set item_content [join [lrange $item 1 end]]
                set aVault(interface) $item_content
            } elseif {$item_name == \"server\"} {
                set item_content [join [lrange $item 1 end]]
                set aVault(server) $item_content
            # Default case
            } else {
                set item_content [join [lrange $item 1 end]]
            }
        }
            append Page_Content \"<TR>
                <TD ALIGN=RIGHT BGCOLOR=#DCDCDC><B><FONT SIZE=-1>$item_name</B></FONT></TD>
                <TD ALIGN=LEFT><FONT SIZE=-1>$item_content</FONT></TD>
                </TR>\"
        }
        if { [ llength $lProp ] > 0 } {
            set lProp [ join $lProp \\n ]
            if { $bDumpSpinner } {
#                if { $bDumpSpinner } { pfile_write [ file join $sDumpProperties ${Object}_${instance}.xls ] $lProp }
            }
        }
        set lProp [list ]
        append Page_Content \"\\n</TABLE><BR><BR>\"

        if {$aVault(server) != \"\"} {
            set sVaultType Remote
        } elseif {$aVault(map) != \"\" || $aVault(interface) != \"\"} {
            set sVaultType Foreign
        } else {
            set sVaultType Local
        }

        set sRefVault lVault${sVaultType}
        set lRefVault [set $sRefVault]
#        set lDump${sVaultType} [ list [ join $lRefVault $sDelimit ] ]
        set sInstanceData [ list ]
        foreach sDumpData $lRefVault {
            if { [ info exists aVault($sDumpData) ] == 1 } {
                lappend sInstanceData \\\"$aVault($sDumpData)\\\"
            }
            lappend sInstanceData $sDelimit
        }
        set sInstanceData [ join $sInstanceData \"\" ]
        lappend lDump${sVaultType} $sInstanceData
        unset aVault
    }
    append Page_Content \"
        </BODY>
        </HTML>
    \"

    if {[llength $lDumpLocal] > 1} {
        set lDumpLocal [ join $lDumpLocal \\n ]
#        if {$bDumpSpinner} {pfile_write [file join $sDumpSchemaDirSystem ${Object}_local.xls] $lDumpLocal}
    }
    
    if {[llength $lDumpRemote] > 1} {
        set lDumpRemote [ join $lDumpRemote \\n ]
#        if {$bDumpSpinner} {pfile_write [file join $sDumpSchemaDirSystem ${Object}_remote.xls] $lDumpRemote}
    }
    
    if {[llength $lDumpForeign] > 1} {
        set lDumpForeign [ join $lDumpForeign \\n ]
#        if {$bDumpSpinner} {pfile_write [file join $sDumpSchemaDirSystem ${Object}_foreign.xls] $lDumpForeign}
    }
    
    if {$bDumpSchema} {pfile_write [file join $Out_Directory ${Object}.html] $Page_Content }

    return 0
}


################################################################################
# Generate_store
#   Generate HTML page for store
#   
#   Parameters :
#       category
#   Return : none
#
proc Generate_store {  } {

    upvar Location_Store Location_Store
    upvar Store_Policy Store_Policy
    upvar aAdmin aAdmin

    global sDumpSchemaDirSystem
    global sDumpProperties
    global Out_Directory
    global bDumpSchema
    global bDumpSpinner
    
    global bStatus
    
    set lProp [list ]

    set sDelimit \"\\t\"
    set sSeperator \" | \"
    set sStoreType \"\"
    set bProcessLocations FALSE
    
    # Get definition instances
    set Object store
    set Instances $aAdmin($Object)

    set lStoreCaptured [ list name \"Registry Name\" description type filename permission \\
        protocol port host path user password location ]
    
    set lDumpCaptured [ list [ join $lStoreCaptured $sDelimit ] ]

    # Head of HTML page
    set Page_Content \"
        <HTML>
        <HEAD>
        <TITLE>$Object</TITLE>
        </HEAD>
        <BODY>
    \"

    # Body of HTML page   
    foreach instance $Instances {
        if {$bStatus} {puts -nonewline \".\"}
        if {[catch {set Content [lrange [split [mql print $Object $instance] \\n] 1 end]} sMsg] != 0} {continue}

        append Page_Content \"
            <A NAME=\\\"[Replace_Space $instance]\\\">
            <TABLE BORDER=0>
            <TR>
            <TD ALIGN=RIGHT BGCOLOR=#F5F5F5 WIDTH=150><FONT SIZE=+1>$Object</FONT></TD>
            <TD ALIGN=LEFT BGCOLOR=#F5F5F5><FONT SIZE=+1>$instance</FONT></TD>
            </TR>
            </A>\"

        if { [ info exists Store_Policy($instance) ] == 1 } {
            set sLinks \"\"
            set lStores $Store_Policy($instance)
            foreach sStore $lStores {
                append sLinks \" \" \"<A HREF=\\\"policy.html#[Replace_Space $sStore]\\\">$sStore</A>\"
            }
            append Page_Content \"<TR>
                <TD ALIGN=RIGHT BGCOLOR=#DCDCDC WIDTH=150><B><FONT SIZE=-1>Used in Policy</B></FONT></TD>
                <TD ALIGN=LEFT><FONT SIZE=-1>$sLinks</FONT></TD>
                </TR>\"
        }
        set aStore(name) $instance
        set sOriginalName [mql print $Object $instance select property\\[original name\\].value dump]
        array set aStore \"\\\"Registry Name\\\" \\\"$sOriginalName\\\"\"
        foreach item $Content {
            set item [ string trim $item ]
            if { $bProcessLocations == \"TRUE\" } {
                if { [ mql list location $item ] == \"\" } {
                    set bProcessLocations FALSE
                } else {
                    Add_Value_Element_To_Array Location_Store $item $instance
                    set aStore(locations) [ lappend aStore(locations) [Replace_Space $item] ]
                    append item_content \" \" \"<A HREF=\\\"location.html#[Replace_Space ${item}] \\
                        \\\">${item}</A>\"
                    continue
                }
            # Case 'data tablespace'
            } elseif { [string match \"*data tablespace*\" $item] == 1 } {
                set item [split $item]
                set item_name [join [lrange $item 0 1]]
                set item_content [join [lrange $item 2 end] ]

            # Case 'index tablespace'
            } elseif { [string match \"*index tablespace*\" $item] == 1 } {
                set item [split $item]
                set item_name [join [lrange $item 0 1]]
                set item_content [join [lrange $item 2 end] ]

           # Case 'total number of business objects'
            } elseif { [string match \"*total number of business objects*\" $item] == 1 } {
                set item [split $item]
                set item_name [join [lrange $item 0 4]]
                set item_content [join [lrange $item 5 end] ]

            } else {
            set item [split $item]
            set item_name [lindex $item 0]
            
            # Property case
            # Extract property name and property value
            if { $item_name == \"property\" } {
                set property [lrange $item 1 end]
                set value_index [lsearch -exact $property \"value\"]
                if { $value_index != -1 } {
                    set item_name [join [lrange $property 0 [expr $value_index -1]]]
                    set item_content [join [lrange $property [expr $value_index +1] end]]
                } else {
                    set item_content [join [lrange $item 1 end]]
                }
                lappend lProp \"$item_name \\t $item_content\"
            } elseif { $item_name == \"type\" } {
                set item_content [join [lrange $item 1 end]]
                set aStore(type) $item_content
                set sStoreType $item_content
            } elseif { $item_name == \"description\" } {
                set item_content [join [lrange $item 1 end]]
                set aStore(description) $item_content
            } elseif { $item_name == \"filename\" } {
                set item_content [join [lrange $item 1 end]]
                set aStore(filename) $item_content
            } elseif { $item_name == \"permission\" } {
                set item_content [join [lrange $item 1 end]]
                set aStore(permission) $item_content
            } elseif { $item_name == \"path\" } {
                set item_content [join [lrange $item 1 end]]
                set aStore(path) $item_content
            } elseif { $item_name == \"protocol\" } {
                set item_content [join [lrange $item 1 end]]
                set aStore(protocol) $item_content
            } elseif { $item_name == \"host\" } {
                set item_content [join [lrange $item 1 end]]
                set aStore(host) $item_content
            } elseif { $item_name == \"user\" } {
                set item_content [join [lrange $item 1 end]]
                set aStore(user) $item_content
            } elseif { $item_name == \"password\" } {
                set item_content [join [lrange $item 1 end]]
                set aStore(password) $item_content
            } elseif { $item_name == \"locations:\" } {
                set aStore(locations) [ list ]
                set bProcessLocations TRUE
                set item_content \"\"
                continue
            # Default case
            } else {
                set item_content [join [lrange $item 1 end]]
            }
           }
            append Page_Content \"<TR>
                  <TD ALIGN=RIGHT BGCOLOR=#DCDCDC><B><FONT SIZE=-1>$item_name</B></FONT></TD>
                  <TD ALIGN=LEFT><FONT SIZE=-1>$item_content</FONT></TD>
                </TR>\"
        }
        if { [ llength $lProp ] > 0 } {
            set lProp [ join $lProp \\n ]
#            if { $bDumpSpinner } { pfile_write [ file join $sDumpProperties ${Object}_${instance}.xls ] $lProp }
        }
        set lProp [list ]
        append Page_Content \"\\n</TABLE><BR><BR>\"

        set sInstanceData [ list ]
        #process each store type
        if { $sStoreType == \"captured\" } {
            foreach sDumpData $lStoreCaptured {
                if { [ info exists aStore($sDumpData) ] == 1 } {
                    if { $sDumpData == \"locations\" } {
                        set aStore(locations) [ join $aStore(locations) $sSeperator ]
                    }
                    lappend sInstanceData \\\"$aStore($sDumpData)\\\"
                }
                lappend sInstanceData $sDelimit
            }
            set sInstanceData [ join $sInstanceData \"\" ]
            lappend lDumpCaptured $sInstanceData
        } else {
            puts \"Store type $sStoreType, not yet supported\"
        }
        unset aStore
    }
    append Page_Content \"
        </BODY>
        </HTML>
    \"

    set lDumpCaptured [ join $lDumpCaptured \\n ]
#    if { $bDumpSpinner } { pfile_write [ file join $sDumpSchemaDirSystem ${Object}_${sStoreType}.xls ] $lDumpCaptured }
    if { $bDumpSchema } { pfile_write [ file join $Out_Directory ${Object}.html ] $Page_Content }
    return 0
}


################################################################################
# Generate_location
#   Generate HTML page for location
#   
#   Parameters :
#       category
#   Return : none
#
proc Generate_location {  } {

    upvar Location_Store Location_Store
    upvar Location_Site Location_Site
    upvar aAdmin aAdmin
    
    global sDumpSchemaDirSystem
    global sDumpProperties
    global Out_Directory
    global bDumpSchema
    global bDumpSpinner

    set lProp [list ]

    set sDelimit \"\\t\"

    # Get definition instances
    set Object location
    set Instances $aAdmin($Object)

    set lLocation [ list name {Registry Name} description permission \\
        protocol port host path user password ]
    
    set lDump [ list [ join $lLocation $sDelimit ] ]

    # Head of HTML page
    set Page_Content \"
        <HTML>
        <HEAD>
        <TITLE>$Object</TITLE>
        </HEAD>
        <BODY>
    \"

    # Body of HTML page   
    foreach instance $Instances {

        if {[catch {set Content [lrange [split [mql print $Object $instance] \\n] 1 end]} sMsg] != 0} {continue}

        append Page_Content \"
            <A NAME=\\\"[Replace_Space $instance]\\\"></A>
            <TABLE BORDER=0>
            <TR>
            <TD ALIGN=RIGHT BGCOLOR=#F5F5F5 WIDTH=150><FONT SIZE=+1>$Object</FONT></TD>
            <TD ALIGN=LEFT BGCOLOR=#F5F5F5><FONT SIZE=+1>$instance</FONT></TD>
            </TR>\"


        if { [ info exists Location_Store($instance) ] == 1 } {
            set sLinks \"\"
            set lStores $Location_Store($instance)
            foreach sStore $lStores {
                append sLinks \" \" \"<A HREF=\\\"store.html#[Replace_Space $sStore]\\\">$sStore</A>\"
            }

            append Page_Content \"<TR>
                <TD ALIGN=RIGHT BGCOLOR=#DCDCDC WIDTH=150><B><FONT SIZE=-1>Used in store</B></FONT></TD>
                <TD ALIGN=LEFT><FONT SIZE=-1>$sLinks</FONT></TD>
                </TR>\"
        }

        if { [ info exists Location_Site($instance) ] == 1 } {
            set sLinks \"\"
            set lStores $Location_Site($instance)
            foreach sStore $lStores {
                append sLinks \" \" \"<A HREF=\\\"site.html#[Replace_Space $sStore]\\\">$sStore</A>\"
            }

            append Page_Content \"<TR>
                <TD ALIGN=RIGHT BGCOLOR=#DCDCDC WIDTH=150><B><FONT SIZE=-1>Used in site</B></FONT></TD>
                <TD ALIGN=LEFT><FONT SIZE=-1>$sLinks</FONT></TD>
                </TR>\"
        }

        set aLocation(name) $instance
        set sOriginalName [mql print $Object $instance select property\\[original name\\].value dump]
        array set aLocation \"\\\"Registry Name\\\" \\\"$sOriginalName\\\"\"


        foreach item $Content {

            set item [ string trim $item ]

            # Case 'data tablespace'
            if { [string match \"*data tablespace*\" $item] == 1 } {
                set item [split $item]
                set item_name [join [lrange $item 0 1]]
                set item_content [join [lrange $item 2 end] ]

            # Case 'index tablespace'
            } elseif { [string match \"*index tablespace*\" $item] == 1 } {
                set item [split $item]
                set item_name [join [lrange $item 0 1]]
                set item_content [join [lrange $item 2 end] ]

           # Case 'total number of business objects'
            } elseif { [string match \"*total number of business objects*\" $item] == 1 } {
                set item [split $item]
                set item_name [join [lrange $item 0 4]]
                set item_content [join [lrange $item 5 end] ]

            } else {

            set item [split $item]
            set item_name [lindex $item 0]
            
            # Property case
            # Extract property name and property value
            if { $item_name == \"property\" } {
                set property [lrange $item 1 end]
                set value_index [lsearch -exact $property \"value\"]
                if { $value_index != -1 } {
                    set item_name [join [lrange $property 0 [expr $value_index -1]]]
                    set item_content [join [lrange $property [expr $value_index +1] end]]
                } else {
                    set item_content [join [lrange $item 1 end]]
                }
                lappend lProp \"$item_name \\t $item_content\"
            } elseif { $item_name == \"description\" } {
                set item_content [join [lrange $item 1 end]]
                set aLocation(description) $item_content
            } elseif { $item_name == \"permission\" } {
                set item_content [join [lrange $item 1 end]]
                set aLocation(permission) $item_content
            } elseif { $item_name == \"path\" } {
                set item_content [join [lrange $item 1 end]]
                set aLocation(path) $item_content
            } elseif { $item_name == \"protocol\" } {
                set item_content [join [lrange $item 1 end]]
                set aLocation(protocol) $item_content
            } elseif { $item_name == \"host\" } {
                set item_content [join [lrange $item 1 end]]
                set aLocation(host) $item_content
            } elseif { $item_name == \"user\" } {
                set item_content [join [lrange $item 1 end]]
                set aLocation(user) $item_content
            } elseif { $item_name == \"password\" } {
                set item_content [join [lrange $item 1 end]]
                set aLocation(password) $item_content
            # Default case
            } else {
                set item_content [join [lrange $item 1 end]]
            }
           }
            
            append Page_Content \"<TR>
                  <TD ALIGN=RIGHT BGCOLOR=#DCDCDC><B><FONT SIZE=-1>$item_name</B></FONT></TD>
                  <TD ALIGN=LEFT><FONT SIZE=-1>$item_content</FONT></TD>
                </TR>\"
        }
        if { [ llength $lProp ] > 0 } {
            set lProp [ join $lProp \\n ]
#            if { $bDumpSpinner } { pfile_write [ file join $sDumpProperties ${Object}_${instance}.xls ] $lProp }
        }
        set lProp [list ]
        append Page_Content \"\\n</TABLE><BR><BR>\"

        set sInstanceData [ list ]

        foreach sDumpData $lLocation {
            if { [ info exists aLocation($sDumpData) ] == 1 } {
                lappend sInstanceData \\\"$aLocation($sDumpData)\\\"
            }
            lappend sInstanceData $sDelimit
        }
        set sInstanceData [ join $sInstanceData \"\" ]
        lappend lDump $sInstanceData

        unset aLocation
    }

    append Page_Content \"
        </BODY>
        </HTML>
    \"

    set lDump [ join $lDump \\n ]
#    if { $bDumpSpinner } { pfile_write [ file join $sDumpSchemaDirSystem ${Object}.xls ] $lDump }
    if { $bDumpSchema } { pfile_write [ file join $Out_Directory ${Object}.html ] $Page_Content }
    return 0
}


################################################################################
# Generate_site
#   Generate HTML page for site
#   
#   Parameters :
#       category
#   Return : none
#
proc Generate_site {  } {
    global sDumpSchemaDirSystem
    global sDumpProperties
    global Out_Directory
    global bDumpSchema
    global bDumpSpinner
    set lProp [list ]
    upvar Location_Site Location_Site
    upvar aAdmin aAdmin
    set sDelimit \"\\t\"
    set sSeperator \" | \"

    # Get definition instances
    set Object site
    set Instances $aAdmin($Object)
    set lSite [ list name {Registry Name} description {member location} ]
    set lDump [ list [ join $lSite $sDelimit ] ]

    # Head of HTML page
    set Page_Content \"
        <HTML>
        <HEAD>
        <TITLE>$Object</TITLE>
        </HEAD>
        <BODY>
    \"
    # Body of HTML page   
    foreach instance $Instances {
        if {[catch {set Content [lrange [split [mql print $Object $instance] \\n] 1 end]} sMsg] != 0} {continue}
        append Page_Content \"
            <A NAME=\\\"[Replace_Space $instance]\\\">
            <TABLE BORDER=0>
            <TR>
            <TD ALIGN=RIGHT BGCOLOR=#F5F5F5 WIDTH=150><FONT SIZE=+1>$Object</FONT></TD>
            <TD ALIGN=LEFT BGCOLOR=#F5F5F5><FONT SIZE=+1>$instance</FONT></TD>
            </TR>
            </A>\"
        set aData(name) $instance
        set sOriginalName [mql print $Object $instance select property\\[original name\\].value dump]
        array set aData \"\\\"Registry Name\\\" \\\"$sOriginalName\\\"\"
        foreach item $Content {
            set item [ string trim $item ]
            # Case 'member location'
            if { [string match \"*member location*\" $item] == 1 } {
                set item [split $item]
                set item_name [join [lrange $item 0 1]]
                set item_content [join [lrange $item 2 end] ]
                if { [ info exists aData(location) ] == 0 } {
                    set aData(location) $item_content
                } else {
                    set aData(location) [ append aData(location) $sSeperator $item_content ]
                }
                Add_Value_Element_To_Array Location_Site $item_content $instance
                set item_content \"<A HREF=\\\"location.html#[Replace_Space ${item_content}] \\
                    \\\">${item_content}</A>\"
            } else {
                set item [split $item]
                set item_name [lindex $item 0]
                # Property case
                # Extract property name and property value
                if { $item_name == \"property\" } {
                    set property [lrange $item 1 end]
                    set value_index [lsearch -exact $property \"value\"]
                    if { $value_index != -1 } {
                        set item_name [join [lrange $property 0 [expr $value_index -1]]]
                        set item_content [join [lrange $property [expr $value_index +1] end]]
                    } else {
                        set item_content [join [lrange $item 1 end]]
                    }
                    lappend lProp \"$item_name \\t $item_content\"
                } elseif { $item_name == \"description\" } {
                    set item_content [join [lrange $item 1 end]]
                    set aData(description) $item_content
                # Default case
                } else {
                    set item_content [join [lrange $item 1 end]]
                }
            }
            append Page_Content \"<TR>
                <TD ALIGN=RIGHT BGCOLOR=#DCDCDC><B><FONT SIZE=-1>$item_name</B></FONT></TD>
                <TD ALIGN=LEFT><FONT SIZE=-1>$item_content</FONT></TD>
                </TR>\"
        }
        if { [ llength $lProp ] > 0 } {
            set lProp [ join $lProp \\n ]
        }
        set lProp [list ]
        append Page_Content \"\\n</TABLE><BR><BR>\"

        set sInstanceData [ list ]
        foreach sDumpData $lSite {
            if { [ info exists aData($sDumpData) ] == 1 } {
                lappend sInstanceData \\\"$aData($sDumpData)\\\"
            }
            lappend sInstanceData $sDelimit
        }
        set sInstanceData [ join $sInstanceData \"\" ]
        lappend lDump $sInstanceData

        unset aData
    }

    append Page_Content \"
        </BODY>
        </HTML>
    \"

    set lDump [ join $lDump \\n ]
#    if { $bDumpSpinner } { pfile_write [ file join $sDumpSchemaDirSystem ${Object}.xls ] $lDump }
    if { $bDumpSchema } { pfile_write [ file join $Out_Directory ${Object}.html ] $Page_Content }
    return 0
}



################################################################################
# Generate_server
#   Generate HTML page for server
#   
#   Parameters :
#       category
#   Return : none
#
proc Generate_server {  } {

    global sDumpSchemaDirSystem
    global sDumpProperties
    global Out_Directory
    global bDumpSchema
    global bDumpSpinner
    upvar aAdmin aAdmin
    set lProp [list ]
    set sDelimit \"\\t\"

    # Get definition instances
    set Object server
    set Instances $aAdmin($Object)
    set lServer [ list name {Registry Name} description user pass connect timezone ]
    set lDump [ list [ join $lServer $sDelimit ] ]
    # Head of HTML page
    set Page_Content \"
        <HTML>
        <HEAD>
        <TITLE>$Object</TITLE>
        </HEAD>
        <BODY>
    \"
    # Body of HTML page   
    foreach instance $Instances {
        if {[catch {set Content [lrange [split [mql print $Object $instance] \\n] 1 end]} sMsg] != 0} {continue}
        append Page_Content \"
            <A NAME=\\\"[Replace_Space $instance]\\\">
            <TABLE BORDER=0>
            <TR>
            <TD ALIGN=RIGHT BGCOLOR=#F5F5F5 WIDTH=150><FONT SIZE=+1>$Object</FONT></TD>
            <TD ALIGN=LEFT BGCOLOR=#F5F5F5><FONT SIZE=+1>$instance</FONT></TD>
            </TR>
            </A>\"
        set aData(name) $instance
        set sOriginalName [mql print $Object $instance select property\\[original name\\].value dump]
        array set aData \"\\\"Registry Name\\\" \\\"$sOriginalName\\\"\"

        foreach item $Content {
            set item [ string trim $item ]
            # Case 'member location'
            if { [string match \"*member location*\" $item] == 1 } {
                set item [split $item]
                set item_name [join [lrange $item 0 1]]
                set item_content [join [lrange $item 2 end] ]
                set item_content \"<A HREF=\\\"location.html#[Replace_Space ${item_content}] \\
                    \\\">${item_content}</A>\"
            } else {
                set item [split $item]
                set item_name [lindex $item 0]
                # Property case
                # Extract property name and property value
                if { $item_name == \"property\" } {
                    set property [lrange $item 1 end]
                    set value_index [lsearch -exact $property \"value\"]
                    if { $value_index != -1 } {
                        set item_name [join [lrange $property 0 [expr $value_index -1]]]
                        set item_content [join [lrange $property [expr $value_index +1] end]]
                    } else {
                        set item_content [join [lrange $item 1 end]]
                    }
                    lappend lProp \"$item_name \\t $item_content\"
                } elseif { $item_name == \"description\" } {
                    set item_content [join [lrange $item 1 end]]
                    set aData(description) $item_content
                } elseif { $item_name == \"user\" } {
                    set item_content [join [lrange $item 1 end]]
                    set aData(user) $item_content
                } elseif { $item_name == \"pass\" } {
                    set item_content [join [lrange $item 1 end]]
                    set aData(pass) $item_content
                } elseif { $item_name == \"connect\" } {
                    set item_content [join [lrange $item 1 end]]
                    set aData(connect) $item_content
                } elseif { $item_name == \"timezone\" } {
                    set item_content [join [lrange $item 1 end]]
                    set aData(timezone) $item_content
                # Default case
                } else {
                    set item_content [join [lrange $item 1 end]]
                }
            }
            append Page_Content \"<TR>
                <TD ALIGN=RIGHT BGCOLOR=#DCDCDC><B><FONT SIZE=-1>$item_name</B></FONT></TD>
                <TD ALIGN=LEFT><FONT SIZE=-1>$item_content</FONT></TD>
                </TR>\"
        }
        if { [ llength $lProp ] > 0 } {
            set lProp [ join $lProp \\n ]
        }
        set lProp [list ]
        append Page_Content \"\\n</TABLE><BR><BR>\"

        set sInstanceData [ list ]

        foreach sDumpData $lServer {
            if { [ info exists aData($sDumpData) ] == 1 } {
                lappend sInstanceData \\\"$aData($sDumpData)\\\"
            }
            lappend sInstanceData $sDelimit
        }
        set sInstanceData [ join $sInstanceData \"\" ]
        lappend lDump $sInstanceData

        unset aData
        append Page_Content \"
            </BODY>
            </HTML>
        \"
    }
    set lDump [ join $lDump \\n ]
#    if {$bDumpSpinner} {pfile_write [file join $sDumpSchemaDirSystem ${Object}.xls] $lDump}
    if {$bDumpSchema} {pfile_write [file join $Out_Directory ${Object}.html] $Page_Content}
    return 0
}


################################################################################
# Generate_Table
#   Generate HTML page for simple category of business definitions
#
#   Parameters :
#       category
#   Return : none
#
proc Generate_table { } {
    global Out_Directory
    global sDumpProperties
    global bDumpSchema
    global bDumpSpinner
    upvar aAdmin aAdmin

    set lProp [list ]

    # Get definition instances
    set Object table
    set Instances $aAdmin($Object)

    # Head of HTML page
    set Page_Content \"
        <HTML>
        <HEAD>
        <TITLE>$Object</TITLE>
        </HEAD>
        <BODY>
    \"

    # Body of HTML page
    foreach instance $Instances {

        if {[catch {set Content [lrange [split [mql print $Object $instance system] \\n] 1 end]} sMsg] != 0} {continue}

        append Page_Content \"
            <A NAME=\\\"[Replace_Space $instance]\\\">
            <TABLE BORDER=0>
            <TR>
            <TD ALIGN=RIGHT BGCOLOR=#F5F5F5 WIDTH=150><FONT SIZE=+1>$Object</FONT></TD>
            <TD ALIGN=LEFT BGCOLOR=#F5F5F5><FONT SIZE=+1>$instance</FONT></TD>
            </TR>
            </A>\"

        foreach item $Content {
            set item [split [string trim $item]]
            set item_name [lindex $item 0]

            # Property case
            # Extract property name and property value
            if { $item_name == \"property\" } {
                set property [lrange $item 1 end]
                set value_index [lsearch -exact $property \"value\"]
                if { $value_index != -1 } {
                    set item_name [join [lrange $property 0 [expr $value_index -1]]]
                    set item_content [join [lrange $property [expr $value_index +1] end]]
                } else {
                    set item_content [join [lrange $item 1 end]]
                }
                lappend lProp \"$item_name \\t $item_content\"

            # Default case
            } else {
                set item_content [join [lrange $item 1 end]]
            }

            regsub -all -- \"<\" $item_content {\\&#60;} item_content
            regsub -all -- \">\" $item_content {\\&#62;} item_content
            append Page_Content \"<TR>
                  <TD ALIGN=RIGHT BGCOLOR=#DCDCDC><B><FONT SIZE=-1>$item_name</B></FONT></TD>
                  <TD ALIGN=LEFT><FONT SIZE=-1>$item_content</FONT></TD>
                </TR>\"
        }
        if { [ llength $lProp ] > 0 } {
            set lProp [ join $lProp \\n ]
#            if { $bDumpSpinner } { pfile_write [ file join $sDumpProperties ${Object}_${instance}.xls ] $lProp }
        }
        set lProp [list ]
        append Page_Content \"\\n</TABLE><BR><BR>\"
    }

    append Page_Content \"
        </BODY>
        </HTML>
    \"

        if { $bDumpSchema } { pfile_write [ file join $Out_Directory ${Object}.html ] $Page_Content }
}


################################################################################
# Generate_command
#   Generate HTML
#   Generate MQL
#   Parameters :
#       category
#   Return : none
#
proc Generate_command {  } {

    global sDumpSchemaDirSystem
    global Out_Directory
    global sDumpProperties
    global bDumpSchema
    global bDumpSpinner
    global bDumpMQL

    upvar aAdmin aAdmin
    
    set sDelimit \"\\t\"

    set lProp [list ]

    # Get definition instances
    set Object command
    set Instances $aAdmin($Object)

    set lLabels [ list description label href alt setting user ]
    
    set lDump [ list [ join $lLabels $sDelimit ] ]
    set lMql [ list ]

    # Head of HTML page
    set Page_Content \"
        <HTML>
        <HEAD>
        <TITLE>$Object</TITLE>
        </HEAD>
        <BODY>
    \"

    # Body of HTML page   
    foreach instance $Instances {
        if {[catch {set Content [lrange [split [mql print $Object $instance] \\n] 1 end]} sMsg] != 0} {continue}

        append Page_Content \"
            <A NAME=\\\"[Replace_Space $instance]\\\">
            <TABLE BORDER=0>
            <TR>
            <TD ALIGN=RIGHT BGCOLOR=#F5F5F5 WIDTH=150><FONT SIZE=+1>$Object</FONT></TD>
            <TD ALIGN=LEFT BGCOLOR=#F5F5F5><FONT SIZE=+1>$instance</FONT></TD>
            </TR>
            </A>\"

        set aData(name) $instance

        foreach item $Content {

            set item [ string trim $item ]

            # Case 'data tablespace'
            if { [string match \"*data tablespace*\" $item] == 1 } {
                set item [split $item]
                set item_name [join [lrange $item 0 1]]
                set item_content [join [lrange $item 2 end] ]
                set aData(tablespace) $item_content

            } else {

            set item [split $item]
            set item_name [lindex $item 0]
            
            # Property case
            # Extract property name and property value
            if { $item_name == \"property\" } {
                set property [lrange $item 1 end]
                set value_index [lsearch -exact $property \"value\"]
                if { $value_index != -1 } {
                    set item_name [join [lrange $property 0 [expr $value_index -1]]]
                    set item_content [join [lrange $property [expr $value_index +1] end]]
                } else {
                    set item_content [join [lrange $item 1 end]]
                }
                lappend lProp \"$item_name \\t $item_content\"
                
            } elseif { $item_name == \"description\" } {
                set item_content [join [lrange $item 1 end]]
                set aData(description) $item_content
            } elseif { $item_name == \"label\" } {
                set item_content [join [lrange $item 1 end]]
                set aData(label) $item_content
            } elseif { $item_name == \"href\" } {
                set item_content [join [lrange $item 1 end]]
                set aData(href) $item_content
            } elseif { $item_name == \"alt\" } {
                set item_content [join [lrange $item 1 end]]
                set aData(alt) $item_content
            } elseif { $item_name == \"setting\" } {
                set nValue [ lsearch $item value ]
                set sFirstValue [ lrange $item 1 [expr $nValue - 1] ]
                set sSeconValue [ lrange $item [expr $nValue + 1] end ]
                if {[info exists aData(setting)] == 0} {
                    set aData(setting) [list \"$sFirstValue $sSeconValue\"]
                } else {
                    set aDate(setting) [lappend aData(setting) [list $sFirstValue $sSeconValue] ]
                }
            } elseif { $item_name == \"user\" } {
                set item_content [join [lrange $item 1 end]]
                if {[info exists aData(user)] == 0} {
                    set aData(user) [list $item_content]
                } else {
                    set aData(user) [lappend aData(user) $item_content]
                }
            # Default case
            } else {
                set item_content [join [lrange $item 1 end]]
            }
           }
            
            append Page_Content \"<TR>
                  <TD ALIGN=RIGHT BGCOLOR=#DCDCDC><B><FONT SIZE=-1>$item_name</B></FONT></TD>
                  <TD ALIGN=LEFT><FONT SIZE=-1>$item_content</FONT></TD>
                </TR>\"
        }
        if { [ llength $lProp ] > 0 } {
            set lProp [ join $lProp \\n ]
            if { $bDumpSpinner } {
#                if { $bDumpSpinner } { pfile_write [ file join $sDumpProperties ${Object}_${instance}.xls ] $lProp }
            }
        }
        set lProp [list ]
        append Page_Content \"\\n</TABLE><BR><BR>\"

        set sCode \"\\n\\n\"
        append sCode \"puts stdout \\\"Add $Object ...\\\"\"
        append sCode \"\\n\\nset bRegister 1\\n\\n\"
        append sCode \"set sMql \\\"mql add $Object \\\\\\\"$instance\\\\\\\"\\\"\\n\"
        append sCode \"pProcessMqlCmd \\$bRegister \\$sMql\\n\\n\"
        append sCode \"puts stdout \\\"Mod $Object ...\\\"\\n\\n\"
        append sCode \"set bRegister 0\\n\\n\"
        append sCode \"set sMql \\\"mql mod $Object \\\\\\\"$instance\\\\\\\" \\\\\\n\"
        foreach sDumpData $lLabels {
            if { [ info exists aData($sDumpData) ] == 1 } {
                switch $sDumpData {
                    user {
                        foreach sUser $aData($sDumpData) {
                            append sCode \"    add user \" \\\\\\\"$sUser\\\\\\\" \" \\\\\\n\"
                        }
                    }
                    setting {
                        foreach sSet $aData($sDumpData) {
                            append sCode \"    add setting \" \\\\\\\"[lindex $sSet 0]\\\\\\\" \" \" \"\\\\\\\"[lindex $sSet 1]\\\\\\\" \\\\\\n\"
                        }
                    }
                    default {append sCode \"    \" $sDumpData \" \" \\\\\\\"$aData($sDumpData)\\\\\\\" \" \\\\\\n\"}
                }
            }
        }
        append sCode \"  \\\"\\n\\n\"
        append sCode \"pProcessMqlCmd \\$bRegister \\$sMql\\n\\n\"
        lappend lMql $sCode
        unset aData
    }

    append Page_Content \"
        </BODY>
        </HTML>
    \"

    set lDump [ join $lDump \\n ]
    set lMql [join $lMql \\n]
    if {$bDumpMQL} {pfile_write [file join $sDumpSchemaDirSystem ${Object}.tcl] $lMql}
#    if { $bDumpSpinner } { pfile_write [ file join $sDumpSchemaDirSystem ${Object}.xls ] $lDump }
    if { $bDumpSchema } { pfile_write [ file join $Out_Directory ${Object}.html ] $Page_Content }
    return 0
}



################################################################################
# Generate_channel
#   Generate HTML
#   Generate MQL
#   Parameters :
#       category
#   Return : none
#
proc Generate_channel {  } {

    global sDumpSchemaDirSystem
    global Out_Directory
    global sDumpProperties
    global bDumpSchema
    global bDumpSpinner
    global bDumpMQL

    upvar aAdmin aAdmin
    
    set sDelimit \"\\t\"

    set lProp [list ]

    # Get definition instances
    set Object channel
    set Instances $aAdmin($Object)

    set lLabels [ list description label href alt setting command ]
    
    set lDump [ list [ join $lLabels $sDelimit ] ]
    set lMql [ list ]

    # Head of HTML page
    set Page_Content \"
        <HTML>
        <HEAD>
        <TITLE>$Object</TITLE>
        </HEAD>
        <BODY>
    \"

    # Body of HTML page   
    foreach instance $Instances {
        if {[catch {set Content [lrange [split [mql print $Object $instance] \\n] 1 end]} sMsg] != 0} {continue}

        append Page_Content \"
            <A NAME=\\\"[Replace_Space $instance]\\\">
            <TABLE BORDER=0>
            <TR>
            <TD ALIGN=RIGHT BGCOLOR=#F5F5F5 WIDTH=150><FONT SIZE=+1>$Object</FONT></TD>
            <TD ALIGN=LEFT BGCOLOR=#F5F5F5><FONT SIZE=+1>$instance</FONT></TD>
            </TR>
            </A>\"

        set aData(name) $instance

        foreach item $Content {

            set item [ string trim $item ]

            # Case 'data tablespace'
            if { [string match \"*data tablespace*\" $item] == 1 } {
                set item [split $item]
                set item_name [join [lrange $item 0 1]]
                set item_content [join [lrange $item 2 end] ]
                set aData(tablespace) $item_content

            } else {

            set item [split $item]
            set item_name [lindex $item 0]
            
            # Property case
            # Extract property name and property value
            if { $item_name == \"property\" } {
                set property [lrange $item 1 end]
                set value_index [lsearch -exact $property \"value\"]
                if { $value_index != -1 } {
                    set item_name [join [lrange $property 0 [expr $value_index -1]]]
                    set item_content [join [lrange $property [expr $value_index +1] end]]
                } else {
                    set item_content [join [lrange $item 1 end]]
                }
                lappend lProp \"$item_name \\t $item_content\"
                
            } elseif { $item_name == \"description\" } {
                set item_content [join [lrange $item 1 end]]
                set aData(description) $item_content
            } elseif { $item_name == \"label\" } {
                set item_content [join [lrange $item 1 end]]
                set aData(label) $item_content
            } elseif { $item_name == \"href\" } {
                set item_content [join [lrange $item 1 end]]
                set aData(href) $item_content
            } elseif { $item_name == \"alt\" } {
                set item_content [join [lrange $item 1 end]]
                set aData(alt) $item_content
            } elseif { $item_name == \"setting\" } {
                set nValue [ lsearch $item value ]
                set sFirstValue [ lrange $item 1 [expr $nValue - 1] ]
                set sSeconValue [ lrange $item [expr $nValue + 1] end ]
                if {[info exists aData(setting)] == 0} {
                    set aData(setting) [list \"$sFirstValue $sSeconValue\"]
                } else {
                    set aDate(setting) [lappend aData(setting) [list $sFirstValue $sSeconValue] ]
                }
            } elseif { $item_name == \"command\" } {
                set item_content [join [lrange $item 1 end]]
                if {[info exists aData(command)] == 0} {
                    set aData(command) [list $item_content]
                } else {
                    set aData(command) [lappend aData(command) $item_content]
                }
            # Default case
            } else {
                set item_content [join [lrange $item 1 end]]
            }
           }
            
            append Page_Content \"<TR>
                  <TD ALIGN=RIGHT BGCOLOR=#DCDCDC><B><FONT SIZE=-1>$item_name</B></FONT></TD>
                  <TD ALIGN=LEFT><FONT SIZE=-1>$item_content</FONT></TD>
                </TR>\"
        }
        if { [ llength $lProp ] > 0 } {
            set lProp [ join $lProp \\n ]
            if { $bDumpSpinner } {
#                if { $bDumpSpinner } { pfile_write [ file join $sDumpProperties ${Object}_${instance}.xls ] $lProp }
            }
        }
        set lProp [list ]
        append Page_Content \"\\n</TABLE><BR><BR>\"

        set sCode \"\\n\\n\"
        append sCode \"puts stdout \\\"Add $Object ...\\\"\"
        append sCode \"\\n\\nset bRegister 1\\n\\n\"
        append sCode \"set sMql \\\"mql add $Object \\\\\\\"$instance\\\\\\\"\\\"\\n\"
        append sCode \"pProcessMqlCmd \\$bRegister \\$sMql\\n\\n\"
        append sCode \"puts stdout \\\"Mod $Object ...\\\"\\n\\n\"
        append sCode \"set bRegister 0\\n\\n\"
        append sCode \"set sMql \\\"mql mod $Object \\\\\\\"$instance\\\\\\\" \\\\\\n\"
        foreach sDumpData $lLabels {
            if { [ info exists aData($sDumpData) ] == 1 } {
                switch $sDumpData {
                    command {
                        foreach sCommand $aData($sDumpData) {
                            append sCode \"    add command \" \\\\\\\"$sCommand\\\\\\\" \" \\\\\\n\"
                        }
                    }
                    setting {
                        foreach sSet $aData($sDumpData) {
                            append sCode \"    add setting \" \\\\\\\"[lindex $sSet 0]\\\\\\\" \" \" \"\\\\\\\"[lindex $sSet 1]\\\\\\\" \\\\\\n\"
                        }
                    }
                    default {append sCode \"    \" $sDumpData \" \" \\\\\\\"$aData($sDumpData)\\\\\\\" \" \\\\\\n\"}
                }
            }
        }
        append sCode \"  \\\"\\n\\n\"
        append sCode \"pProcessMqlCmd \\$bRegister \\$sMql\\n\\n\"
        lappend lMql $sCode
        unset aData
    }

    append Page_Content \"
        </BODY>
        </HTML>
    \"

    set lDump [ join $lDump \\n ]
    set lMql [join $lMql \\n]
    if {$bDumpMQL} {pfile_write [file join $sDumpSchemaDirSystem ${Object}.tcl] $lMql}
#    if { $bDumpSpinner } { pfile_write [ file join $sDumpSchemaDirSystem ${Object}.xls ] $lDump }
    if { $bDumpSchema } { pfile_write [ file join $Out_Directory ${Object}.html ] $Page_Content }
    return 0
}



################################################################################
# Generate_portal
#   Generate HTML
#   Generate MQL
#   Parameters :
#       category
#   Return : none
#
proc Generate_portal {  } {

    global sDumpSchemaDirSystem
    global Out_Directory
    global sDumpProperties
    global bDumpSchema
    global bDumpSpinner
    global bDumpMQL

    upvar aAdmin aAdmin
    
    set sDelimit \"\\t\"

    set lProp [list ]

    # Get definition instances
    set Object portal
    set Instances $aAdmin($Object)

    set lLabels [ list description label href alt setting channel ]
    
    set lDump [ list [ join $lLabels $sDelimit ] ]
    set lMql [ list ]

    # Head of HTML page
    set Page_Content \"
        <HTML>
        <HEAD>
        <TITLE>$Object</TITLE>
        </HEAD>
        <BODY>
    \"

    # Body of HTML page   
    foreach instance $Instances {
        if {[catch {set Content [lrange [split [mql print $Object $instance] \\n] 1 end]} sMsg] != 0} {continue}

        append Page_Content \"
            <A NAME=\\\"[Replace_Space $instance]\\\">
            <TABLE BORDER=0>
            <TR>
            <TD ALIGN=RIGHT BGCOLOR=#F5F5F5 WIDTH=150><FONT SIZE=+1>$Object</FONT></TD>
            <TD ALIGN=LEFT BGCOLOR=#F5F5F5><FONT SIZE=+1>$instance</FONT></TD>
            </TR>
            </A>\"

        set aData(name) $instance

        foreach item $Content {

            set item [ string trim $item ]

            # Case 'data tablespace'
            if { [string match \"*data tablespace*\" $item] == 1 } {
                set item [split $item]
                set item_name [join [lrange $item 0 1]]
                set item_content [join [lrange $item 2 end] ]
                set aData(tablespace) $item_content

            } else {

            set item [split $item]
            set item_name [lindex $item 0]
            
            # Property case
            # Extract property name and property value
            if { $item_name == \"property\" } {
                set property [lrange $item 1 end]
                set value_index [lsearch -exact $property \"value\"]
                if { $value_index != -1 } {
                    set item_name [join [lrange $property 0 [expr $value_index -1]]]
                    set item_content [join [lrange $property [expr $value_index +1] end]]
                } else {
                    set item_content [join [lrange $item 1 end]]
                }
                lappend lProp \"$item_name \\t $item_content\"
                
            } elseif { $item_name == \"description\" } {
                set item_content [join [lrange $item 1 end]]
                set aData(description) $item_content
            } elseif { $item_name == \"label\" } {
                set item_content [join [lrange $item 1 end]]
                set aData(label) $item_content
            } elseif { $item_name == \"href\" } {
                set item_content [join [lrange $item 1 end]]
                set aData(href) $item_content
            } elseif { $item_name == \"alt\" } {
                set item_content [join [lrange $item 1 end]]
                set aData(alt) $item_content
            } elseif { $item_name == \"setting\" } {
                set nValue [ lsearch $item value ]
                set sFirstValue [ lrange $item 1 [expr $nValue - 1] ]
                set sSeconValue [ lrange $item [expr $nValue + 1] end ]
                if {[info exists aData(setting)] == 0} {
                    set aData(setting) [list \"$sFirstValue $sSeconValue\"]
                } else {
                    set aDate(setting) [lappend aData(setting) [list $sFirstValue $sSeconValue] ]
                }
            } elseif { $item_name == \"channel\" } {
                set item_content [join [lrange $item 1 end]]
                if {[info exists aData(channel)] == 0} {
                    set aData(channel) [list $item_content]
                } else {
                    set aData(channel) [lappend aData(channel) $item_content]
                }
            # Default case
            } else {
                set item_content [join [lrange $item 1 end]]
            }
           }
            
            append Page_Content \"<TR>
                  <TD ALIGN=RIGHT BGCOLOR=#DCDCDC><B><FONT SIZE=-1>$item_name</B></FONT></TD>
                  <TD ALIGN=LEFT><FONT SIZE=-1>$item_content</FONT></TD>
                </TR>\"
        }
        if { [ llength $lProp ] > 0 } {
            set lProp [ join $lProp \\n ]
            if { $bDumpSpinner } {
#                if { $bDumpSpinner } { pfile_write [ file join $sDumpProperties ${Object}_${instance}.xls ] $lProp }
            }
        }
        set lProp [list ]
        append Page_Content \"\\n</TABLE><BR><BR>\"

        set sCode \"\\n\\n\"
        append sCode \"puts stdout \\\"Add $Object ...\\\"\"
        append sCode \"\\n\\nset bRegister 1\\n\\n\"
        append sCode \"set sMql \\\"mql add $Object \\\\\\\"$instance\\\\\\\"\\\"\\n\"
        append sCode \"pProcessMqlCmd \\$bRegister \\$sMql\\n\\n\"
        append sCode \"puts stdout \\\"Mod $Object ...\\\"\\n\\n\"
        append sCode \"set bRegister 0\\n\\n\"
        append sCode \"set sMql \\\"mql mod $Object \\\\\\\"$instance\\\\\\\" \\\\\\n\"
        foreach sDumpData $lLabels {
            if { [ info exists aData($sDumpData) ] == 1 } {
                switch $sDumpData {
                    user {
                        foreach sUser $aData($sDumpData) {
                            append sCode \"    add channel \" \\\\\\\"$sChannel\\\\\\\" \" \\\\\\n\"
                        }
                    }
                    setting {
                        foreach sSet $aData($sDumpData) {
                            append sCode \"    add setting \" \\\\\\\"[lindex $sSet 0]\\\\\\\" \" \" \"\\\\\\\"[lindex $sSet 1]\\\\\\\" \\\\\\n\"
                        }
                    }
                    default {append sCode \"    \" $sDumpData \" \" \\\\\\\"$aData($sDumpData)\\\\\\\" \" \\\\\\n\"}
                }
            }
        }
        append sCode \"  \\\"\\n\\n\"
        append sCode \"pProcessMqlCmd \\$bRegister \\$sMql\\n\\n\"
        lappend lMql $sCode
        unset aData
    }

    append Page_Content \"
        </BODY>
        </HTML>
    \"

    set lDump [ join $lDump \\n ]
    set lMql [join $lMql \\n]
    if {$bDumpMQL} {pfile_write [file join $sDumpSchemaDirSystem ${Object}.tcl] $lMql}
#    if { $bDumpSpinner } { pfile_write [ file join $sDumpSchemaDirSystem ${Object}.xls ] $lDump }
    if { $bDumpSchema } { pfile_write [ file join $Out_Directory ${Object}.html ] $Page_Content }
    return 0
}



################################################################################
# Generate_Simple
#   Generate HTML page for simple category of business definitions
#
#   Parameters :
#       category
#   Return : none
#
proc Generate_Simple { category } {

    global Out_Directory
    global sDirSpinnerExport
    global sDumpProperties
    global bDumpSchema
    global bDumpSpinner
    upvar aAdmin aAdmin
    upvar aDirs aDirs

    set lProp [list ]

    # Get definition instances
    set Object $category
    set Instances $aAdmin($Object)

    # Head of HTML page
    set Page_Content \"
        <HTML>
        <HEAD>
        <TITLE>$Object</TITLE>
        </HEAD>
        <BODY>
    \"

    # Body of HTML page
    foreach instance $Instances {

        if {[catch {set Content [lrange [split [mql print $Object $instance] \\n] 1 end]} sMsg] != 0} {continue}

        append Page_Content \"
            <A NAME=\\\"[Replace_Space $instance]\\\">
            <TABLE BORDER=0>
            <TR>
            <TD ALIGN=RIGHT BGCOLOR=#F5F5F5 WIDTH=150><FONT SIZE=+1>$Object</FONT></TD>
            <TD ALIGN=LEFT BGCOLOR=#F5F5F5><FONT SIZE=+1>$instance</FONT></TD>
            </TR>
            </A>\"

        foreach item $Content {
            set item [split $item]
            set item_name [lindex $item 2]

            # Property case
            # Extract property name and property value
            if { $item_name == \"property\" } {
                set property [lrange $item 3 end]
                set value_index [lsearch -exact $property \"value\"]
                if { $value_index != -1 } {
                    set item_name [join [lrange $property 0 [expr $value_index -1]]]
                    set item_content [join [lrange $property [expr $value_index +1] end]]
                } else {
                    set item_content [join [lrange $item 3 end]]
                }
                lappend lProp \"$item_name \\t $item_content\"

            # Default case
            } else {
                set item_content [join [lrange $item 3 end]]
            }

            append Page_Content \"<TR>
                  <TD ALIGN=RIGHT BGCOLOR=#DCDCDC><B><FONT SIZE=-1>$item_name</B></FONT></TD>
                  <TD ALIGN=LEFT><FONT SIZE=-1>$item_content</FONT></TD>
                </TR>\"
        }
        if { [ llength $lProp ] > 0 } {
            set lProp [ join $lProp \\n ]
#            if { $bDumpSpinner } { pfile_write [ file join $sDumpProperties ${Object}_${instance}.xls ] $lProp }
        }
        set lProp [list ]
        if { $Object == \"command\" || $Object == \"menu\" || $Object == \"channel\" || $Object == \"portal\" || $Object == \"page\" || $Object == \"interface\" || $Object == \"expression\" || $Object == \"index\" || $Object == \"dimension\"} {
            # Do nothing
        } else {
            if {$bDumpSpinner} { mql export $Object $instance into file [file join $aDirs(sDirSpinnerExport${Object}) ${instance}.exp] }
        }
        append Page_Content \"\\n</TABLE><BR><BR>\"
    }

    append Page_Content \"
        </BODY>
        </HTML>
    \"

    if { $bDumpSchema } { 
        if {$Object != \"index\"} {
             pfile_write [ file join $Out_Directory ${Object}.html ] $Page_Content
        } else {
             pfile_write [ file join $Out_Directory index_.html ] $Page_Content
        }
    }
         
    return 0
}



################################################################################
# Generate_Summary_Menu
#   Generate HTML page for a menu page (left frame)
#
#   Parameters :
#       category
#   Return : none
#
proc Generate_Summary_Menu { category } {
    upvar Category_Order Category_Order
    upvar Out_Directory Out_Directory
    upvar Statistic Statistic
    upvar aAdmin aAdmin
    global bDumpSchema
    global bDumpSpinner
    global glsTriggerManagerObjects


    set Summary_Menu_Page \"
        <HTML>
        <HEAD>
        <TITLE>$category</TITLE>
        </HEAD>
        <BODY>
        <A HREF=general.html TARGET=Category><IMG SRC=Images/ematrix_logo.gif BORDER=0 WIDTH=145 HEIGHT=32></A><BR><BR><BR>
    \"

    foreach category_menu $Category_Order {

        # List administrative objects for category asked
        if { $category_menu == $category } {
            append Summary_Menu_Page \"<A HREF=summary.html TARGET=\\\"Summary\\\"><IMG SRC=Images/moins.gif BORDER=0 WIDTH=9 HEIGHT=9> $category_menu</A><BR>\"
            if {$category == \"Trigger Manager Objects\"} {
                set Objects [lsort -dictionary $glsTriggerManagerObjects]
                append Summary_Menu_Page \"<TABLE BORDER=0 CELLSPACING=0>\"
                foreach object $Objects {
                    append Summary_Menu_Page \"
                            <TR><TD WIDTH=25>&nbsp;</TD>
                            <TD ALIGN=LEFT NOWRAP><A HREF=\\\"[Replace_Space $category].html#[Replace_Space $object]\\\" TARGET=\\\"Category\\\">$object</A><BR></TD>
                            </TR>
                    \"
            }
            append Summary_Menu_Page \"</TABLE>\"

            } else {
                set Objects $aAdmin($category)
                append Summary_Menu_Page \"<TABLE BORDER=0 CELLSPACING=0>\"
                foreach object $Objects {
                    set sSubstitute [Replace_Space $category]
                    if {$sSubstitute == \"index\"} {set sSubstitute \"index_\"}
                    append Summary_Menu_Page \"
                            <TR><TD WIDTH=25>&nbsp;</TD>
                            <TD ALIGN=LEFT NOWRAP><A HREF=\\\"$sSubstitute.html#[Replace_Space $object]\\\" TARGET=\\\"Category\\\">$object</A><BR></TD>
                            </TR>
                    \"
                }
                append Summary_Menu_Page \"</TABLE>\"

            }
            # Update Statistic
            #puts \"Add_Value_Element_To_Array Statistic $category [llength $Objects]\"
            Add_Value_Element_To_Array Statistic $category [llength $Objects]

        # Display a link for other category
        } else {
            if {$category_menu == \"index\"} {
                append Summary_Menu_Page \"<A HREF=\\\"index__menu.html\\\" TARGET=\\\"Summary\\\"><IMG SRC=Images/plus.gif BORDER=0 WIDTH=9 HEIGHT=9> $category_menu</A><BR>\"
            } else {
                append Summary_Menu_Page \"<A HREF=\\\"${category_menu}_menu.html\\\" TARGET=\\\"Summary\\\"><IMG SRC=Images/plus.gif BORDER=0 WIDTH=9 HEIGHT=9> $category_menu</A><BR>\"
            }
        }
    }

    #puts \"[array get Statistic]\"
    if { $bDumpSchema } { pfile_write [ file join $Out_Directory [Replace_Space $category]_menu.html ] $Summary_Menu_Page }
    return 0
}


#************************************************************************
# Procedure:   pfile_write
#
# Description: Procedure to write a variable to file.
#
# Parameters:  The filename to write to,
#              The data variable.
#
# Returns:     Nothing
#************************************************************************

proc pfile_write { filename data } {
  return  [catch {
    set fileid [open $filename \"w+\"]
    puts $fileid $data
    close $fileid
  }]
}
#End pfile_write


#************************************************************************
# Procedure:   pfile_read
#
# Description: Procedure to read a file.
#
# Parameters:  The filename to read from.
#
# Returns:     The file data
#************************************************************************

proc pfile_read { filename } {

  set data \"\"
  if { [file readable $filename] } {
    set fd [open $filename \"r\"]
    set data [read $fd]
    close $fd
  }
  return $data
}
#End file_read



proc pRemSpecChar {filename} {

    # Note, still need to add double quote, less than and greater than.
    #List elements are, {\\\\\\\" %22} {< %3C} {> %3E}
    set lChar [list {\\\\\\\\ %5C} {/ %2F} {: %3A} {\\\\\\* %2A} {\\\\\\? %3F} {\\\\\\| %7C}]

    foreach i $lChar {

        set sLabel [lindex $i 0]
        set sValue [lindex $i 1]

        regsub -all -- \"$sLabel\" $filename \"$sValue\" filename

    }

    return $filename

}
#End pRemSpecChar



proc pFormatSpinner { lData sHead sType } {

    global lAccessModes
    global sPositive
    global sNegative
 
    set sDelimit \"\\t\"
    set sFormat \"\"

    if { [ llength $lData ] == 0 } {
        append sFormat \"No Data\"
        return $sFormat
    }

    if {$sType == \"Rule\"} {
        append sFormat \"Rule\"
    } else {
        append sFormat \"State\"
    }
    
    append sFormat \"${sDelimit}User\"

    # construct the access headers
    foreach sMode $lAccessModes {
        append sFormat \"$sDelimit$sMode\"
    }
    append sFormat \"${sDelimit}Filter\"
    append sFormat \"\\n\"

    foreach line $lData {
        if { $line == \"\" } {
            continue
        }
        set sPolicyDetails [ lindex $line 0 ]
        set sPolicyData [ lindex $line 1 ]
        set sFilter [ lindex $sPolicyData 1 ]
        set sLeft [ split [ lindex $line 0 ] , ]
        set sOwner [ lindex $sLeft 2 ]
        set sLeft [ split [ lindex $sLeft 0 ] | ]
        set sPolicy [ lindex $sLeft 0 ]
        set sState [ lindex $sLeft 2 ]
        set sRights [ lindex $sPolicyData 0 ]

        append sFormat \"$sState\"
        append sFormat \"$sDelimit$sOwner\"

        if { $sRights == \"all\" } {
            set sNegativeValue $sPositive
        } else {
            set sNegativeValue $sNegative
        }
        foreach sMode $lAccessModes {
            set sMode [string tolower $sMode]
            if { [ lsearch $sRights $sMode ] == -1 } {
                append sFormat \"$sDelimit$sNegativeValue\"
            } else {
                append sFormat \"$sDelimit$sPositive\"
            }
        }
        append sFormat \"$sDelimit$sFilter\"
        append sFormat \"\\n\"

    }
    return $sFormat
}


proc pFormat { lData sHead sType } {

    global lAccessModes
    global sPositive
    global sNegative


    set sFormat \"\"
    append sFormat \"<html>\\n\"
    append sFormat {
        <STYLE type=text/css>
        TD.odd {
            BACKGROUND-COLOR: #DDDBCC
        }
        TD.even {
            BACKGROUND-COLOR: #FFFFFF
        }
        </STYLE>
    }
    append sFormat \"<head>\"
    append sFormat \"<title>HTML document</title>\"
    append sFormat \"</head>\\n\"
    append sFormat \"<body>\"
    append sFormat \"<h1><center>$sType - $sHead</center></h1>\\n\\n\"

    set sFontC {#0000ff}

    if { [ llength $lData ] == 0 } {
        append sFormat \"<h2><center>No Data</center></h2>\\n\"
        return $sFormat
    }

    append sFormat \"<div style=\\\"width:80%\\\">\\n\"
    append sFormat \"<table rows=\\\"1\\\" border=\\\"1\\\" cols=\\\"35\\\" align=\\\"Center\\\" border=\\\"1\\\" callpadding=\\\"1\\\" cellspacing=\\\"1\\\" width=\\\"100%\\\" ID=\\\"tblHeader\\\">\\n\"
    # construct the table header row
    append sFormat \"<tr>\\n\"
    if { $sType == \"Policy\" } {
        append sFormat \"<td CLASS=even VALIGN=BOTTOM ALIGN=LEFT><B>State</B></td>\\n\"
        append sFormat \"<td CLASS=even VALIGN=BOTTOM ALIGN=LEFT><B>User</B></td>\\n\"
    } else {
        append sFormat \"<td CLASS=even VALIGN=BOTTOM ALIGN=LEFT><B>Policy</B></td>\\n\"
        append sFormat \"<td CLASS=even VALIGN=BOTTOM ALIGN=LEFT><B>State</B></td>\\n\"
    }
    # construct the access headers
    set lModes $lAccessModes
    lappend lModes Filter
    
    if {$sType == \"Policy\"} {
        foreach sMode $lModes {
            append sFormat \"<td CLASS=even VALIGN=BOTTOM ALIGN=CENTER><IMG SRC=\\\"../Images/[string tolower $sMode].gif\\\" ALT=\\\"$sMode\\\"></TD>\\n\"
        }
    } else {
        foreach sMode $lModes {
            append sFormat \"<td CLASS=even VALIGN=BOTTOM ALIGN=CENTER><IMG SRC=\\\"../../Images/[string tolower $sMode].gif\\\" ALT=\\\"$sMode\\\"></TD>\\n\"
        }
    }
    append sFormat \"</tr>\\n\"
    append sFormat \"</table>\\n\"

    append sFormat \"<div style=\\\"height:400;overflow:auto;\\\">\\n\"
    append sFormat \"<table cols=\\\"35\\\" border=\\\"1\\\" width=\\\"100%\\\" id=\\\"tblData\\\">\\n\"
    append sFormat \"<tr height=\\\"0\\\">\\n\"

    for {set x 0} {$x < 35} {incr x} {
        append sFormat \"<td></td>\\n\"
    }
    append sFormat \"</tr>\\n\"

    set sData $lData
    set sLastPolicy \"\"
    set sLastState \"\"
    set sMajorRowClass \"even\"
    set sMinorRowClass \"even\"
    set sBlankRowClass \"Spacer\"
    set nAccessColumns [expr [llength $lAccessModes] + 3]
    set sSeparator \"<TD COLSPAN=$nAccessColumns COLOR=\\\"#000000\\\" BGCOLOR=\\\"#000000\\\"><img src=\\\"../Images/utilspace.gif\\\" width=1 height=1></TD>\\n\"
    set sPositiveImage \"Y\"
    set sNegativeImage \"&nbsp\"

    set sTempData \"@[join $sData @]\"
    foreach line $sData {
        if { $line == \"\" } {
            continue
        }
        set sPolicyData [ lindex $line 1 ]
        set sLeft [ split [ lindex $line 0 ] , ]
        set sOwner [ lindex $sLeft 2 ]
        set sLeft [ split [ lindex $sLeft 0 ] | ]
        set sPolicy [ lindex $sLeft 0 ]
        set sState [ lindex $sLeft 2 ]
        set sRights [ lindex $sPolicyData 0 ]
        set sFilter [ lindex $sPolicyData 1 ]
        if { $sFilter == \"\" } {
            set sFilter \"-\"
        }
        append sFormat \"<tr>\"
        regsub -all {\\(} $sPolicy {\\\\(} sTempPolicy
        regsub -all {\\)} $sTempPolicy {\\\\)} sTempPolicy
        if { $sType == \"Policy\" } {
            # figure out how many rows there are with the same state
            # Make the state Name spans the correct number of rows
            if {$sState != $sLastState} {
                set sMatch \"@\\[\\{\\]?$sTempPolicy\\\\|\\[0-9\\]+\\\\|$sState\\\\,\" ;#check for \\}
                set nNumUsersPerState [regsub -all $sMatch $sTempData {} sGarbage]
                append sFormat \"$sSeparator</tr><tr>\"
                append sFormat \"<td CLASS=\\\"$sMajorRowClass\\\" rowspan=$nNumUsersPerState>$sState</td>\"
                if {$sMajorRowClass == \"odd\"} {
                    set sMajorRowClass \"even\"
                } else {
                    set sMajorRowClass \"odd\"
                }
            }
            append sFormat \"<td CLASS=\\\"$sMinorRowClass\\\"><A HREF=\\\"user/[Replace_Space $sOwner].html\\\">$sOwner</A></td>\"
        } else {
            if {$sPolicy != $sLastPolicy} {
                set sMatch \"@\\[\\{\\]?$sTempPolicy\\\\|\\[0-9\\]+\\\\|\\[^\\\\|\\\\,\\]+\\\\,\\[0-9\\]+\\\\,$sOwner\" ;#check for \\}
                set nNumStatesPerPolicy [regsub -all $sMatch $sTempData {????} sGarbage]
                append sFormat \"$sSeparator</tr><tr>\\n\"
                append sFormat \"<td CLASS=\\\"$sMajorRowClass\\\" rowspan=$nNumStatesPerPolicy><A HREF=\\\"../[Replace_Space $sPolicy].html\\\">$sPolicy</A></td>\"
                if {$sMajorRowClass == \"odd\"} {
                    set sMajorRowClass \"even\"
                } else {
                    set sMajorRowClass \"odd\"
                }
            }
            append sFormat \"<td CLASS=\\\"$sMinorRowClass\\\">$sState</td>\"
        }

        if { $sRights == \"all\" } {
            set sNegativeValue $sPositiveImage
        } else {
            set sNegativeValue $sNegativeImage
        }
        foreach sMode $lAccessModes {
            set sMode [string tolower $sMode]
            if { [ lsearch $sRights $sMode ] == -1 } {
                append sFormat \"<td CLASS=\\\"$sMinorRowClass\\\">$sNegativeValue</td>\"
            } else {
                append sFormat \"<td CLASS=\\\"$sMinorRowClass\\\">$sPositiveImage</td>\"
            }
        }
        append sFormat \"<td CLASS=\\\"$sMinorRowClass\\\"> $sFilter</td>\"
        append sFormat \"</tr>\\n\\n\"
        if {$sMinorRowClass == \"odd\"} {
            set sMinorRowClass \"even\"
        } else {
            set sMinorRowClass \"odd\"
        }
        set sLastState $sState
        set sLastPolicy $sPolicy
    }

    append sFormat \"</td>\\n\"
    append sFormat \"        </table>\\n\"
    append sFormat \"</div>\\n\"
    append sFormat \"</td> </tr> </table>\\n\"
    append sFormat \"</div>\\n\"

    append sFormat \"<script language=\\\"javascript\\\">

    doSyncTables();
    function doSyncTables(){
    var i;
    var nDtlCol = document.getElementById('tblData').rows\\[0\\].cells.length;
    var hdrColLength=\\\"\\\";
    var dltColLength=\\\"\\\";
    var dltColLength2=\\\"\\\";
    var colWidth = 0;

    for (i=0; i < nDtlCol; i++) {
        dltColLength2 = document.getElementById('tblHeader').cells\\[i\\].offsetWidth;
        dltColLength = document.getElementById('tblData').cells\\[i\\].offsetWidth;
        dltColLength2=parseInt(dltColLength2);
        dltColLength=parseInt(dltColLength);
     if (dltColLength<dltColLength2){
         dltColLength = dltColLength2;
     }
     if (dltColLength > 0){
         document.getElementById('tblData').cells\\[i\\].width = dltColLength;
         document.getElementById('tblHeader').cells\\[i\\].width = dltColLength;
     }     
     }     
     window.tblHeader.width  = window.tblData.offsetWidth;
     }
     </script>\\n\"

    append sFormat \"    </body>\\n\"
    append sFormat \"</html>\\n\"

    return $sFormat
}

proc Generate_ExtendedPolicy { } {

    global bDumpSchema
    global bDumpSpinner
    global bStatus
    global bExtendedPolicy
    global lExtendedPersonData
    global Out_Directory
    global lAccessModes
    global sPolicySpinnerDir
    global sRuleSpinnerDir
    global nMxVer
    upvar aAdmin aAdmin

    set lAccessModes [ list Read Modify Delete Checkout Checkin Schedule Lock \\
        Unlock Execute Freeze Thaw Create Revise Promote Demote Grant Enable \\
        Disable Override ChangeName ChangeType ChangeOwner ChangePolicy Revoke \\
        ChangeVault FromConnect ToConnect FromDisconnect ToDisconnect \\
        ViewForm Modifyform Show ]

#    set lAccessModes [ list read modify delete checkout checkin lock unlock \\
#        changeowner promote demote schedule override enable disable create \\
#        revise changevault changename changepolicy changetype fromconnect \\
#        toconnect fromdisconnect todisconnect freeze thaw execute modifyform \\
#        viewform grant show]
        
    set lSpecialUsers [ list Public Owner ]
        
    global sPositive
    global sNegative

    set sPositive Y
    set sNegative \"-\"

    set lPolicy $aAdmin(policy)
    set lRule $aAdmin(rule)
    set lPerson $aAdmin(person)
    set lRole $aAdmin(role)
    set lGroup $aAdmin(group)
    set lAssociation $aAdmin(association)

    if {$bStatus} {puts \"Start Process Extended Policy ...\"}

    foreach sPol $lPolicy {
        set sStates [ split [ mql print policy $sPol select state dump | ] | ]
        set bAllstate FALSE
        if {$nMxVer >= 10.8} {set bAllstate [ mql print policy $sPol select allstate dump ]}
        if {$sStates != [list ] && $bAllstate} {lappend sStates \"allstate\"}
        set sStOrder 0
        foreach sSt $sStates {
            if {$sSt == \"allstate\"} {
                set sOwner [ split [ string trim [ mql print policy $sPol select allstate.owneraccess dump | ] ] , ]
                set data($sPol|$sStOrder|$sSt,0,Owner) [ list $sOwner \"\" ]
                set sPublic [ split [ string trim [ mql print policy $sPol select allstate.publicaccess dump | ] ] , ]
                set data($sPol|$sStOrder|$sSt,0,Public) [ list $sPublic \"\" ]
                set sUsers [ split [ mql print policy $sPol select allstate.access ] \\n ]
            } else {
                set sOwner [ split [ string trim [ mql print policy $sPol select state\\[$sSt\\].owneraccess dump | ] ] , ]
                set data($sPol|$sStOrder|$sSt,0,Owner) [ list $sOwner \"\" ]
                set sPublic [ split [ string trim [ mql print policy $sPol select state\\[$sSt\\].publicaccess dump | ] ] , ]
                set data($sPol|$sStOrder|$sSt,0,Public) [ list $sPublic \"\" ]
                set sUsers [ split [ mql print policy $sPol select state\\[$sSt\\].access ] \\n ]
            }
            foreach i $sUsers {
                set i [ string trim $i ]
                if {[string first \"policy\" $i] == 0} {continue}
                if { $i != \"\" } {
                    #MODIFICATION by FIT -start
                    set sLine [ split $i \"=\" ]
                    set sUs [string range [ lindex $sLine 0 ] [ string first \".\" $sLine ] end ]
                    #set sLine [ lindex [ split $i \".\" ] 1 ]
                    #set sLine [ split $sLine \"=\" ]
                    #MODIFICATION by FIT -end
                    set sRights [ split [ string trim [ lindex $sLine 1 ] ] , ]
                    if { $sRights == \"all\" } {
#                        set sRights $lAccessModes
                    } elseif { $sRights == \"none\" } {
                        set sRights \"\"
                    }
                    #MODIFICATION by FIT -start
                    #set sUs [string trim [ lindex $sLine 0 ] ]
                    #MODIFICATION by FIT -end
                    
                    if {[string first \"access\\[\" $sUs] > -1} {
                        regsub \"access\\134\\[\" $sUs \"|\" sUs
                        set sUs [lindex [split $sUs |] 1]
                        regsub \"\\134\\]\" $sUs \"\" sOwner
                        if {$sSt == \"allstate\"} {
                            set sExpression [ mql print policy \"$sPol\" select allstate.filter\\[$sOwner\\] dump ]
                        } else {
                            set sExpression [ mql print policy \"$sPol\" select state\\[$sSt\\].filter\\[$sOwner\\] dump ]
                        }
                        set data($sPol|$sStOrder|$sSt,1,$sOwner) [ list $sRights $sExpression ]
                    }
                }
            }
            incr sStOrder
        }
    }
 
    set sSpin \"\"
    set bb \"\"
    if {$bStatus} {puts \"Start Process Extended Policy by Policy Name ...\"}
    foreach sP $lPolicy {
        set pu [ lsort -dictionary [ array name data \"$sP|*|*,*,*\" ] ]
        foreach i $pu {
            lappend sSpin [ list $i $data($i) ]
        }
        if { $bDumpSpinner } {
            set sPolicySpin [ pFormatSpinner $sSpin $sP Policy ]
            pfile_write \"$sPolicySpinnerDir/$sP.xls\" $sPolicySpin
        }
        if { $bDumpSchema && $bExtendedPolicy } {
            set bb [ pFormat $sSpin $sP Policy ]
            set sFile [ Replace_Space $sP ]
            pfile_write $Out_Directory/Policy/$sFile.html $bb
        }
        set bb \"\"
        set sSpin \"\"
        set sPolicySpin \"\"
    }
     
    if {$bStatus} {puts \"Start Process Extended Rule ...\"}

    foreach sRul $lRule {
        set sOwner [ split [ string trim [ mql print rule $sRul select owneraccess dump | ] ] , ]
        set data($sRul|0|$sRul,0,Owner) [ list $sOwner \"\" ]
        set sPublic [ split [ string trim [ mql print rule $sRul select publicaccess dump | ] ] , ]
        set data($sRul|0|$sRul,0,Public) [ list $sPublic \"\" ]
        set sUsers [ split [ mql print rule $sRul select access ] \\n ]
        foreach i $sUsers {
            set i [ string trim $i ]
            if {[string first \"rule\" $i] == 0} {continue}
            if { $i != \"\" } {
                set sLine [ split $i \"=\" ]
                set sRights [ split [ string trim [ lindex $sLine 1 ] ] , ]
                if { $sRights == \"all\" } {
#                    set sRights $lAccessModes
                } elseif { $sRights == \"none\" } {
                    set sRights \"\"
                }
                set sUs [string trim [ lindex $sLine 0 ] ]
                if {[string first \"access\\[\" $sUs] > -1} {
                    regsub \"access\\134\\[\" $sUs \"|\" sUs
                    set sUs [lindex [split $sUs |] 1]
                    regsub \"\\134\\]\" $sUs \"\" sOwner
                    set sExpression [ mql print rule \"$sRul\" select filter\\[$sOwner\\] dump ]
                    set data($sRul|0|$sRul,1,$sOwner) [ list $sRights $sExpression ]
                }
            }
        }
    }
 
    set sSpin \"\"
    set bb \"\"
    if {$bStatus} {puts \"Start Process Extended Rule by Rule Name ...\"}
    foreach sR $lRule {
        set ru [ lsort -dictionary [ array name data \"$sR|*|*,*,*\" ] ]
        foreach i $ru {
            lappend sSpin [ list $i $data($i) ]
        }
        if { $bDumpSpinner } {
            set sRuleSpin [ pFormatSpinner $sSpin $sR Rule ]
            pfile_write \"$sRuleSpinnerDir/$sR.xls\" $sRuleSpin
        }
        if { $bDumpSchema && $bExtendedPolicy } {
            set bb [ pFormat $sSpin $sR Rule ]
            set sFile [ Replace_Space $sR ]
            pfile_write $Out_Directory/Rule/$sFile.html $bb
        }
        set bb \"\"
        set sSpin \"\"
        set sRuleSpin \"\"
    }
     
    set sSpin \"\"
    set bb \"\"
    if { $bDumpSchema && $bExtendedPolicy} {
        if {$bStatus} {puts \"Start Process Extended Policy Schema for Person ...\"}
        foreach sP $lPerson {
            set pu [ lsort -dictionary [ array name data \"*,*,$sP\" ] ]
            if {$pu == \"\"} {continue}
            lappend lExtendedPersonData $sP
            foreach i $pu {
                lappend sSpin [ list $i $data($i) ]
            }
            set bb [ pFormat $sSpin $sP Person ]
            set sFile [ Replace_Space $sP ]
            pfile_write $Out_Directory/Policy/user/$sFile.html $bb
            set bb \"\"
            set sSpin \"\"
        }
    }


    set sSpin \"\"
    set bb \"\"
    if { $bDumpSchema && $bExtendedPolicy} {
        if {$bStatus} {puts \"Start Process Extended Policy Schema for Role ...\"}
        foreach sP $lRole {
            set pu [ lsort -dictionary [ array name data \"*,*,$sP\" ] ]
            foreach i $pu {
                lappend sSpin [ list $i $data($i) ]
            }
            set bb [ pFormat $sSpin $sP Role ]
            set sFile [ Replace_Space $sP ]        
            pfile_write $Out_Directory/Policy/user/$sFile.html $bb
            set bb \"\"
            set sSpin \"\"
        }
    }


    set sSpin \"\"
    set bb \"\"
    if { $bDumpSchema && $bExtendedPolicy} {
        if {$bStatus} {puts \"Start Process Extended Policy Schema for Group ...\"}
        foreach sP $lGroup {
            set pu [ lsort -dictionary [ array name data \"*,*,$sP\" ] ]
            foreach i $pu {
                lappend sSpin [ list $i $data($i) ]
            }
            set bb [ pFormat $sSpin $sP Group ]
            set sFile [ Replace_Space $sP ]        
            pfile_write $Out_Directory/Policy/user/$sFile.html $bb
            set bb \"\"
            set sSpin \"\"
        }
    }

    set sSpin \"\"
    set bb \"\"
    if { $bDumpSchema && $bExtendedPolicy} {
        if {$bStatus} {puts \"Start Process Extended Policy Schema for Association ...\"}
        foreach sP $lAssociation {
            set pu [ lsort -dictionary [ array name data \"*,*,$sP\" ] ]
            foreach i $pu {
                lappend sSpin [ list $i $data($i) ]
            }
            set bb [ pFormat $sSpin $sP Association ]
            set sFile [ Replace_Space $sP ]        
            pfile_write $Out_Directory/Policy/user/$sFile.html $bb
            set bb \"\"
            set sSpin \"\"
        }
    }


    set sSpin \"\"
    set bb \"\"
    if { $bDumpSchema && $bExtendedPolicy} {
        if {$bStatus} {puts \"Start Process Extended Policy Schema for SpecialUsers ...\"}
        foreach sP $lSpecialUsers {
            set pu [ lsort -dictionary [ array name data \"*,*,$sP\" ] ]
            foreach i $pu {
                lappend sSpin [ list $i $data($i) ]
            }
            set bb [ pFormat $sSpin $sP Special ]
            set sFile [ Replace_Space $sP ]        
            pfile_write $Out_Directory/Policy/user/$sFile.html $bb
            set bb \"\"
            set sSpin \"\"
        }
    }
}



################################################################################
# Generate_TriggerLinks
#
#   Parameters : TriggerData string
#   Return     : HTML formatted string containing Trigger information and hyperlinks
#
proc Generate_TriggerLinks {lsTriggerData sAdminType sAdminName {sState \"\"}} {
    upvar aTriggerXRef aTriggerXRef

    global glsPrograms
    global glsTriggerManagerObjects

    set sTempHTML \"<TABLE BORDER=0>\"
    foreach trigger $lsTriggerData {
        set trigger [split $trigger :]
        set trigger_event [lindex $trigger 0]
        set program_parameters [lindex $trigger 1]
        set bracket_index [string first ( $program_parameters]
        set program_name [string range $program_parameters 0 [expr $bracket_index -1]]
        set parameters [string range $program_parameters [expr $bracket_index +1] [expr [string length $program_parameters] -2]]

        # Add the trigger type,policy, state to the global list of \"Where-used\" triggers
        set lTriggerRef \"\"
        catch { set lTriggerRef $aTriggerXRef($program_name) }
        set sRefData \"$sAdminType|$sAdminName|$sState|$trigger_event\"
        if {[lsearch -exact $lTriggerRef $sRefData] == -1} {
            lappend lTriggerRef $sRefData
        }
        set aTriggerXRef($program_name) $lTriggerRef


        append sTempHTML \"<TR><TD><FONT SIZE=-1>$trigger_event</FONT></TD><TD>\"
        append sTempHTML \"<FONT SIZE=-1><A HREF=\\\"program.html#[Replace_Space $program_name]\\\">$program_name</FONT></A> \"
        # Assume the parameters are in tcl list format
        # for each list element, see if it is corresponds to an
        # eServiceTrigger object or an actual program
        set sParamData \"\"
        foreach sParam $parameters {
            set bIsProgram [lsearch -exact $glsPrograms $sParam]
            set bIsTriggerObject [lsearch -exact $glsTriggerManagerObjects $sParam]
            if {$bIsProgram != -1  || $bIsTriggerObject != -1 } \\
            {
                set lTriggerRef \"\"
                catch { set lTriggerRef $aTriggerXRef($sParam) }
                set sRefData \"$sAdminType|$sAdminName|$sState|$trigger_event\"
                if {[lsearch -exact $lTriggerRef $sRefData] == -1} {
                    lappend lTriggerRef $sRefData
                }
                set aTriggerXRef($sParam) $lTriggerRef

                # create the hyperlinks to the parameters
                if {$bIsProgram != -1} {
                    set sProgramLink \"<A HREF=\\\"program.html#[Replace_Space $sParam]\\\"><FONT SIZE=-1>$sParam</FONT></A>\"
                } elseif {$bIsTriggerObject != -1} {
                    set sProgramLink \"<A HREF=\\\"Trigger_Manager_Objects.html#[Replace_Space $sParam]\\\"><FONT SIZE=-1>$sParam</FONT></A>\"
                } else {
                    set sProgramLink \"<FONT SIZE=-1>$sParam</FONT>\"
                }
                append sParamData \" $sProgramLink\"
            }
        }
        if {$sParamData == \"\"} {
            set sParamData \"&nbsp;\"
        }

        append sTempHTML \"$sParamData</TD></TR>\\n\"
#        append sTempHTML \"<TR><TD><FONT SIZE=-1>$trigger_event</FONT></TD>  <TD><FONT SIZE=-1><A HREF=\\\"program.html#[Replace_Space $program_name]\\\">$program_name</FONT></A> <FONT SIZE=-1>$parameters</FONT></TD></TR>\"
    }
    append sTempHTML \"</TABLE>\"

    return $sTempHTML

}


################################################################################
# Generate_TriggerObjects
#
#   Parameters : none
#   Return     : none
#
proc Generate_TriggerObjects { } {
  global Out_Directory Out_Directory
  global bDumpSchema
  global bDumpSpinner
  set sType \"eService Trigger Program Parameters\"

  if { [ catch { mql print type $sType } sErr ] == 0 } {


#  set lHeads [ list \"type 1\" name revision current desc ]
#    set lAtt [list \"eService Program Name\" \"eService Sequence Number\" \\
#        \"eService Program Argument 1\" \"eService Program Argument Desc 1\" \\
#        \"eService Program Argument 2\" \"eService Program Argument Desc 2\" \\
#        \"eService Program Argument 3\" \"eService Program Argument Desc 3\" \\
#        \"eService Program Argument 4\" \"eService Program Argument Desc 4\" \\
#        \"eService Program Argument 5\" \"eService Program Argument Desc 5\" \\
#        \"eService Program Argument 6\" \"eService Program Argument Desc 6\" \\
#        \"eService Program Argument 7\" \"eService Program Argument Desc 7\" \\
#        \"eService Program Argument 8\" \"eService Program Argument Desc 8\" \\
#        \"eService Program Argument 9\" \"eService Program Argument Desc 9\" \\
#        \"eService Program Argument 10\" \"eService Program Argument Desc 10\" \\
#        \"eService Program Argument 11\" \"eService Program Argument Desc 11\" \\
#        \"eService Program Argument 12\" \"eService Program Argument Desc 12\" \\
#        \"eService Program Argument 13\" \"eService Program Argument Desc 13\" \\
#        \"eService Program Argument 14\" \"eService Program Argument Desc 14\" \\
#        \"eService Program Argument 15\" \"eService Program Argument Desc 15\" \\
#    ]
    set lHeads [list \"eService Program Name\" \"eService Sequence Number\" ]
    set lAtt [ lsort -dictionary -index end [ split [ mql print type $sType select attribute dump | ] | ] ]

    set sCmd \"mql temp query bus \\\"$sType\\\" * * select current description\"
    foreach sAttr $lHeads {
        append sCmd \" attribute\\\\\\[$sAttr\\\\\\].value\"
    }
    foreach sAttr $lAtt {
        if {[lsearch -exact $lHeads $sAttr] == -1} {
            lappend lHeads $sAttr
            append sCmd \" attribute\\\\\\[$sAttr\\\\\\].value\"
        }
    }
#    set sRecSep [format \"%c\" 127]
#    append sCmd \" dump | recordsep $sRecSep\"
    append sCmd \" dump |\"

    # Append the basic info to the list of information returned
#    set lHeads [ linsert $lAtt 0 Type Name Revision State Description ]
    if { [ catch { eval $sCmd } sMsg ] == 0 } {
        set Object [ split $sMsg \\n ]
    } else {
      puts \"an error occurred\\nthe message is:\\n$sMsg\"
    }

    set Object [lsort -dictionary $Object]
    set Page_Content [pFormatTriggerObj_html $sType $lHeads $Object]
    if {$bDumpSchema} { pfile_write [file join $Out_Directory Trigger_Manager_Objects.html] $Page_Content }
#puts \"sType = $sType\"
#puts \"lHeads = $lHeads\"
#puts \"Object = $Object\"
    }
}

################################################################################
# pFormatTriggerObj_html
#
#   Parameters : none
#   Return     : none
#
proc pFormatTriggerObj_html { sType lAtt data } {
    global glsTriggerManagerObjects
    set Page_Content \"
        <HTML>
        <HEAD>
        <TITLE>$sType</TITLE>
        </HEAD>
        <BODY>
        <CENTER>
        <FONT SIZE=+2><B>$sType</B></FONT>
        </CENTER>\"

    regsub -all \"\\n\" $data {<BR>} data
    set sLastTriggerObjName \"\"

    append Page_Content \"<TABLE BORDER=0>\\n\"

    foreach linedata $data {
        set lineinfo [ split $linedata | ]
        set nCount 0
        set lsBasicInfo [lrange $lineinfo 0 4]
        set lineinfo [lrange $lineinfo 5 end]
        set sObjType  [lindex $lsBasicInfo 0]
        set sObjName  [lindex $lsBasicInfo 1]
        set sObjRev   [lindex $lsBasicInfo 2]
        set sObjState [lindex $lsBasicInfo 3]
        set sObjDesc  [lindex $lsBasicInfo 4]
        if {$sObjName != $sLastTriggerObjName} {
            lappend glsTriggerManagerObjects $sObjName
            append Page_Content \"\\n<TR><TD COLSPAN=2 ALIGN=LEFT BGCOLOR=#F5F5F5 VALIGN=BOTTOM>\"
            append Page_Content \"<A NAME=\\\"[Replace_Space $sObjName]\\\">\"
            append Page_Content \"<FONT SIZE=+1>$sObjName</FONT>\"
            append Page_Content \"</A>\"
            append Page_Content \"</TD></TR>\\n\"
        }
        append Page_Content \"<TR><TD ALIGN=RIGHT BGCOLOR=#DCDCDC VALIGN=BOTTOM><FONT SIZE=+1>\"
        append Page_Content \"Id\"
        append Page_Content \"</FONT></TD>\\n\"
        append Page_Content \"<TD ALIGN=LEFT BGCOLOR=#F5F5F5 VALIGN=BOTTOM><FONT SIZE=+1>\"
        append Page_Content \"$sObjRev\"
        append Page_Content \"</FONT></TD></TR>\\n\"
        if {$sObjState == \"Active\"} {
            set sColor \"#009900\"
        } else {
            set sColor \"#FF0000\"
        }
        append Page_Content \"
        <TR>
        <TD ALIGN=RIGHT BGCOLOR=#DCDCDC WIDTH=150><FONT SIZE=+1>State</FONT></TD>
        <TD ALIGN=LEFT BGCOLOR=#FFFFFF VALIGN=BOTTOM><FONT COLOR=$sColor SIZE=+1>$sObjState</FONT></TD>
        </TR>
        <TR>
        <TD ALIGN=RIGHT BGCOLOR=#DCDCDC WIDTH=150><FONT SIZE=+1>Description</FONT></TD>
        <TD ALIGN=LEFT BGCOLOR=#FFFFFF VALIGN=BOTTOM>$sObjDesc</TD>
        </TR>\"
        foreach sAttrName $lAtt sAttrValue $lineinfo {
            incr nCount
            if {$sAttrName == \"eService Program Name\"} {
                append Page_Content \"<TR>
                    <TD ALIGN=RIGHT BGCOLOR=#DCDCDC WIDTH=150><B><FONT SIZE=-1>$sAttrName</B></FONT></TD>
                    <TD ALIGN=LEFT><FONT SIZE=-1><A HREF=\\\"program.html#[Replace_Space $sAttrValue]\\\">$sAttrValue</FONT></A></TD>
                    </TR>\\n\"
            } else {
                if {$sAttrValue != \"\"} {
                    append Page_Content \"<TR>
                        <TD ALIGN=RIGHT BGCOLOR=#DCDCDC WIDTH=150><B><FONT SIZE=-1>$sAttrName</B></FONT></TD>
                        <TD ALIGN=LEFT><FONT SIZE=-1>$sAttrValue</FONT></TD>
                        </TR>\\n\"
                }
            }
        }
        # End foreach
        append Page_Content \"<TR><TD COLSPAN=2>&nbsp;</TD></TR>\"
        set sLastTriggerObjName $sObjName
    }
    append Page_Content \"</TABLE>\\n<BR>\"

    append Page_Content \"
        </BODY>
        </HTML>\"

    return $Page_Content

}


################################################################################
# pRemoveElement
#
#   Parameters : list to clear
#   Return     : list with element removed
#
proc pRemoveElement { llist } {

    set bDone 0
    set sRemove \"adm*\"

    while { $bDone == 0 } {

        set nIndex [ lsearch $llist $sRemove ]
        if { $nIndex == -1 } {
            set bDone 1
        } else {
            set llist [ lreplace $llist $nIndex $nIndex ]
        }
    }

    return $llist
}


proc pProcessFile { lAdmin sFileName sDelimit } {

    global bStatus
    upvar aAdminTemp aAdminTemp

    set sFileData [ split [ pfile_read $sFileName ] \\n ]
    set sFileLine1 [split [lindex $sFileData 0] $sDelimit ]
    set sFileMarker [ lindex $sFileLine1 0 ]
    set sInVersion [ lindex $sFileLine1 1 ]
    set sFileType [ lindex $sFileLine1 3 ]
    set nLineStart [ lindex $sFileLine1 5 ]
    if {$bStatus} {puts \"Input File,\\nVersion: $sInVersion\\nData Type to process: $sFileType\\nLine Start: $nLineStart\"}

    switch $sFileType {
    filter {
        set sData [lrange $sFileData [ expr $nLineStart - 1] end]
        foreach sDataLine $sData {
            set sVal [ lindex [ split $sDataLine ] 2]
            if {$sVal == \"\"} {continue}
#            set aAdminTemp($sVal) [split [eval $sDataLine] \\n]

            set lLH [split [eval $sDataLine] \\n]
            if { [ info exists aAdminTemp($sVal) ] == 0 } {
                set aAdminTemp($sVal) $lLH
            } else {
                set lRH $aAdminTemp($sVal)
                set aAdminTemp($sVal) [lindex [pCompareLists $lLH $lRH] 3]
            }
        }
    }
    data {
        set sHeaderRaw [ split [ lindex $sFileData [ expr $nLineStart - 1] ] \"\\t\" ]
        set sHeader [ list ]
        foreach i $sHeaderRaw {
            lappend sHeader [ string trim $i ]
        }
        set sData [ lrange $sFileData $nLineStart end ]
        foreach sDataLine $sData {
            set sDataLine [ split $sDataLine $sDelimit ]
            foreach i $sHeader j $sDataLine {
                if { $j != \"\" } {
                    # Make sure the file header is in the admin list
                    if { [ lsearch $lAdmin ${i}* ] == -1 } {
                        if { $bStatus } { puts \"Header error $i is not a recognized admin type, check developer file ...\" }
                    }
                    # Check to see if name really exists
                    if {$i == \"table\" } {
                        set sRes [mql list $i $j system]
                    } else {
                        set sRes [mql list $i $j]
                    }
                    if {$sRes != \"\"} {
                        set aAdminTemp($i) [ lappend aAdminTemp($i) $j ]
                    } else {
                        if {$bStatus} {puts \"Admin type $i, name $j, does not exist ...\"}
                    }
                }
            }
        }
    }
    default {puts \"unknown switch type, check input file\"}
    } ;# End Switch
}
# End pIncludeFile



proc pMergeArray { sMode lAdminName } {

    upvar aAdmin aAdmin
    upvar aAdminTemp aAdminTemp

    foreach sType $lAdminName {
    
        if {[info exists aAdminTemp($sType)] == 0} {
            continue
        }

        set l1 $aAdmin($sType)
        set l2 $aAdminTemp($sType)

        switch $sMode {
        or {
            set lReturn [ pCompareLists $l1 $l2 ]
            set aAdmin($sType) [lindex $lReturn 3]
        }
        xor {
            set lReturn [ pCompareLists $l1 $l2 ]
            set aAdmin($sType) [lindex $lReturn 0] 
        }
        default {puts \"unknown switch type from proc pMergeArray\"}
        }
    }
}
# End pMergeArray



proc pCompareLists { lList1 lList2 } {

    set lCommon {}
    set lUnique1 {}
    set lOr $lList1
    foreach i1 $lList1 {
        set nFound [ lsearch $lList2 $i1 ]
        if { $nFound == -1 } {
            lappend lUnique1 $i1
        } else {
            lappend lCommon $i1
            set lList2 [ lreplace $lList2 $nFound $nFound ]
        }
    }
    foreach i2 $lList2 {
        set nFound [ lsearch $lOr $i2 ]
        if {$nFound == -1} {
            lappend lOr $i2
        }
    }
    set lResults [ list $lUnique1 $lCommon $lList2 $lOr ]
    return $lResults
}
# End pCompareLists


proc pCheckExists {sType sName} {

    set sCmd \"mql list $sType $sName\"
    if {[catch {eval $sCmd} sMsg] == 0} {
        set sExists $sMsg
    } else {
        puts \"An error occurred with $sCmd, Error is: $sMsg\"
        return \"2|$sMsg\"
    }
    set sExists $sMsg
    if {$sExists != \"\"} {
        return \"0|\"
    } else {
        return \"1|\"
    }
}
# End pCheckExists



################################################################################
# Generate
#
#   Parameters : none
#   Return     : none
#                This is the main processing routine.
#
proc Generate { AOName } {
    upvar Attribute_Types Attribute_Types
    upvar Attribute_Relationships Attribute_Relationships
    upvar Format_Policies Format_Policies
    upvar Statistic Statistic
    upvar Out_Directory Out_Directory
    upvar Image_Directory Image_Directory
    upvar aTriggerXRef aTriggerXRef
    upvar Location_Store Location_Store
    upvar Location_Site Location_Site
    upvar Store_Policy Store_Policy
    upvar aAdmin aAdmin

    global bStatus

    upvar aInclude aInclude
    upvar aExclude aExclude

    global bExtendedPolicy
    global lExtendedPersonData
    global bPolicySpinner
    
    # A new array to hold all dirs, need to migrate them in!
    
    upvar aDirs aDirs

    global sDirSpinnerExport
    global sDumpSchemaDir
    global sDumpSchemaDirSystem
    global sDumpSchemaDirBusiness
    global sDumpSchemaDirBusinessSource
    global sDumpSchemaDirBusinessPage
    global sDumpSchemaDirSystem
    global sDumpSchemaDirSystemMap
    global sDumpSchemaDirObjects
    global sDumpProperties

    global lSpinnerAdminTypes

    global bDumpSchema
    global bDumpSpinner
    global bDumpMQL
    global sPolicySpinnerDir
    global sRuleSpinnerDir
    global glsPrograms
    global glsTriggerManagerObjects
    set glsPrograms \"\"
    set glsTriggerManagerObjects \"\"

    global bStatus
    global nMxVer
    global sHeaderTitle
    
    global glsServer
    global bSuppressAdmReporting
    global bSuppressHidden

    set lExtendedPersonData [ list ]

    set sMqlVersion [mql version]
    set nMxVer [ join [lrange [split $sMqlVersion \".\"] 0 1] \".\"]
    array set aAdminTemp {}

# Check version, if < 9.5 stop.


    file mkdir $Out_Directory
    
    set sSchemaPolicy [ file join $Out_Directory Policy ]
    file mkdir $sSchemaPolicy
    set sSchemaPolicyUser [ file join $sSchemaPolicy user ]
    file mkdir $sSchemaPolicyUser
    set sSchemaRule [ file join $Out_Directory Rule ]
    file mkdir $sSchemaRule
    set Image_Directory [ file join $Out_Directory Images ]
    file mkdir $Image_Directory
    set sSchemaProgram [ file join $Out_Directory Programs ]
    file mkdir $sSchemaProgram
    
    set sDumpSchemaDir [ file join $Out_Directory Spinner ]
    set aDirs(sDumpSchemaDir) $sDumpSchemaDir
    file mkdir $sDumpSchemaDir
    set aDirs(sDirSpinnerLogs) [file join $sDumpSchemaDir Logs]
    file mkdir $aDirs(sDirSpinnerLogs)
# New name
    set sSpinner $sDumpSchemaDir
    set sDirSpinnerExport [ file join $sSpinner Export ]
    file mkdir $sDirSpinnerExport
    
    #Add the dirs required for the exports by type.
    set aDirs(sDirSpinnerExportperson) [ file join $sDirSpinnerExport person ]
    file mkdir $aDirs(sDirSpinnerExportperson)
    set aDirs(sDirSpinnerExportwizard) [ file join $sDirSpinnerExport wizard ]
    file mkdir $aDirs(sDirSpinnerExportwizard)
    set aDirs(sDirSpinnerExportprocess) [ file join $sDirSpinnerExport process ]
    file mkdir $aDirs(sDirSpinnerExportprocess)
    set aDirs(sDirSpinnerExportresource) [ file join $sDirSpinnerExport resource ]
    file mkdir $aDirs(sDirSpinnerExportresource)
    set aDirs(sDirSpinnerExportform) [ file join $sDirSpinnerExport form ]
    file mkdir $aDirs(sDirSpinnerExportform)
    set aDirs(sDirSpinnerExportreport) [ file join $sDirSpinnerExport report ]
    file mkdir $aDirs(sDirSpinnerExportreport)
    set aDirs(sDirSpinnerExportinquiry) [ file join $sDirSpinnerExport inquiry ]
    file mkdir $aDirs(sDirSpinnerExportinquiry)
    set aDirs(sDirSpinnerExportmenu) [ file join $sDirSpinnerExport menu ]
    file mkdir $aDirs(sDirSpinnerExportmenu)
    set aDirs(sDirSpinnerExportrule) [ file join $sDirSpinnerExport rule ]
    file mkdir $aDirs(sDirSpinnerExportrule)
    set aDirs(sDirSpinnerExportindex) [ file join $sDirSpinnerExport index ]
    file mkdir $aDirs(sDirSpinnerExportindex)

    set sDumpSchemaDirSystem [ file join $sDumpSchemaDir System ]
    file mkdir $sDumpSchemaDirSystem
    set sDumpSchemaDirBusiness [ file join $sDumpSchemaDir Business ]
    set aDirs(sDumpSchemaDirBusiness) $sDumpSchemaDirBusiness
    file mkdir $sDumpSchemaDirBusiness
    set sDumpSchemaDirBusinessSource [ file join $sDumpSchemaDirBusiness SourceFiles ]
    file mkdir $sDumpSchemaDirBusinessSource
    set sDumpSchemaDirBusinessPage [ file join $sDumpSchemaDirBusiness PageFiles ]
    file mkdir $sDumpSchemaDirBusinessPage
    set sDumpSchemaDirSystem [ file join $sDumpSchemaDir System ]
    set aDirs(sDumpSchemaDirSystem) $sDumpSchemaDirSystem
    file mkdir $sDumpSchemaDirSystem
    set sDumpSchemaDirSystemMap [ file join $sDumpSchemaDirSystem Map ]
    file mkdir $sDumpSchemaDirSystemMap
    set sDumpSchemaDirObjects [ file join $sDumpSchemaDir Objects ]
    file mkdir $sDumpSchemaDirObjects
    set sPolicySpinnerDir [ file join $sDumpSchemaDirBusiness Policy ]
    file mkdir $sPolicySpinnerDir
    set sRuleSpinnerDir [ file join $sDumpSchemaDirBusiness Rule ]
    file mkdir $sRuleSpinnerDir
    set aDirs(sDumpSchemaDirRelationships) [ file join $sDumpSchemaDir Relationships ]
    file mkdir $aDirs(sDumpSchemaDirRelationships)

    # Create Spinner files, assume no files are in the db.
    set sExists FALSE
    if {$bDumpSpinner} {
#        set lFileName [list emxSpinnerScanner.tcl emxSpinnerAgent.tcl \\
#            emxSpinnerAccess.tcl emxSpinnerCompare.tcl emxSpinnerSystem.tcl \\
#            emxSpinnerPerson.tcl emxSpinnerBusObjects.tcl emxSpinnerBusRels.tcl \\
#            emxRegUnRegSchema.tcl]
# Commented out to allow only the one file to be come out, the rest are exec.
            
        set lFileName [list emxSpinner.tcl]
        foreach sFileName $lFileName {
            set sCmd \"mql list program $sFileName\"
            if {[catch {eval $sCmd} sMsg] == 0} {
                if {$sMsg == \"\"} {
                    set sExists FALSE
                } else {
                    set sExists TRUE
                }
            } else {
                puts \"An error occurred with $sCmd, Error is: $sMsg\"
                set sExists FALSE
            }
            if {$sExists == \"TRUE\"} {
                set sFileData [mql print program $sFileName select code dump]
                pfile_write [file join $sDumpSchemaDir $sFileName] $sFileData
            }
        }
    }


    if {$bDumpSchema} {
        if {$bStatus} {puts \"Start Create Images ...\"}
        Create_Images
    }


    # Generate main page
    set Main_Page {
        <!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 
            Frameset//EN\"\"http://www.w3.org/TR/html4/loose.dtd\">
        <HTML>
        <HEAD>
        <TITLE>Business Model Documentation</TITLE>
        </HEAD>
        <FRAMESET COLS=\"24%,*\">
          <FRAME NAME=\"Summary\" SRC=\"summary.html\">
          <FRAME NAME=\"Category\" SRC=\"general.html\">
        <NOFRAMES>
        <BODY>
        Not available
        </BODY>
        </NOFRAMES>
        </FRAMESET>
        </HTML>
    }
    if {$bDumpSchema} { pfile_write [file join $Out_Directory index.html] $Main_Page }

    # Generate summary page
    set Summary_Page \"
        <HTML>
        <HEAD>
        <TITLE>Business Model Documentation</TITLE>
        </HEAD>
        <BODY>
        <A HREF=general.html TARGET=Category><IMG SRC=Images/ematrix_logo.gif BORDER=0 WIDTH=145 HEIGHT=32></A><BR><BR><BR>
    \"

    # This is the MASTER list of all admin types to process ANYWHERE.
    # Refer to readme for more details.  Version dependant.
    
    set lAdmin [ list {association complex} {attribute complex} {command complex} \\
        {form complex} {format complex} {group complex} {inquiry simple} \\
        {location complex} {menu simple} {person complex} {policy complex} \\
        {program complex} {relationship complex} \\
        {role complex} {rule simple} {server complex} {site complex}  {store complex} \\
        {table complex} {type complex} {vault complex} {wizard complex} ]

    if {$nMxVer >= 10.5} {
        lappend lAdmin {channel complex} {portal complex} {index simple}
    }

    if {$nMxVer >= 10.6} {
        lappend lAdmin {page simple} {interface simple} {expression simple}
    }

    if {$nMxVer >= 10.7} {
        lappend lAdmin {dimension simple}
    }

    # Initialize the aAdmin array elements and make empty.
    set lAdminName [ list ]
    foreach i $lAdmin {
        set sTypeName [lindex $i 0]
        lappend lAdminName $sTypeName
        set aAdmin($sTypeName) {}
    }

    if { $aInclude(bMode) } {
        if { $bStatus } { puts \"Build Data set from include file/s ...\" }
        set lFile [ glob -nocomplain [ file join $aInclude(sDir) $aInclude(sMask) ] ]
        foreach sFile $lFile {
            unset aAdminTemp
            array set aAdminTemp {}
            pProcessFile $lAdmin $sFile $aInclude(sDelimit)
            pMergeArray or $lAdminName
        }
    } else {
        if { $bStatus } { puts \"Build Data set from database ...\" }
        foreach lAdminType $lAdmin {
            set sAdminType [ lindex $lAdminType 0 ]
            if { $sAdminType == \"table\" } {
                set lValues [lsort -dictionary [split [mql list $sAdminType \"$AOName\" system] \\n]]
            } else {
                set lValues [lsort -dictionary [split [mql list $sAdminType  \"$AOName\"] \\n]]
            }
            set aAdmin($sAdminType) $lValues
        }
    }


    if { $aExclude(bMode) } {
        if { $bStatus } { puts \"Remove Data defined in exclude file/s ...\" }
        set lFile [ glob -nocomplain [ file join $aExclude(sDir) $aExclude(sMask) ] ]
        foreach sFile $lFile {
            unset aAdminTemp
            array set aAdminTemp {}
            pProcessFile $lAdmin $sFile $aExclude(sDelimit)
            pMergeArray xor $lAdminName
        }
    }


    foreach i $lAdminName {
        puts \"Process admin type $i ...\"
        set aAdmin($i) [ lsort -dictionary $aAdmin($i) ]

        if {$bSuppressAdmReporting} {
            puts \"Supress adm admin data ...\"
            set aAdmin($i) [pRemoveElement $aAdmin($i)]
        }
    
        if {$bSuppressHidden} {
            puts \"Supress Hidden admin data ...\"
            foreach sValue $aAdmin($i) {
                set bHidden \"FALSE\"
                if {$i != \"table\"} {
                    set bHidden [mql print \"$i\" $sValue select hidden dump]
                } else {
                    set bHidden [mql print \"$i\" $sValue system select hidden dump]
                }
                if {$bHidden == \"TRUE\"} {
                    set nIndex [ lsearch $aAdmin($i) $sValue ]
                    set aAdmin($i) [ lreplace $aAdmin($i) $nIndex $nIndex ]
                }
            }
        }
    } ;# End foreach

    set Category_Order [ list ]
    foreach cat $lAdmin {
        lappend Category_Order [ lindex $cat 0 ]
    }
    # Temp only until the BO are fixed.
    lappend Category_Order \"Trigger Manager Objects\"
    set Category_Order [ lsort -dictionary $Category_Order ]


    # build a global list of programs for use by the trigger processing routine
#    set glsPrograms [split [mql list program *] \\n]
    set glsPrograms $aAdmin(program)
    
    # glsTriggerManagerObjects is set when the trigger manager objects
    Generate_TriggerObjects
#    puts [array get Statistic]

    # Generate Extended data before creating users, will allow for null data.
    Generate_ExtendedPolicy


    foreach category $Category_Order {
        if { $bStatus } { puts \"Build Menu $category ...\" }
        Generate_Summary_Menu $category
        append Summary_Page \"<A HREF=\\\"[Replace_Space $category]_menu.html\\\" TARGET=\\\"Summary\\\"><IMG SRC=Images/plus.gif BORDER=0 WIDTH=9 HEIGHT=9> $category</A><BR>\"
    }

    # Generate the business system data.
    foreach lAdminType $lAdmin {
        set sAdminType [ lindex $lAdminType 0 ]
        set sGenerate [ lindex $lAdminType 1 ]
        if { [llength $aAdmin($sAdminType)] == 0 } {
            if { $bStatus } { puts \"No Data for $sAdminType ...\" }
        } else {
            if { $bStatus } { puts \"Start Processing $sAdminType ...\" }
            if { $sGenerate == \"complex\" } {
                set sRet [Generate_$sAdminType]
            } else {
                set sRet [Generate_Simple $sAdminType]
            }
        }
    }

    # Generate general page
    set General_Content \"
        <HTML>
        <HEAD>
        <TITLE>Business Model Documentation</TITLE>
        </HEAD>
        <BODY>\"

    append General_Content \"
        <DIV ALIGN=center><BR>
        <FONT SIZE=+1><B>$sHeaderTitle</FONT></B><BR><BR>
        <FONT SIZE=-1>Date-Time Generated<BR>(YYYY MM DD - HH MM SS)<BR>[clock format [clock seconds] -format \"%Y %m %d% - %H %M %S\"]</FONT><BR><BR>
        <TABLE BORDER=0 CELLSPACING=3>
        <TR>
        <TD ALIGN=RIGHT BGCOLOR=#F5F5F5 WIDTH=150><FONT SIZE=+1>Administration type</FONT></TD>
        <TD ALIGN=LEFT BGCOLOR=#F5F5F5><FONT SIZE=+1>Quantity</FONT></TD>
        </TR>\"

    foreach type [lsort -dictionary [array names Statistic]] {
        if { $type != \"\" } {
            append General_Content \"<TR>
                  <TD ALIGN=RIGHT BGCOLOR=#DCDCDC><B><FONT SIZE=-1>$type</B></FONT></TD>
                  <TD ALIGN=CENTER><FONT SIZE=-1>$Statistic($type)</FONT></TD>
                </TR>\"
        }
    }

    append General_Content \"
        </TABLE>
        <BR>
        <FONT SIZE=-1>Use menu on the left frame to navigate through administrative objects.
        <BR><BR><BR>Schema Dumper, Version 10.5.6 Build 05.04.21<BR><BR>
        [mql version]<BR>
        � Copyright 2005 by MatrixOne Inc.<BR>
        All rights reserved.<BR><BR>
        <A HREF=http://www.matrixone.com><IMG SRC=Images/matrixone_logo.gif BORDER=0><BR>
        <A HREF=http://www.matrixone.com>www.matrixone.com</a>
        </FONT>
        </DIV>
        <BR><BR>
        </BODY>
        </HTML>\"

    if {$bDumpSchema} { pfile_write [file join $Out_Directory general.html] $General_Content }


    # Summary page
    append Summary_Page \"
        </BODY>
        </HTML>
    \"
    if {$bDumpSchema} { pfile_write [file join $Out_Directory summary.html] $Summary_Page }
    
    puts \"\\nFinish Admin, Move onto Spinner.\\n\"
    
    # Settings to dump selected Types, format is a list of lists, the Type, the Vaults to search and the limit to set.
    # Temp until fully incorporated.
    set lSpinnerAdminTypes [ list \\
        {\"eService Trigger Program Parameters\" \"eService Administration\" 1000} \\
        {\"eService Number Generator\" \"*\" 1000} \\
        {\"eService Object Generator\" \"*\" 1000} \\
    ]
    
    
    if { $bDumpSpinner } {
        pSpinnerDumper
        foreach lType $lSpinnerAdminTypes {
            pSpinnerObject $lType
        }
        set thelist [ list \\
           \"eService Object Generator,eService Number Generator\" \\
           \"eService Object Generator,eService Additional Object\" \\
        ]
        pGet_BOAdminRel $thelist
    }
    return 0
}


################################################################################
# Create_Image_File
#   Create_Image_File
#
#   Parameters :
#       path
#       binary_data
#   Return     : none
#
proc Create_Image_File { path binary_data } {

    set Image_File [open $path w+]
    fconfigure $Image_File -translation binary
    foreach data $binary_data {
        if { $data == \"00\" } {
          set data_f \\000
        } elseif { $data == \"0A\" } {
          set data_f \\012
        } else {
          scan $data %x data_i
          set data_f [format %c $data_i]
        }

    puts -nonewline $Image_File $data_f
    }
    close $Image_File

    return
}

################################################################################
# Create_Images
#   Create Images
#
#   Parameters : none
#   Return     : none
#
proc Create_Images {} {
    upvar Image_Directory Image_Directory

    set ematrix_logo {ematrix_logo.gif {47 49 46 38 39 61 91 00 20 00 D5 00 00 C5 00 40 C9 10 4C CC 20 58 D0 30 64 D4 40 70 D7 50 7C DB 60 88 DE 70 94 E2 7F 9F E6 8F AB E9 9F B7 ED AF C3 F0 BF CF F4 CF DB F8 DF E7 FB EF F3 FF FF FF EF EF EF DF DF DF CF CF CF BF BF BF AF AF AF 9F 9F 9F 8F 8F 8F 7F 7F 7F 70 70 70 60 60 60 50 50 50 40 40 40 30 30 30 20 20 20 10 10 10 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 2C 00 00 00 00 91 00 20 00 00 06 FF 40 88 70 48 2C 1A 8F C8 A4 72 C9 6C 3A 9F D0 A8 74 4A AD 5A AF D8 AC 76 CB ED 7A BF E0 B0 78 4C 2E 9B 97 18 90 7A CD 06 5D 8C 9A B6 9C 72 6E CA 41 98 7A 33 7D 5F 6F 8C 1F 7D 6B 74 57 1C 72 1C 54 77 79 7A 68 82 6B 45 13 8E 6A 84 56 86 6D 88 53 8A 8C 8D 92 15 44 7C 8E 94 55 96 6C 98 52 9A 9B 49 A0 82 1A 44 1D 92 20 A2 54 A4 6B A6 51 14 B8 B9 14 12 65 0D 09 08 05 04 07 08 0A 0D 47 AB 7D 1E 43 12 B0 B1 46 14 17 18 D2 D3 18 15 BC 43 B9 AF 6D 1D B9 12 13 BA B8 D7 16 D4 10 E0 E1 E6 E1 43 DF E6 11 4E 0A 02 00 F1 F2 F2 02 08 0F 9F CD 13 42 16 CD 94 12 1A 81 1C 79 B0 20 A4 19 1E 5A 6A 30 50 F0 D0 06 82 A2 0C 77 3A 08 89 24 C7 43 BB 25 0D 06 CC DB 38 4F 80 31 21 C8 FA BC 81 B0 A1 9F 90 0A 01 9B B5 32 88 01 21 88 92 72 1C CA C9 E3 12 4F 04 6D 6C 3E E8 C3 18 80 A3 CF FF 78 01 3E 86 04 C1 90 8D 44 08 29 D5 14 6D 43 27 42 D2 7C 2C 6B DE 91 D9 26 4F 84 A5 6C 60 B6 21 C8 44 E3 C6 00 06 10 1C 80 B7 91 00 C8 3B 10 DB 44 A8 20 27 2D 53 08 17 E4 7C B8 80 6B E8 05 0E 78 9F 82 F8 80 97 83 05 A9 31 51 4D D0 8B B6 89 02 8E 03 EE 09 79 E0 75 1E 03 08 43 29 3C B5 E0 56 CD 86 C8 10 FE F6 C5 CB 55 88 CB 45 10 5C DA 02 0C 02 2F 43 AA 6C 40 F3 93 64 4B 49 63 79 08 18 C8 96 8D 80 A3 01 C8 77 28 C4 C9 8A 15 C4 B8 DC 4A 24 50 A8 BC 06 B4 68 22 35 E7 12 E1 85 4A 08 F1 36 16 9D FC 9C 4E 0F F7 1C B6 39 E5 44 C0 AC EE 82 06 0E 84 53 0F 39 3E FE CE C8 22 CD 3D F7 D1 F9 84 BA 7B EB 6F C3 AB 41 C4 BD 42 6F 49 C6 0F 21 97 8B 24 7D B9 3E AD 2D E1 1E 75 F0 B1 41 C7 6E 22 15 38 08 04 CF B5 A1 57 7E 97 EC 17 E1 11 E9 39 25 48 67 4C F8 94 C0 6C 1C 76 F8 FF 18 66 D8 F5 C1 4B 64 CC DC 71 19 05 11 7C 56 DE 84 EA B1 88 DE 4C AE 48 B2 13 13 05 70 54 80 13 DC 85 77 54 64 76 C5 58 D5 8A 39 51 42 9E 11 CD 21 28 C8 07 D7 2C C1 80 4F 05 38 00 C1 03 0A F4 B4 11 02 0A 4E 22 84 91 6C 8C C4 A3 79 43 C4 05 63 8B 7D B4 A4 1F 85 5F AE 06 4B 07 17 2D 71 C0 80 1B 25 56 A5 33 10 84 D8 C6 35 91 99 B9 0D 07 F7 25 04 A4 22 43 BE F8 23 45 DB 34 D8 4A 13 06 B0 19 8F 9B 6F 52 A2 D7 51 89 5A 68 D0 1A 83 66 E6 88 98 2E 12 A1 88 A3 6D E8 53 13 68 4B 2C 40 D6 74 01 D8 33 04 77 10 60 E9 C6 A8 C0 0D 76 24 4E 6B 28 33 84 A9 C5 F5 69 E9 4C AC 16 27 84 04 84 61 D8 A9 01 AF 01 20 40 01 0A 28 36 84 66 9B 71 30 23 05 C5 72 90 24 B1 9B ED B4 5D AD 1D 64 20 41 05 C9 72 20 8A 6E E0 A9 D1 01 67 19 24 9B 01 12 D5 6E 50 6D A4 71 86 9B CA B9 E8 A6 AB 0F EE BA EC B6 EB EE BB F0 C6 2B EF BC 57 04 01 00 3B}}
    set plus {plus.gif {47 49 46 38 39 61 09 00 09 00 F7 00 00 00 00 00 84 84 84 FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF 2C 00 00 00 00 09 00 09 00 00 08 26 00 03 08 1C 48 50 80 C1 83 02 04 1E 04 70 50 A1 41 86 06 15 02 98 38 31 61 80 85 0D 2F 3E CC 88 30 23 41 82 01 01 00 3B}}
    set moins {moins.gif {47 49 46 38 39 61 09 00 09 00 F7 00 00 00 00 00 84 84 84 FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF 2C 00 00 00 00 09 00 09 00 00 08 22 00 03 08 1C 48 50 80 C1 83 02 04 22 3C A8 70 61 C2 00 02 00 48 94 F8 D0 61 45 87 0D 17 12 DC 18 20 20 00 3B}}
    set matrix_type {matrix_type.gif {47 49 46 38 39 61 10 00 10 00 F7 00 00 00 00 00 7B 7B 7B BD BD BD FF FF 00 FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF 2C 00 00 00 00 10 00 10 00 00 08 67 00 09 08 1C 48 B0 A0 40 00 08 0D 1A 04 30 80 C0 00 84 10 21 12 04 E0 B0 62 C3 8B 14 07 32 B4 C8 31 E3 41 8B 01 42 8A 14 49 71 63 C3 00 0D 2B 3A 14 50 12 A4 42 96 04 4C 12 08 A0 32 E5 C3 98 2A 69 0E 0C 40 11 66 44 00 3A 1B 32 04 00 B3 20 4A 8D 0E 13 12 D4 79 50 A8 C7 9D 02 06 B0 94 A8 30 26 D5 AA 58 09 06 04 00 3B}}
    set matrixone_logo {matrixone_logo.gif {47 49 46 38 39 61 9E 00 3A 00 E6 00 00 FE F8 F9 FD F3 F5 FE F9 FA F8 DA E1 F9 DF E5 FB E9 ED FC EF F2 CC 00 33 CC 01 34 CC 02 35 CD 05 37 CD 06 38 CD 07 39 CE 08 39 CE 09 3A CE 0C 3D CF 10 40 D0 12 41 D0 15 44 D0 16 45 D1 17 45 D1 18 46 D2 1C 49 D2 1D 4A D2 20 4D D3 25 51 D4 26 51 D4 29 54 D6 30 59 D7 39 61 D8 3A 61 D9 40 66 DA 48 6D DB 4B 6F DC 50 73 DD 56 78 DE 58 79 DF 5E 7E DF 60 80 E0 65 84 E1 69 87 E1 6A 88 E2 6C 89 E2 70 8D E3 72 8E E5 7B 95 E5 7C 96 E5 7F 99 E6 83 9C E6 84 9D E8 8D A4 E9 8F A5 E9 93 A9 EA 95 AA EA 96 AB EB 9A AE EC 9F B2 EC A1 B4 ED A7 B9 EE A9 BA EF AF BF F0 B4 C3 F1 B7 C5 F2 BF CC F4 C6 D1 F7 D6 DE FB EA EE FE FA FB F3 C5 D1 F5 CF D9 F7 D9 E1 F9 E2 E8 F9 E3 E9 FA E7 EC FA E8 ED FB ED F1 FD F6 F8 FD F7 F9 FE FC FD FF FD FD FF FE FE FF FF FF EF EF EF DF DF DF CF CF CF BF BF BF AF AF AF 9F 9F 9F 8F 8F 8F 7F 7F 7F 70 70 70 60 60 60 50 50 50 40 40 40 30 30 30 20 20 20 10 10 10 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 2C 00 00 00 00 9E 00 3A 00 00 07 FF 80 51 82 83 84 85 86 87 88 89 8A 8B 8C 8D 8E 8F 90 91 92 93 94 95 96 97 98 99 9A 9B 9C 9D 9E 9F A0 A1 A2 A3 A4 A5 82 06 3C 2F 1F 18 07 AD AE AF 07 18 1F 26 2F 3C 45 A6 B8 B9 91 3C 22 B0 BE BF B0 1F 2B 38 04 BA C6 C7 51 3F AC C0 CC CD B1 26 38 06 C8 D3 A1 2B CD 10 1F 2F 33 3F 3F B7 A7 DC 3F 33 2F 26 1F 10 BE 1C 33 C5 D4 EB 98 D6 BF 18 2B DE 91 06 3F 2F 22 CB AD E8 EA EC FC 8F 3F EF 38 36 11 C0 61 02 9F 88 80 FD 12 2A EA 05 6B 45 28 02 33 38 B4 82 B0 62 9F C2 8B 51 7C CD 28 65 00 C7 87 56 26 7E 60 54 58 04 96 08 5D 10 59 7D 10 39 92 DD BF 57 16 73 FD 30 71 60 65 CB 75 AF 4C AC 23 F0 02 1B CB 9B C6 24 B6 E2 C1 AF A3 AC 98 40 49 CD 70 25 2D 21 0E 0C 26 9A 26 25 65 C0 DC 81 91 38 D0 4D 2D F5 A2 D5 4D 55 3F B7 7E 32 C0 0A 69 42 03 2F 56 48 15 DB E9 DF 46 A0 04 FF 56 84 D5 94 A5 AE DD BA 57 0A 61 B9 7B 57 D7 0A 0E 96 3A 8A F8 18 2B 9B 3C 4D E1 D6 62 0A C3 B8 71 63 29 83 A6 38 9E 2C E9 4A 97 CB 97 A9 44 FA 40 74 52 4F 66 1F CC 06 E6 34 D9 71 5E 41 58 4A 37 96 94 65 72 95 79 22 14 33 32 20 F4 5A E7 91 AA 19 6F 19 C4 25 77 18 D6 AE 25 F1 8C 54 DB 19 84 C3 0A 7D 83 19 E4 FB 37 21 29 55 A2 4B 87 4C A8 B5 E3 D7 89 A8 44 D7 4C A8 88 EC 44 5D 61 61 78 61 EF 5C 22 70 73 09 A1 4F 7F A9 B9 66 2B CD 07 5D F9 92 DB 8B 95 28 5D 9A E7 77 3C C5 4B E3 CB 93 C1 E7 18 18 53 E0 37 19 16 56 B9 A2 D3 20 38 F8 92 CA 2B 1F CC 90 60 2C B7 45 61 80 09 13 1E 00 81 09 A2 49 D2 5C 16 51 68 11 5F 14 5B 34 C7 98 15 FB E5 96 22 63 FE FD B7 E2 6F D6 FD 97 9A 63 5C BC E4 0A 04 8A D1 94 53 78 CE 74 56 44 86 AF 40 C0 9E 87 8E B5 C8 62 14 F4 31 06 46 FF 69 51 54 31 D9 17 5A F4 E6 18 80 BE BD 38 19 95 AB 45 21 65 7D 52 2C 05 A1 21 3C 04 C3 63 33 1F 58 98 61 39 41 76 F8 C8 95 5B 86 21 A0 6E 4C 5A 86 19 17 83 94 E8 98 20 31 32 86 5D 9E 8D 81 D1 C5 17 58 32 26 88 14 49 96 06 86 66 63 1E F0 82 21 36 B6 92 0D 2C 14 E9 F8 4A 14 92 1E C0 81 34 17 E6 D4 DD 24 57 5E 51 A4 63 6F 66 39 08 74 55 64 61 E7 9D 51 F0 B9 67 69 A7 09 F2 E2 20 54 2C 59 DA 7D 51 24 EA 50 21 8D D6 94 A8 37 0C B9 12 C5 84 B4 90 57 29 06 DD 21 04 C9 95 52 E4 B6 1C 93 51 4C B1 45 A1 B9 E1 19 5C AA 93 ED 46 C8 AB 83 CC E8 98 16 0C C2 02 58 21 5E BA F2 E8 A4 82 24 9A 91 33 BE 12 82 83 B1 8E 5C 69 60 69 74 C6 69 62 96 AA 4A 0B 6A 21 D8 0A 62 64 63 5F 50 47 80 2F 73 E1 D3 0A 79 B0 0C 62 2E BA AE CC F5 02 BB 8C B8 AB AD 69 51 30 29 6B 63 5B 5C 31 05 FF 9F F6 36 46 6B BD D7 52 26 88 88 AA 75 31 08 61 37 B2 44 40 AF AE F0 54 70 B9 05 C3 F2 C2 7A E8 C9 F6 01 C3 8A B8 2B 59 69 90 95 46 C5 64 5E 0C 02 AD 73 7C 7E 51 D7 A9 7A E2 EB B1 A7 BE 71 9B CC 2F 10 14 E7 8A 43 E6 B2 3C 29 CA 97 0A 92 0A 79 0B 1F 42 C0 71 ED 4E A9 EF 64 74 46 4C 59 69 5D 64 F1 B3 73 48 93 3D ED 20 AF C6 3A E0 BE 61 9C D6 20 C2 55 47 5D 6B C1 3F 06 B9 0A 2C 6F 19 D2 93 9A CC 79 1D C5 C3 71 0B C2 64 9B 23 4E 31 F1 94 6B BB 3A 19 A1 01 BA ED 18 77 38 00 69 52 53 76 47 5D 79 33 B7 1E 52 D5 B7 8B B8 
DB EC E3 86 53 26 05 D1 8C 7D 81 FA 69 55 9C FD 22 76 6C 5F 39 99 D2 84 83 E1 2F 86 BF D8 64 F0 CA 77 93 1B 05 01 95 8A 3B E4 20 34 2D 5A 0A 74 75 59 C1 9D 22 53 48 57 C5 F2 9F CC 15 0E D6 3C 00 0E C9 0F 38 68 F3 C3 77 60 B6 62 3D 5B 94 A0 45 73 BE 3F 25 D5 04 7E 28 3F CC 3C 52 CA E7 87 F2 02 07 E3 4F 63 63 E7 ED 7B 02 3C 06 F1 1B 33 77 2C F5 8B 92 3E 04 2F E0 1E 2E 48 76 95 FE F9 EF 23 21 41 C6 BF 7C 67 40 F4 7D 04 03 E9 D0 05 01 0B D8 C0 51 FC 80 21 07 11 20 27 12 05 81 0A 9A 22 2E 56 11 41 04 C7 12 BC 03 2C C8 83 A6 F0 88 2B E0 C1 03 0D 46 E2 29 BF F8 1E 0A 39 01 91 E2 40 65 1B 2E 44 44 11 56 20 B0 57 F4 6D 86 28 89 88 2F B0 41 0B 1C 80 83 10 04 E0 86 38 D0 C4 8C 1F 02 F1 18 1D 29 08 C2 A6 98 8F E1 3D D1 18 03 F9 0B 15 81 21 02 2B 5E 71 1D 45 48 C5 60 7A 78 8E 6C 54 E8 8B 68 4C A3 1A D7 C8 C6 36 CE 30 10 00 3B}}
    set image_changename {changename.gif {47 49 46 38 39 61 10 00 50 00 f7 00 00 00 00 00 00 00 55 00 00 aa 00 00 ff 00 24 00 00 24 55 00 24 aa 00 24 ff 00 49 00 00 49 55 00 49 aa 00 49 ff 00 6d 00 00 6d 55 00 6d aa 00 6d ff 00 92 00 00 92 55 00 92 aa 00 92 ff 00 b6 00 00 b6 55 00 b6 aa 00 b6 ff 00 db 00 00 db 55 00 db aa 00 db ff 00 ff 00 00 ff 55 00 ff aa 00 ff ff 24 00 00 24 00 55 24 00 aa 24 00 ff 24 24 00 24 24 55 24 24 aa 24 24 ff 24 49 00 24 49 55 24 49 aa 24 49 ff 24 6d 00 24 6d 55 24 6d aa 24 6d ff 24 92 00 24 92 55 24 92 aa 24 92 ff 24 b6 00 24 b6 55 24 b6 aa 24 b6 ff 24 db 00 24 db 55 24 db aa 24 db ff 24 ff 00 24 ff 55 24 ff aa 24 ff ff 49 00 00 49 00 55 49 00 aa 49 00 ff 49 24 00 49 24 55 49 24 aa 49 24 ff 49 49 00 49 49 55 49 49 aa 49 49 ff 49 6d 00 49 6d 55 49 6d aa 49 6d ff 49 92 00 49 92 55 49 92 aa 49 92 ff 49 b6 00 49 b6 55 49 b6 aa 49 b6 ff 49 db 00 49 db 55 49 db aa 49 db ff 49 ff 00 49 ff 55 49 ff aa 49 ff ff 6d 00 00 6d 00 55 6d 00 aa 6d 00 ff 6d 24 00 6d 24 55 6d 24 aa 6d 24 ff 6d 49 00 6d 49 55 6d 49 aa 6d 49 ff 6d 6d 00 6d 6d 55 6d 6d aa 6d 6d ff 6d 92 00 6d 92 55 6d 92 aa 6d 92 ff 6d b6 00 6d b6 55 6d b6 aa 6d b6 ff 6d db 00 6d db 55 6d db aa 6d db ff 6d ff 00 6d ff 55 6d ff aa 6d ff ff 92 00 00 92 00 55 92 00 aa 92 00 ff 92 24 00 92 24 55 92 24 aa 92 24 ff 92 49 00 92 49 55 92 49 aa 92 49 ff 92 6d 00 92 6d 55 92 6d aa 92 6d ff 92 92 00 92 92 55 92 92 aa 92 92 ff 92 b6 00 92 b6 55 92 b6 aa 92 b6 ff 92 db 00 92 db 55 92 db aa 92 db ff 92 ff 00 92 ff 55 92 ff aa 92 ff ff b6 00 00 b6 00 55 b6 00 aa b6 00 ff b6 24 00 b6 24 55 b6 24 aa b6 24 ff b6 49 00 b6 49 55 b6 49 aa b6 49 ff b6 6d 00 b6 6d 55 b6 6d aa b6 6d ff b6 92 00 b6 92 55 b6 92 aa b6 92 ff b6 b6 00 b6 b6 55 b6 b6 aa b6 b6 ff b6 db 00 b6 db 55 b6 db aa b6 db ff b6 ff 00 b6 ff 55 b6 ff aa b6 ff ff db 00 00 db 00 55 db 00 aa db 00 ff db 24 00 db 24 55 db 24 aa db 24 ff db 49 00 db 49 55 db 49 aa db 49 ff db 6d 00 db 6d 55 db 6d aa db 6d ff db 92 00 db 92 55 db 92 aa db 92 ff db b6 00 db b6 55 db b6 aa db b6 ff db db 00 db db 55 db db aa db db ff db ff 00 db ff 55 db ff aa db ff ff ff 00 00 ff 00 55 ff 00 aa ff 00 ff ff 24 00 ff 24 55 ff 24 aa ff 24 ff ff 49 00 ff 49 55 ff 49 aa ff 49 ff ff 6d 00 ff 6d 55 ff 6d aa ff 6d ff ff 92 00 ff 92 55 ff 92 aa ff 92 ff ff b6 00 ff b6 55 ff b6 aa ff b6 ff ff db 00 ff db 55 ff db aa ff db ff ff ff 00 ff ff 55 ff ff aa ff ff ff 21 f9 04 01 00 00 ff 00 2c 00 00 00 00 10 00 50 00 40 08 c0 00 ff 09 1c 48 b0 a0 c1 83 08 ff 01 58 c8 30 21 c1 86 07 21 0a 04 e0 50 a1 c4 8a 13 1d 32 bc 68 90 22 46 8f 0f 35 2e cc a8 11 e3 c4 8d 20 0b a6 b4 58 71 a4 c2 92 2f 3d ae 3c b9 d1 24 47 93 38 73 b6 44 29 b2 66 42 94 33 43 0e 0c 3a 34 e6 4f 9d 27 5b 76 2c 49 d1 25 42 88 37 69 02 8d c8 f3 68 d1 a3 4d 77 fa 54 09 d4 a9 ca a5 4f ab 22 1d 4b 95 e4 d3 98 44 87 46 b5 1a 76 2b 55 b7 60 6d 8a fd d8 73 6d 46 b8 64 bb a6 55 bb d7 2e df b9 64 f9 9a 7d eb 77 2f d7 91 78 5f 1a 55 dc 11 a4 d7 87 80 bf e2 9c 3a b9 ee e3 af 89 cf fe 8c 6c b1 6b c4 cf 65 af 82 16 da 18 72 dd c0 64 03 02 00 3b}}
    set image_changeowner {changeowner.gif {47 49 46 38 39 61 10 00 57 00 f7 00 00 05 05 05 fb fb fb 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 00 00 00 21 f9 04 01 00 00 ff 00 2c 00 00 00 00 10 00 57 00 40 08 cc 00 ff 09 1c 48 b0 a0 41 00 04 11 1a 1c 08 a0 a1 c3 85 0c 05 3e 84 48 71 a1 c3 89 14 15 56 64 78 51 a3 c5 8e 1f 3b 36 84 38 92 63 45 8f 1b 11 aa 44 59 50 e4 46 89 2c 23 b6 3c 59 32 a6 4c 95 12 43 62 7c 69 b3 64 ce 97 40 83 72 bc 98 52 a1 cd a1 47 7f 02 4d da d2 27 4d a6 ff 5c 92 3c 28 b4 28 d1 8c 0f af 1e d4 e8 34 61 55 af 19 a3 ee dc aa 15 ec 4c 8b 54 b1 76 fd ca b6 6d 54 b3 3a d7 ba 9d 98 54 ea d2 a7 63 9b 96 4d ab 34 a4 d0 bd 5b 97 82 0c 1b 14 70 42 8f 72 df 9e 0d 6c 52 2d 54 b1 7d a9 ae b4 ca 94 6e 62 a3 8a 63 8a cc cb 37 6e dd c1 53 65 92 04 8d 16 a7 e0 cf 86 45 3b 26 3d b7 33 dc c8 87 53 bb ad 18 10 00 3b}}
    set image_changepolicy {changepolicy.gif {47 49 46 38 39 61 10 00 52 00 f7 00 00 05 05 05 fb fb fb 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 00 00 00 21 f9 04 01 00 00 ff 00 2c 00 00 00 00 10 00 52 00 40 08 c3 00 ff 09 1c 48 b0 a0 41 00 08 0b 02 20 98 10 a1 c3 85 06 19 3a 8c 28 f0 21 44 8a 03 17 6a bc 18 d1 e2 c3 8e 0c 31 fe f3 48 91 63 45 91 28 15 26 4c c9 d1 64 45 8f 2b 4b 5a 2c 79 50 e4 c4 91 31 55 7e c4 a8 71 a4 4c 98 3c 67 a6 1c 2a 31 27 d1 9f 2e 15 86 ac c9 94 66 c6 a3 41 49 da 84 98 b4 68 d5 a7 3e a9 b2 9c ba 13 a9 d1 9f 36 a1 0e 75 79 55 2c d4 b2 32 51 0a ad 9a b4 ed c5 b2 52 c7 76 dc d8 75 eb 41 98 68 8f c6 05 89 35 2a dc af 4d b5 ce dd 6b b6 e8 49 bf 80 fb b2 9c 58 17 6b 4f 9f 73 33 b2 15 ea 74 2c 65 bb 5e e1 e2 4c cc 37 f3 60 c2 87 95 46 56 2c 7a e9 5d 89 5c f3 16 a6 18 10 00 3b}}
    set image_changetype {changetype.gif {47 49 46 38 39 61 10 00 4d 00 f7 00 00 05 05 05 fb fb fb 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 00 00 00 21 f9 04 01 00 00 ff 00 2c 00 00 00 00 10 00 4d 00 40 08 bb 00 ff 09 1c 48 b0 a0 41 00 08 13 1a 24 08 60 61 43 86 0f 17 4a 9c 78 50 61 c2 88 0c 29 16 6c 78 d1 a1 c7 89 1d 35 8a 84 18 52 63 49 92 17 31 56 3c e9 30 22 c2 91 2a 37 a6 94 18 33 e6 c8 9b 20 5f fe b3 89 13 e5 cc 95 30 75 0e 54 59 93 66 cf 9d 3a 79 0a 54 7a 70 e9 4e a7 2b 15 e6 64 29 93 2a c8 96 29 85 ca cc 48 13 a3 d6 a3 60 c3 22 85 6a 94 23 53 a4 5f b1 8a f4 4a d6 a7 d5 b3 2d 4d 86 e4 69 93 28 ce ac 69 db ea 1d 0a 77 eb d3 ab 66 e5 e6 25 b9 74 f0 43 8e 7b d1 66 5d 4b 71 f1 54 a9 46 87 36 fe 59 f6 ef da c1 85 ad 4a 16 ec 58 ec 5e ba 4d bb 6a f6 3c 31 20 00 3b}}
    set image_changevault {changevault.gif {47 49 46 38 39 61 10 00 52 00 f7 00 00 00 00 00 00 00 55 00 00 aa 00 00 ff 00 24 00 00 24 55 00 24 aa 00 24 ff 00 49 00 00 49 55 00 49 aa 00 49 ff 00 6d 00 00 6d 55 00 6d aa 00 6d ff 00 92 00 00 92 55 00 92 aa 00 92 ff 00 b6 00 00 b6 55 00 b6 aa 00 b6 ff 00 db 00 00 db 55 00 db aa 00 db ff 00 ff 00 00 ff 55 00 ff aa 00 ff ff 24 00 00 24 00 55 24 00 aa 24 00 ff 24 24 00 24 24 55 24 24 aa 24 24 ff 24 49 00 24 49 55 24 49 aa 24 49 ff 24 6d 00 24 6d 55 24 6d aa 24 6d ff 24 92 00 24 92 55 24 92 aa 24 92 ff 24 b6 00 24 b6 55 24 b6 aa 24 b6 ff 24 db 00 24 db 55 24 db aa 24 db ff 24 ff 00 24 ff 55 24 ff aa 24 ff ff 49 00 00 49 00 55 49 00 aa 49 00 ff 49 24 00 49 24 55 49 24 aa 49 24 ff 49 49 00 49 49 55 49 49 aa 49 49 ff 49 6d 00 49 6d 55 49 6d aa 49 6d ff 49 92 00 49 92 55 49 92 aa 49 92 ff 49 b6 00 49 b6 55 49 b6 aa 49 b6 ff 49 db 00 49 db 55 49 db aa 49 db ff 49 ff 00 49 ff 55 49 ff aa 49 ff ff 6d 00 00 6d 00 55 6d 00 aa 6d 00 ff 6d 24 00 6d 24 55 6d 24 aa 6d 24 ff 6d 49 00 6d 49 55 6d 49 aa 6d 49 ff 6d 6d 00 6d 6d 55 6d 6d aa 6d 6d ff 6d 92 00 6d 92 55 6d 92 aa 6d 92 ff 6d b6 00 6d b6 55 6d b6 aa 6d b6 ff 6d db 00 6d db 55 6d db aa 6d db ff 6d ff 00 6d ff 55 6d ff aa 6d ff ff 92 00 00 92 00 55 92 00 aa 92 00 ff 92 24 00 92 24 55 92 24 aa 92 24 ff 92 49 00 92 49 55 92 49 aa 92 49 ff 92 6d 00 92 6d 55 92 6d aa 92 6d ff 92 92 00 92 92 55 92 92 aa 92 92 ff 92 b6 00 92 b6 55 92 b6 aa 92 b6 ff 92 db 00 92 db 55 92 db aa 92 db ff 92 ff 00 92 ff 55 92 ff aa 92 ff ff b6 00 00 b6 00 55 b6 00 aa b6 00 ff b6 24 00 b6 24 55 b6 24 aa b6 24 ff b6 49 00 b6 49 55 b6 49 aa b6 49 ff b6 6d 00 b6 6d 55 b6 6d aa b6 6d ff b6 92 00 b6 92 55 b6 92 aa b6 92 ff b6 b6 00 b6 b6 55 b6 b6 aa b6 b6 ff b6 db 00 b6 db 55 b6 db aa b6 db ff b6 ff 00 b6 ff 55 b6 ff aa b6 ff ff db 00 00 db 00 55 db 00 aa db 00 ff db 24 00 db 24 55 db 24 aa db 24 ff db 49 00 db 49 55 db 49 aa db 49 ff db 6d 00 db 6d 55 db 6d aa db 6d ff db 92 00 db 92 55 db 92 aa db 92 ff db b6 00 db b6 55 db b6 aa db b6 ff db db 00 db db 55 db db aa db db ff db ff 00 db ff 55 db ff aa db ff ff ff 00 00 ff 00 55 ff 00 aa ff 00 ff ff 24 00 ff 24 55 ff 24 aa ff 24 ff ff 49 00 ff 49 55 ff 49 aa ff 49 ff ff 6d 00 ff 6d 55 ff 6d aa ff 6d ff ff 92 00 ff 92 55 ff 92 aa ff 92 ff ff b6 00 ff b6 55 ff b6 aa ff b6 ff ff db 00 ff db 55 ff db aa ff db ff ff ff 00 ff ff 55 ff ff aa ff ff ff 21 f9 04 01 00 00 ff 00 2c 00 00 00 00 10 00 52 00 40 08 bc 00 ff 09 1c 48 b0 20 41 00 08 13 22 34 78 50 21 00 86 03 1d 3e 84 d8 70 22 c4 87 18 2d 32 94 98 70 e3 41 8a ff 24 5e 34 a8 11 a4 c9 93 02 39 2e a4 28 d2 23 ca 90 2f 23 ae ec b8 d1 21 48 8c 30 6b 72 64 69 33 a6 4f 93 25 5d 16 0c 3a 32 26 d1 88 21 69 92 4c 7a 54 a6 52 a0 13 9b a6 7c ea 12 67 ce 9b 37 7b 5e d4 9a 55 aa d4 9f 29 97 82 1d 4b d6 a7 c6 a3 2a 8d ea 6c 89 d2 2b 57 92 6f 87 1a 8d fb d1 ea 49 aa 32 c7 ae f4 48 77 6a 59 a8 51 bb e2 fd f8 52 21 53 a2 81 03 d7 cc bb 76 af d0 bb 7d 1f c3 35 cc f2 b0 5a 9e 94 87 a6 15 2b 77 31 d2 a2 84 e1 36 14 fc f7 67 40 00 3b}}
    set image_checkin {checkin.gif {47 49 46 38 39 61 10 00 36 00 f7 00 00 00 00 00 00 00 55 00 00 aa 00 00 ff 00 24 00 00 24 55 00 24 aa 00 24 ff 00 49 00 00 49 55 00 49 aa 00 49 ff 00 6d 00 00 6d 55 00 6d aa 00 6d ff 00 92 00 00 92 55 00 92 aa 00 92 ff 00 b6 00 00 b6 55 00 b6 aa 00 b6 ff 00 db 00 00 db 55 00 db aa 00 db ff 00 ff 00 00 ff 55 00 ff aa 00 ff ff 24 00 00 24 00 55 24 00 aa 24 00 ff 24 24 00 24 24 55 24 24 aa 24 24 ff 24 49 00 24 49 55 24 49 aa 24 49 ff 24 6d 00 24 6d 55 24 6d aa 24 6d ff 24 92 00 24 92 55 24 92 aa 24 92 ff 24 b6 00 24 b6 55 24 b6 aa 24 b6 ff 24 db 00 24 db 55 24 db aa 24 db ff 24 ff 00 24 ff 55 24 ff aa 24 ff ff 49 00 00 49 00 55 49 00 aa 49 00 ff 49 24 00 49 24 55 49 24 aa 49 24 ff 49 49 00 49 49 55 49 49 aa 49 49 ff 49 6d 00 49 6d 55 49 6d aa 49 6d ff 49 92 00 49 92 55 49 92 aa 49 92 ff 49 b6 00 49 b6 55 49 b6 aa 49 b6 ff 49 db 00 49 db 55 49 db aa 49 db ff 49 ff 00 49 ff 55 49 ff aa 49 ff ff 6d 00 00 6d 00 55 6d 00 aa 6d 00 ff 6d 24 00 6d 24 55 6d 24 aa 6d 24 ff 6d 49 00 6d 49 55 6d 49 aa 6d 49 ff 6d 6d 00 6d 6d 55 6d 6d aa 6d 6d ff 6d 92 00 6d 92 55 6d 92 aa 6d 92 ff 6d b6 00 6d b6 55 6d b6 aa 6d b6 ff 6d db 00 6d db 55 6d db aa 6d db ff 6d ff 00 6d ff 55 6d ff aa 6d ff ff 92 00 00 92 00 55 92 00 aa 92 00 ff 92 24 00 92 24 55 92 24 aa 92 24 ff 92 49 00 92 49 55 92 49 aa 92 49 ff 92 6d 00 92 6d 55 92 6d aa 92 6d ff 92 92 00 92 92 55 92 92 aa 92 92 ff 92 b6 00 92 b6 55 92 b6 aa 92 b6 ff 92 db 00 92 db 55 92 db aa 92 db ff 92 ff 00 92 ff 55 92 ff aa 92 ff ff b6 00 00 b6 00 55 b6 00 aa b6 00 ff b6 24 00 b6 24 55 b6 24 aa b6 24 ff b6 49 00 b6 49 55 b6 49 aa b6 49 ff b6 6d 00 b6 6d 55 b6 6d aa b6 6d ff b6 92 00 b6 92 55 b6 92 aa b6 92 ff b6 b6 00 b6 b6 55 b6 b6 aa b6 b6 ff b6 db 00 b6 db 55 b6 db aa b6 db ff b6 ff 00 b6 ff 55 b6 ff aa b6 ff ff db 00 00 db 00 55 db 00 aa db 00 ff db 24 00 db 24 55 db 24 aa db 24 ff db 49 00 db 49 55 db 49 aa db 49 ff db 6d 00 db 6d 55 db 6d aa db 6d ff db 92 00 db 92 55 db 92 aa db 92 ff db b6 00 db b6 55 db b6 aa db b6 ff db db 00 db db 55 db db aa db db ff db ff 00 db ff 55 db ff aa db ff ff ff 00 00 ff 00 55 ff 00 aa ff 00 ff ff 24 00 ff 24 55 ff 24 aa ff 24 ff ff 49 00 ff 49 55 ff 49 aa ff 49 ff ff 6d 00 ff 6d 55 ff 6d aa ff 6d ff ff 92 00 ff 92 55 ff 92 aa ff 92 ff ff b6 00 ff b6 55 ff b6 aa ff b6 ff ff db 00 ff db 55 ff db aa ff db ff ff ff 00 ff ff 55 ff ff aa ff ff ff 21 f9 04 01 00 00 ff 00 2c 00 00 00 00 10 00 36 00 40 08 87 00 ff 09 1c 48 b0 a0 c1 7f 00 12 2a 3c 38 10 00 41 87 0c 23 32 74 48 11 62 41 85 18 13 46 cc 68 51 a2 c7 86 0f 3f 6a ec 78 10 a3 47 8e 13 0d 92 fc c8 b2 25 c8 8d 19 4b 56 34 b9 b1 e1 4a 84 1c 35 d6 7c 09 53 e0 cd 87 0b 25 fe 74 a9 b2 28 d1 a3 48 93 da a4 99 b2 25 4a a7 32 71 32 2d 19 52 28 ce 89 39 6f 6a 15 6a 71 a8 d4 a0 4a 81 42 f4 fa 94 25 d9 98 2a b3 52 35 9a b6 ea 5a b7 17 3b ea c4 3a 37 6c cb 80 00 3b}}
    set image_checkmark {checkmark.gif {47 49 46 38 39 61 09 00 09 00 91 00 00 00 00 00 ff ff ff ff ff ff 00 00 00 21 f9 04 01 00 00 02 00 2c 00 00 00 00 09 00 09 00 00 02 11 94 8f a9 07 a0 ed 44 93 d0 c0 6b 6f a4 15 75 53 00 00 3b}}
    set image_checkout {checkout.gif {47 49 46 38 39 61 10 00 40 00 f7 00 00 00 00 00 00 00 55 00 00 aa 00 00 ff 00 24 00 00 24 55 00 24 aa 00 24 ff 00 49 00 00 49 55 00 49 aa 00 49 ff 00 6d 00 00 6d 55 00 6d aa 00 6d ff 00 92 00 00 92 55 00 92 aa 00 92 ff 00 b6 00 00 b6 55 00 b6 aa 00 b6 ff 00 db 00 00 db 55 00 db aa 00 db ff 00 ff 00 00 ff 55 00 ff aa 00 ff ff 24 00 00 24 00 55 24 00 aa 24 00 ff 24 24 00 24 24 55 24 24 aa 24 24 ff 24 49 00 24 49 55 24 49 aa 24 49 ff 24 6d 00 24 6d 55 24 6d aa 24 6d ff 24 92 00 24 92 55 24 92 aa 24 92 ff 24 b6 00 24 b6 55 24 b6 aa 24 b6 ff 24 db 00 24 db 55 24 db aa 24 db ff 24 ff 00 24 ff 55 24 ff aa 24 ff ff 49 00 00 49 00 55 49 00 aa 49 00 ff 49 24 00 49 24 55 49 24 aa 49 24 ff 49 49 00 49 49 55 49 49 aa 49 49 ff 49 6d 00 49 6d 55 49 6d aa 49 6d ff 49 92 00 49 92 55 49 92 aa 49 92 ff 49 b6 00 49 b6 55 49 b6 aa 49 b6 ff 49 db 00 49 db 55 49 db aa 49 db ff 49 ff 00 49 ff 55 49 ff aa 49 ff ff 6d 00 00 6d 00 55 6d 00 aa 6d 00 ff 6d 24 00 6d 24 55 6d 24 aa 6d 24 ff 6d 49 00 6d 49 55 6d 49 aa 6d 49 ff 6d 6d 00 6d 6d 55 6d 6d aa 6d 6d ff 6d 92 00 6d 92 55 6d 92 aa 6d 92 ff 6d b6 00 6d b6 55 6d b6 aa 6d b6 ff 6d db 00 6d db 55 6d db aa 6d db ff 6d ff 00 6d ff 55 6d ff aa 6d ff ff 92 00 00 92 00 55 92 00 aa 92 00 ff 92 24 00 92 24 55 92 24 aa 92 24 ff 92 49 00 92 49 55 92 49 aa 92 49 ff 92 6d 00 92 6d 55 92 6d aa 92 6d ff 92 92 00 92 92 55 92 92 aa 92 92 ff 92 b6 00 92 b6 55 92 b6 aa 92 b6 ff 92 db 00 92 db 55 92 db aa 92 db ff 92 ff 00 92 ff 55 92 ff aa 92 ff ff b6 00 00 b6 00 55 b6 00 aa b6 00 ff b6 24 00 b6 24 55 b6 24 aa b6 24 ff b6 49 00 b6 49 55 b6 49 aa b6 49 ff b6 6d 00 b6 6d 55 b6 6d aa b6 6d ff b6 92 00 b6 92 55 b6 92 aa b6 92 ff b6 b6 00 b6 b6 55 b6 b6 aa b6 b6 ff b6 db 00 b6 db 55 b6 db aa b6 db ff b6 ff 00 b6 ff 55 b6 ff aa b6 ff ff db 00 00 db 00 55 db 00 aa db 00 ff db 24 00 db 24 55 db 24 aa db 24 ff db 49 00 db 49 55 db 49 aa db 49 ff db 6d 00 db 6d 55 db 6d aa db 6d ff db 92 00 db 92 55 db 92 aa db 92 ff db b6 00 db b6 55 db b6 aa db b6 ff db db 00 db db 55 db db aa db db ff db ff 00 db ff 55 db ff aa db ff ff ff 00 00 ff 00 55 ff 00 aa ff 00 ff ff 24 00 ff 24 55 ff 24 aa ff 24 ff ff 49 00 ff 49 55 ff 49 aa ff 49 ff ff 6d 00 ff 6d 55 ff 6d aa ff 6d ff ff 92 00 ff 92 55 ff 92 aa ff 92 ff ff b6 00 ff b6 55 ff b6 aa ff b6 ff ff db 00 ff db 55 ff db aa ff db ff ff ff 00 ff ff 55 ff ff aa ff ff ff 21 f9 04 01 00 00 ff 00 2c 00 00 00 00 10 00 40 00 40 08 95 00 ff 09 1c 48 b0 a0 c1 83 08 0d 02 48 28 70 e1 40 87 05 01 48 9c 38 91 e1 3f 89 0d 19 42 d4 a8 d0 a2 c7 87 1f 43 12 84 88 31 e1 c6 8d 07 29 8a 5c c9 b2 65 4a 8a 15 4d c2 d4 38 53 a6 4a 9a 25 2d 62 44 e9 f2 61 4c 93 17 2f f2 1c 59 33 22 cc 9f 11 3b 22 3c da b3 a9 d3 a7 49 41 be 64 1a 72 a8 cf 9b 4b 8b a6 5c 89 75 e9 48 9c 48 95 66 e4 98 d3 e8 d1 a1 68 69 4a cd da d5 69 4c ab 0d b5 ea 04 5b f6 2a d5 a8 78 8d 7e f5 9a 97 a8 5f 9b 70 a1 16 0c 08 00 3b}}
    set image_create {create.gif {47 49 46 38 39 61 10 00 2c 00 f7 00 00 00 00 00 00 00 55 00 00 aa 00 00 ff 00 24 00 00 24 55 00 24 aa 00 24 ff 00 49 00 00 49 55 00 49 aa 00 49 ff 00 6d 00 00 6d 55 00 6d aa 00 6d ff 00 92 00 00 92 55 00 92 aa 00 92 ff 00 b6 00 00 b6 55 00 b6 aa 00 b6 ff 00 db 00 00 db 55 00 db aa 00 db ff 00 ff 00 00 ff 55 00 ff aa 00 ff ff 24 00 00 24 00 55 24 00 aa 24 00 ff 24 24 00 24 24 55 24 24 aa 24 24 ff 24 49 00 24 49 55 24 49 aa 24 49 ff 24 6d 00 24 6d 55 24 6d aa 24 6d ff 24 92 00 24 92 55 24 92 aa 24 92 ff 24 b6 00 24 b6 55 24 b6 aa 24 b6 ff 24 db 00 24 db 55 24 db aa 24 db ff 24 ff 00 24 ff 55 24 ff aa 24 ff ff 49 00 00 49 00 55 49 00 aa 49 00 ff 49 24 00 49 24 55 49 24 aa 49 24 ff 49 49 00 49 49 55 49 49 aa 49 49 ff 49 6d 00 49 6d 55 49 6d aa 49 6d ff 49 92 00 49 92 55 49 92 aa 49 92 ff 49 b6 00 49 b6 55 49 b6 aa 49 b6 ff 49 db 00 49 db 55 49 db aa 49 db ff 49 ff 00 49 ff 55 49 ff aa 49 ff ff 6d 00 00 6d 00 55 6d 00 aa 6d 00 ff 6d 24 00 6d 24 55 6d 24 aa 6d 24 ff 6d 49 00 6d 49 55 6d 49 aa 6d 49 ff 6d 6d 00 6d 6d 55 6d 6d aa 6d 6d ff 6d 92 00 6d 92 55 6d 92 aa 6d 92 ff 6d b6 00 6d b6 55 6d b6 aa 6d b6 ff 6d db 00 6d db 55 6d db aa 6d db ff 6d ff 00 6d ff 55 6d ff aa 6d ff ff 92 00 00 92 00 55 92 00 aa 92 00 ff 92 24 00 92 24 55 92 24 aa 92 24 ff 92 49 00 92 49 55 92 49 aa 92 49 ff 92 6d 00 92 6d 55 92 6d aa 92 6d ff 92 92 00 92 92 55 92 92 aa 92 92 ff 92 b6 00 92 b6 55 92 b6 aa 92 b6 ff 92 db 00 92 db 55 92 db aa 92 db ff 92 ff 00 92 ff 55 92 ff aa 92 ff ff b6 00 00 b6 00 55 b6 00 aa b6 00 ff b6 24 00 b6 24 55 b6 24 aa b6 24 ff b6 49 00 b6 49 55 b6 49 aa b6 49 ff b6 6d 00 b6 6d 55 b6 6d aa b6 6d ff b6 92 00 b6 92 55 b6 92 aa b6 92 ff b6 b6 00 b6 b6 55 b6 b6 aa b6 b6 ff b6 db 00 b6 db 55 b6 db aa b6 db ff b6 ff 00 b6 ff 55 b6 ff aa b6 ff ff db 00 00 db 00 55 db 00 aa db 00 ff db 24 00 db 24 55 db 24 aa db 24 ff db 49 00 db 49 55 db 49 aa db 49 ff db 6d 00 db 6d 55 db 6d aa db 6d ff db 92 00 db 92 55 db 92 aa db 92 ff db b6 00 db b6 55 db b6 aa db b6 ff db db 00 db db 55 db db aa db db ff db ff 00 db ff 55 db ff aa db ff ff ff 00 00 ff 00 55 ff 00 aa ff 00 ff ff 24 00 ff 24 55 ff 24 aa ff 24 ff ff 49 00 ff 49 55 ff 49 aa ff 49 ff ff 6d 00 ff 6d 55 ff 6d aa ff 6d ff ff 92 00 ff 92 55 ff 92 aa ff 92 ff ff b6 00 ff b6 55 ff b6 aa ff b6 ff ff db 00 ff db 55 ff db aa ff db ff ff ff 00 ff ff 55 ff ff aa ff ff ff 21 f9 04 01 00 00 ff 00 2c 00 00 00 00 10 00 2c 00 40 08 71 00 ff 09 1c 48 b0 a0 41 00 ff 10 02 40 68 70 e0 c2 87 0c 1b 26 9c b8 50 a2 c5 8b 18 33 1e 84 f8 50 63 47 8b 11 27 36 0c 29 90 a4 46 90 0c 4d 16 84 88 51 a5 44 85 22 2f 56 8c f9 f2 23 4a 96 23 0f de b4 79 b2 a7 cf 9f 32 67 ba 2c c9 51 26 41 97 1c 79 b6 0c 8a f3 65 42 a5 40 1d 0a 65 0a f5 68 cf a4 46 1d d6 b4 ea 74 e5 56 a9 54 a3 8a 0d 08 00 3b}}
    set image_delete {delete.gif {47 49 46 38 39 61 10 00 31 00 f7 00 00 00 00 00 00 00 55 00 00 aa 00 00 ff 00 24 00 00 24 55 00 24 aa 00 24 ff 00 49 00 00 49 55 00 49 aa 00 49 ff 00 6d 00 00 6d 55 00 6d aa 00 6d ff 00 92 00 00 92 55 00 92 aa 00 92 ff 00 b6 00 00 b6 55 00 b6 aa 00 b6 ff 00 db 00 00 db 55 00 db aa 00 db ff 00 ff 00 00 ff 55 00 ff aa 00 ff ff 24 00 00 24 00 55 24 00 aa 24 00 ff 24 24 00 24 24 55 24 24 aa 24 24 ff 24 49 00 24 49 55 24 49 aa 24 49 ff 24 6d 00 24 6d 55 24 6d aa 24 6d ff 24 92 00 24 92 55 24 92 aa 24 92 ff 24 b6 00 24 b6 55 24 b6 aa 24 b6 ff 24 db 00 24 db 55 24 db aa 24 db ff 24 ff 00 24 ff 55 24 ff aa 24 ff ff 49 00 00 49 00 55 49 00 aa 49 00 ff 49 24 00 49 24 55 49 24 aa 49 24 ff 49 49 00 49 49 55 49 49 aa 49 49 ff 49 6d 00 49 6d 55 49 6d aa 49 6d ff 49 92 00 49 92 55 49 92 aa 49 92 ff 49 b6 00 49 b6 55 49 b6 aa 49 b6 ff 49 db 00 49 db 55 49 db aa 49 db ff 49 ff 00 49 ff 55 49 ff aa 49 ff ff 6d 00 00 6d 00 55 6d 00 aa 6d 00 ff 6d 24 00 6d 24 55 6d 24 aa 6d 24 ff 6d 49 00 6d 49 55 6d 49 aa 6d 49 ff 6d 6d 00 6d 6d 55 6d 6d aa 6d 6d ff 6d 92 00 6d 92 55 6d 92 aa 6d 92 ff 6d b6 00 6d b6 55 6d b6 aa 6d b6 ff 6d db 00 6d db 55 6d db aa 6d db ff 6d ff 00 6d ff 55 6d ff aa 6d ff ff 92 00 00 92 00 55 92 00 aa 92 00 ff 92 24 00 92 24 55 92 24 aa 92 24 ff 92 49 00 92 49 55 92 49 aa 92 49 ff 92 6d 00 92 6d 55 92 6d aa 92 6d ff 92 92 00 92 92 55 92 92 aa 92 92 ff 92 b6 00 92 b6 55 92 b6 aa 92 b6 ff 92 db 00 92 db 55 92 db aa 92 db ff 92 ff 00 92 ff 55 92 ff aa 92 ff ff b6 00 00 b6 00 55 b6 00 aa b6 00 ff b6 24 00 b6 24 55 b6 24 aa b6 24 ff b6 49 00 b6 49 55 b6 49 aa b6 49 ff b6 6d 00 b6 6d 55 b6 6d aa b6 6d ff b6 92 00 b6 92 55 b6 92 aa b6 92 ff b6 b6 00 b6 b6 55 b6 b6 aa b6 b6 ff b6 db 00 b6 db 55 b6 db aa b6 db ff b6 ff 00 b6 ff 55 b6 ff aa b6 ff ff db 00 00 db 00 55 db 00 aa db 00 ff db 24 00 db 24 55 db 24 aa db 24 ff db 49 00 db 49 55 db 49 aa db 49 ff db 6d 00 db 6d 55 db 6d aa db 6d ff db 92 00 db 92 55 db 92 aa db 92 ff db b6 00 db b6 55 db b6 aa db b6 ff db db 00 db db 55 db db aa db db ff db ff 00 db ff 55 db ff aa db ff ff ff 00 00 ff 00 55 ff 00 aa ff 00 ff ff 24 00 ff 24 55 ff 24 aa ff 24 ff ff 49 00 ff 49 55 ff 49 aa ff 49 ff ff 6d 00 ff 6d 55 ff 6d aa ff 6d ff ff 92 00 ff 92 55 ff 92 aa ff 92 ff ff b6 00 ff b6 55 ff b6 aa ff b6 ff ff db 00 ff db 55 ff db aa ff db ff ff ff 00 ff ff 55 ff ff aa ff ff ff 21 f9 04 01 00 00 ff 00 2c 00 00 00 00 10 00 31 00 40 08 78 00 ff 09 1c 48 b0 a0 c1 83 08 05 02 20 b8 30 21 80 87 10 13 fe 8b 38 11 61 43 86 12 33 6a 74 f8 50 e1 46 89 10 43 76 fc c8 51 e4 45 92 28 53 1e 34 69 d1 e4 49 83 14 5f 82 54 d9 32 64 49 8a 2b 61 d2 dc c9 b3 a7 4f 85 0d 65 62 5c 38 f2 e6 4d 9b 0e 51 8e 14 3a 90 e8 44 a6 4d 71 16 74 59 14 a3 4e 90 41 67 12 85 0a b4 ea 4a a9 30 4f 42 95 c9 94 aa c5 ab 2a 03 02 00 3b}}
    set image_demote {demote.gif {47 49 46 38 39 61 10 00 32 00 f7 00 00 00 00 00 00 00 55 00 00 aa 00 00 ff 00 24 00 00 24 55 00 24 aa 00 24 ff 00 49 00 00 49 55 00 49 aa 00 49 ff 00 6d 00 00 6d 55 00 6d aa 00 6d ff 00 92 00 00 92 55 00 92 aa 00 92 ff 00 b6 00 00 b6 55 00 b6 aa 00 b6 ff 00 db 00 00 db 55 00 db aa 00 db ff 00 ff 00 00 ff 55 00 ff aa 00 ff ff 24 00 00 24 00 55 24 00 aa 24 00 ff 24 24 00 24 24 55 24 24 aa 24 24 ff 24 49 00 24 49 55 24 49 aa 24 49 ff 24 6d 00 24 6d 55 24 6d aa 24 6d ff 24 92 00 24 92 55 24 92 aa 24 92 ff 24 b6 00 24 b6 55 24 b6 aa 24 b6 ff 24 db 00 24 db 55 24 db aa 24 db ff 24 ff 00 24 ff 55 24 ff aa 24 ff ff 49 00 00 49 00 55 49 00 aa 49 00 ff 49 24 00 49 24 55 49 24 aa 49 24 ff 49 49 00 49 49 55 49 49 aa 49 49 ff 49 6d 00 49 6d 55 49 6d aa 49 6d ff 49 92 00 49 92 55 49 92 aa 49 92 ff 49 b6 00 49 b6 55 49 b6 aa 49 b6 ff 49 db 00 49 db 55 49 db aa 49 db ff 49 ff 00 49 ff 55 49 ff aa 49 ff ff 6d 00 00 6d 00 55 6d 00 aa 6d 00 ff 6d 24 00 6d 24 55 6d 24 aa 6d 24 ff 6d 49 00 6d 49 55 6d 49 aa 6d 49 ff 6d 6d 00 6d 6d 55 6d 6d aa 6d 6d ff 6d 92 00 6d 92 55 6d 92 aa 6d 92 ff 6d b6 00 6d b6 55 6d b6 aa 6d b6 ff 6d db 00 6d db 55 6d db aa 6d db ff 6d ff 00 6d ff 55 6d ff aa 6d ff ff 92 00 00 92 00 55 92 00 aa 92 00 ff 92 24 00 92 24 55 92 24 aa 92 24 ff 92 49 00 92 49 55 92 49 aa 92 49 ff 92 6d 00 92 6d 55 92 6d aa 92 6d ff 92 92 00 92 92 55 92 92 aa 92 92 ff 92 b6 00 92 b6 55 92 b6 aa 92 b6 ff 92 db 00 92 db 55 92 db aa 92 db ff 92 ff 00 92 ff 55 92 ff aa 92 ff ff b6 00 00 b6 00 55 b6 00 aa b6 00 ff b6 24 00 b6 24 55 b6 24 aa b6 24 ff b6 49 00 b6 49 55 b6 49 aa b6 49 ff b6 6d 00 b6 6d 55 b6 6d aa b6 6d ff b6 92 00 b6 92 55 b6 92 aa b6 92 ff b6 b6 00 b6 b6 55 b6 b6 aa b6 b6 ff b6 db 00 b6 db 55 b6 db aa b6 db ff b6 ff 00 b6 ff 55 b6 ff aa b6 ff ff db 00 00 db 00 55 db 00 aa db 00 ff db 24 00 db 24 55 db 24 aa db 24 ff db 49 00 db 49 55 db 49 aa db 49 ff db 6d 00 db 6d 55 db 6d aa db 6d ff db 92 00 db 92 55 db 92 aa db 92 ff db b6 00 db b6 55 db b6 aa db b6 ff db db 00 db db 55 db db aa db db ff db ff 00 db ff 55 db ff aa db ff ff ff 00 00 ff 00 55 ff 00 aa ff 00 ff ff 24 00 ff 24 55 ff 24 aa ff 24 ff ff 49 00 ff 49 55 ff 49 aa ff 49 ff ff 6d 00 ff 6d 55 ff 6d aa ff 6d ff ff 92 00 ff 92 55 ff 92 aa ff 92 ff ff b6 00 ff b6 55 ff b6 aa ff b6 ff ff db 00 ff db 55 ff db aa ff db ff ff ff 00 ff ff 55 ff ff aa ff ff ff 21 f9 04 01 00 00 ff 00 2c 00 00 00 00 10 00 32 00 40 08 7e 00 ff 09 1c 48 b0 a0 c1 7f 00 12 02 38 48 70 e1 40 87 0c 11 46 34 98 50 20 c4 82 15 1f 4e dc 78 30 e3 45 8a 1c 43 52 54 98 31 22 49 93 24 15 8a e4 b8 b0 e5 c7 87 29 4b 32 3c 39 31 66 cd 94 37 69 ce 6c 58 53 a2 cc 91 3f 31 82 ec 38 74 a5 51 94 0e 5f 36 c4 69 92 67 c7 98 4a 8f 5a 64 ba 53 63 ce a8 55 67 52 7d aa 93 a8 48 9b 52 b9 5a bc 1a 34 2c 58 af 4e 8b 5a 05 ba 35 ac c8 80 00 3b}}
    set image_disable {disable.gif {47 49 46 38 39 61 10 00 31 00 f7 00 00 00 00 00 00 00 55 00 00 aa 00 00 ff 00 24 00 00 24 55 00 24 aa 00 24 ff 00 49 00 00 49 55 00 49 aa 00 49 ff 00 6d 00 00 6d 55 00 6d aa 00 6d ff 00 92 00 00 92 55 00 92 aa 00 92 ff 00 b6 00 00 b6 55 00 b6 aa 00 b6 ff 00 db 00 00 db 55 00 db aa 00 db ff 00 ff 00 00 ff 55 00 ff aa 00 ff ff 24 00 00 24 00 55 24 00 aa 24 00 ff 24 24 00 24 24 55 24 24 aa 24 24 ff 24 49 00 24 49 55 24 49 aa 24 49 ff 24 6d 00 24 6d 55 24 6d aa 24 6d ff 24 92 00 24 92 55 24 92 aa 24 92 ff 24 b6 00 24 b6 55 24 b6 aa 24 b6 ff 24 db 00 24 db 55 24 db aa 24 db ff 24 ff 00 24 ff 55 24 ff aa 24 ff ff 49 00 00 49 00 55 49 00 aa 49 00 ff 49 24 00 49 24 55 49 24 aa 49 24 ff 49 49 00 49 49 55 49 49 aa 49 49 ff 49 6d 00 49 6d 55 49 6d aa 49 6d ff 49 92 00 49 92 55 49 92 aa 49 92 ff 49 b6 00 49 b6 55 49 b6 aa 49 b6 ff 49 db 00 49 db 55 49 db aa 49 db ff 49 ff 00 49 ff 55 49 ff aa 49 ff ff 6d 00 00 6d 00 55 6d 00 aa 6d 00 ff 6d 24 00 6d 24 55 6d 24 aa 6d 24 ff 6d 49 00 6d 49 55 6d 49 aa 6d 49 ff 6d 6d 00 6d 6d 55 6d 6d aa 6d 6d ff 6d 92 00 6d 92 55 6d 92 aa 6d 92 ff 6d b6 00 6d b6 55 6d b6 aa 6d b6 ff 6d db 00 6d db 55 6d db aa 6d db ff 6d ff 00 6d ff 55 6d ff aa 6d ff ff 92 00 00 92 00 55 92 00 aa 92 00 ff 92 24 00 92 24 55 92 24 aa 92 24 ff 92 49 00 92 49 55 92 49 aa 92 49 ff 92 6d 00 92 6d 55 92 6d aa 92 6d ff 92 92 00 92 92 55 92 92 aa 92 92 ff 92 b6 00 92 b6 55 92 b6 aa 92 b6 ff 92 db 00 92 db 55 92 db aa 92 db ff 92 ff 00 92 ff 55 92 ff aa 92 ff ff b6 00 00 b6 00 55 b6 00 aa b6 00 ff b6 24 00 b6 24 55 b6 24 aa b6 24 ff b6 49 00 b6 49 55 b6 49 aa b6 49 ff b6 6d 00 b6 6d 55 b6 6d aa b6 6d ff b6 92 00 b6 92 55 b6 92 aa b6 92 ff b6 b6 00 b6 b6 55 b6 b6 aa b6 b6 ff b6 db 00 b6 db 55 b6 db aa b6 db ff b6 ff 00 b6 ff 55 b6 ff aa b6 ff ff db 00 00 db 00 55 db 00 aa db 00 ff db 24 00 db 24 55 db 24 aa db 24 ff db 49 00 db 49 55 db 49 aa db 49 ff db 6d 00 db 6d 55 db 6d aa db 6d ff db 92 00 db 92 55 db 92 aa db 92 ff db b6 00 db b6 55 db b6 aa db b6 ff db db 00 db db 55 db db aa db db ff db ff 00 db ff 55 db ff aa db ff ff ff 00 00 ff 00 55 ff 00 aa ff 00 ff ff 24 00 ff 24 55 ff 24 aa ff 24 ff ff 49 00 ff 49 55 ff 49 aa ff 49 ff ff 6d 00 ff 6d 55 ff 6d aa ff 6d ff ff 92 00 ff 92 55 ff 92 aa ff 92 ff ff b6 00 ff b6 55 ff b6 aa ff b6 ff ff db 00 ff db 55 ff db aa ff db ff ff ff 00 ff ff 55 ff ff aa ff ff ff 21 f9 04 01 00 00 ff 00 2c 00 00 00 00 10 00 31 00 40 08 82 00 ff 09 1c 48 b0 a0 c1 7f 00 12 2a 3c 38 50 61 42 86 0d 11 4a 84 68 10 00 43 8b 05 31 52 dc c8 91 a0 c3 8f 07 35 76 14 f8 f0 e1 48 8a 1f 17 9e 44 69 52 e4 46 97 2b 49 a6 34 79 11 24 47 95 17 11 5a 84 a9 53 a7 43 88 29 81 56 8c 49 b4 68 46 8c 3c 23 ee 4c da 10 e7 d1 99 21 a3 b2 64 1a b1 ea d3 a0 23 a9 62 cd f9 d3 68 c6 9e 54 c1 f2 2c 69 33 a7 d5 90 4e 2b 8a 64 0a 33 e9 4c b7 43 8b 06 04 00 3b}}
    set image_enable {enable.gif {47 49 46 38 39 61 10 00 31 00 f7 00 00 00 00 00 00 00 55 00 00 aa 00 00 ff 00 24 00 00 24 55 00 24 aa 00 24 ff 00 49 00 00 49 55 00 49 aa 00 49 ff 00 6d 00 00 6d 55 00 6d aa 00 6d ff 00 92 00 00 92 55 00 92 aa 00 92 ff 00 b6 00 00 b6 55 00 b6 aa 00 b6 ff 00 db 00 00 db 55 00 db aa 00 db ff 00 ff 00 00 ff 55 00 ff aa 00 ff ff 24 00 00 24 00 55 24 00 aa 24 00 ff 24 24 00 24 24 55 24 24 aa 24 24 ff 24 49 00 24 49 55 24 49 aa 24 49 ff 24 6d 00 24 6d 55 24 6d aa 24 6d ff 24 92 00 24 92 55 24 92 aa 24 92 ff 24 b6 00 24 b6 55 24 b6 aa 24 b6 ff 24 db 00 24 db 55 24 db aa 24 db ff 24 ff 00 24 ff 55 24 ff aa 24 ff ff 49 00 00 49 00 55 49 00 aa 49 00 ff 49 24 00 49 24 55 49 24 aa 49 24 ff 49 49 00 49 49 55 49 49 aa 49 49 ff 49 6d 00 49 6d 55 49 6d aa 49 6d ff 49 92 00 49 92 55 49 92 aa 49 92 ff 49 b6 00 49 b6 55 49 b6 aa 49 b6 ff 49 db 00 49 db 55 49 db aa 49 db ff 49 ff 00 49 ff 55 49 ff aa 49 ff ff 6d 00 00 6d 00 55 6d 00 aa 6d 00 ff 6d 24 00 6d 24 55 6d 24 aa 6d 24 ff 6d 49 00 6d 49 55 6d 49 aa 6d 49 ff 6d 6d 00 6d 6d 55 6d 6d aa 6d 6d ff 6d 92 00 6d 92 55 6d 92 aa 6d 92 ff 6d b6 00 6d b6 55 6d b6 aa 6d b6 ff 6d db 00 6d db 55 6d db aa 6d db ff 6d ff 00 6d ff 55 6d ff aa 6d ff ff 92 00 00 92 00 55 92 00 aa 92 00 ff 92 24 00 92 24 55 92 24 aa 92 24 ff 92 49 00 92 49 55 92 49 aa 92 49 ff 92 6d 00 92 6d 55 92 6d aa 92 6d ff 92 92 00 92 92 55 92 92 aa 92 92 ff 92 b6 00 92 b6 55 92 b6 aa 92 b6 ff 92 db 00 92 db 55 92 db aa 92 db ff 92 ff 00 92 ff 55 92 ff aa 92 ff ff b6 00 00 b6 00 55 b6 00 aa b6 00 ff b6 24 00 b6 24 55 b6 24 aa b6 24 ff b6 49 00 b6 49 55 b6 49 aa b6 49 ff b6 6d 00 b6 6d 55 b6 6d aa b6 6d ff b6 92 00 b6 92 55 b6 92 aa b6 92 ff b6 b6 00 b6 b6 55 b6 b6 aa b6 b6 ff b6 db 00 b6 db 55 b6 db aa b6 db ff b6 ff 00 b6 ff 55 b6 ff aa b6 ff ff db 00 00 db 00 55 db 00 aa db 00 ff db 24 00 db 24 55 db 24 aa db 24 ff db 49 00 db 49 55 db 49 aa db 49 ff db 6d 00 db 6d 55 db 6d aa db 6d ff db 92 00 db 92 55 db 92 aa db 92 ff db b6 00 db b6 55 db b6 aa db b6 ff db db 00 db db 55 db db aa db db ff db ff 00 db ff 55 db ff aa db ff ff ff 00 00 ff 00 55 ff 00 aa ff 00 ff ff 24 00 ff 24 55 ff 24 aa ff 24 ff ff 49 00 ff 49 55 ff 49 aa ff 49 ff ff 6d 00 ff 6d 55 ff 6d aa ff 6d ff ff 92 00 ff 92 55 ff 92 aa ff 92 ff ff b6 00 ff b6 55 ff b6 aa ff b6 ff ff db 00 ff db 55 ff db aa ff db ff ff ff 00 ff ff 55 ff ff aa ff ff ff 21 f9 04 01 00 00 ff 00 2c 00 00 00 00 10 00 31 00 40 08 77 00 ff 09 1c 48 b0 a0 c1 83 07 01 28 5c b8 30 21 c2 87 ff 18 2a 44 08 20 e2 c4 88 10 33 6a 7c 28 b1 22 47 86 19 2b 8a 0c 29 91 a2 41 8f 1b 53 6e 6c 88 31 25 4a 95 05 3b b2 a4 58 52 e3 4c 87 30 6d ca cc c9 b3 a7 cf 9c 17 5f 9e c4 78 f1 63 d1 98 32 85 0a 54 da d2 a8 4d 82 4c 93 32 35 69 f4 e6 50 90 2e 21 76 d4 5a 93 ea 52 9a 50 a7 7a 44 29 76 e7 cf 94 01 01 00 3b}}
    set image_execute {execute.gif {47 49 46 38 39 61 10 00 30 00 f7 00 00 00 00 00 00 00 55 00 00 aa 00 00 ff 00 24 00 00 24 55 00 24 aa 00 24 ff 00 49 00 00 49 55 00 49 aa 00 49 ff 00 6d 00 00 6d 55 00 6d aa 00 6d ff 00 92 00 00 92 55 00 92 aa 00 92 ff 00 b6 00 00 b6 55 00 b6 aa 00 b6 ff 00 db 00 00 db 55 00 db aa 00 db ff 00 ff 00 00 ff 55 00 ff aa 00 ff ff 24 00 00 24 00 55 24 00 aa 24 00 ff 24 24 00 24 24 55 24 24 aa 24 24 ff 24 49 00 24 49 55 24 49 aa 24 49 ff 24 6d 00 24 6d 55 24 6d aa 24 6d ff 24 92 00 24 92 55 24 92 aa 24 92 ff 24 b6 00 24 b6 55 24 b6 aa 24 b6 ff 24 db 00 24 db 55 24 db aa 24 db ff 24 ff 00 24 ff 55 24 ff aa 24 ff ff 49 00 00 49 00 55 49 00 aa 49 00 ff 49 24 00 49 24 55 49 24 aa 49 24 ff 49 49 00 49 49 55 49 49 aa 49 49 ff 49 6d 00 49 6d 55 49 6d aa 49 6d ff 49 92 00 49 92 55 49 92 aa 49 92 ff 49 b6 00 49 b6 55 49 b6 aa 49 b6 ff 49 db 00 49 db 55 49 db aa 49 db ff 49 ff 00 49 ff 55 49 ff aa 49 ff ff 6d 00 00 6d 00 55 6d 00 aa 6d 00 ff 6d 24 00 6d 24 55 6d 24 aa 6d 24 ff 6d 49 00 6d 49 55 6d 49 aa 6d 49 ff 6d 6d 00 6d 6d 55 6d 6d aa 6d 6d ff 6d 92 00 6d 92 55 6d 92 aa 6d 92 ff 6d b6 00 6d b6 55 6d b6 aa 6d b6 ff 6d db 00 6d db 55 6d db aa 6d db ff 6d ff 00 6d ff 55 6d ff aa 6d ff ff 92 00 00 92 00 55 92 00 aa 92 00 ff 92 24 00 92 24 55 92 24 aa 92 24 ff 92 49 00 92 49 55 92 49 aa 92 49 ff 92 6d 00 92 6d 55 92 6d aa 92 6d ff 92 92 00 92 92 55 92 92 aa 92 92 ff 92 b6 00 92 b6 55 92 b6 aa 92 b6 ff 92 db 00 92 db 55 92 db aa 92 db ff 92 ff 00 92 ff 55 92 ff aa 92 ff ff b6 00 00 b6 00 55 b6 00 aa b6 00 ff b6 24 00 b6 24 55 b6 24 aa b6 24 ff b6 49 00 b6 49 55 b6 49 aa b6 49 ff b6 6d 00 b6 6d 55 b6 6d aa b6 6d ff b6 92 00 b6 92 55 b6 92 aa b6 92 ff b6 b6 00 b6 b6 55 b6 b6 aa b6 b6 ff b6 db 00 b6 db 55 b6 db aa b6 db ff b6 ff 00 b6 ff 55 b6 ff aa b6 ff ff db 00 00 db 00 55 db 00 aa db 00 ff db 24 00 db 24 55 db 24 aa db 24 ff db 49 00 db 49 55 db 49 aa db 49 ff db 6d 00 db 6d 55 db 6d aa db 6d ff db 92 00 db 92 55 db 92 aa db 92 ff db b6 00 db b6 55 db b6 aa db b6 ff db db 00 db db 55 db db aa db db ff db ff 00 db ff 55 db ff aa db ff ff ff 00 00 ff 00 55 ff 00 aa ff 00 ff ff 24 00 ff 24 55 ff 24 aa ff 24 ff ff 49 00 ff 49 55 ff 49 aa ff 49 ff ff 6d 00 ff 6d 55 ff 6d aa ff 6d ff ff 92 00 ff 92 55 ff 92 aa ff 92 ff ff b6 00 ff b6 55 ff b6 aa ff b6 ff ff db 00 ff db 55 ff db aa ff db ff ff ff 00 ff ff 55 ff ff aa ff ff ff 21 f9 04 01 00 00 ff 00 2c 00 00 00 00 10 00 30 00 40 08 7c 00 ff 09 1c 48 b0 a0 41 00 08 13 1a 24 98 50 e1 42 81 0d 11 3e 84 c8 f0 21 80 7f 0e 2f 4e dc c8 30 a2 c4 89 1a 39 42 fc 18 72 21 c9 92 15 0b a2 14 09 92 e4 c6 92 2b 41 be 8c 38 73 60 4c 96 07 69 72 74 88 b3 a5 c7 9e 40 83 ee d4 78 93 e2 c5 8f 3e 8b 7a 44 6a b2 e7 4f 96 45 47 36 14 6a 31 65 52 91 2e 65 1e 8d 8a 91 a7 56 a6 26 c1 36 b5 69 11 e6 4d a2 64 c3 3e a5 0a 34 20 00 3b}}
    set image_freeze {freeze.gif {47 49 46 38 39 61 10 00 2e 00 f7 00 00 00 00 00 00 00 55 00 00 aa 00 00 ff 00 24 00 00 24 55 00 24 aa 00 24 ff 00 49 00 00 49 55 00 49 aa 00 49 ff 00 6d 00 00 6d 55 00 6d aa 00 6d ff 00 92 00 00 92 55 00 92 aa 00 92 ff 00 b6 00 00 b6 55 00 b6 aa 00 b6 ff 00 db 00 00 db 55 00 db aa 00 db ff 00 ff 00 00 ff 55 00 ff aa 00 ff ff 24 00 00 24 00 55 24 00 aa 24 00 ff 24 24 00 24 24 55 24 24 aa 24 24 ff 24 49 00 24 49 55 24 49 aa 24 49 ff 24 6d 00 24 6d 55 24 6d aa 24 6d ff 24 92 00 24 92 55 24 92 aa 24 92 ff 24 b6 00 24 b6 55 24 b6 aa 24 b6 ff 24 db 00 24 db 55 24 db aa 24 db ff 24 ff 00 24 ff 55 24 ff aa 24 ff ff 49 00 00 49 00 55 49 00 aa 49 00 ff 49 24 00 49 24 55 49 24 aa 49 24 ff 49 49 00 49 49 55 49 49 aa 49 49 ff 49 6d 00 49 6d 55 49 6d aa 49 6d ff 49 92 00 49 92 55 49 92 aa 49 92 ff 49 b6 00 49 b6 55 49 b6 aa 49 b6 ff 49 db 00 49 db 55 49 db aa 49 db ff 49 ff 00 49 ff 55 49 ff aa 49 ff ff 6d 00 00 6d 00 55 6d 00 aa 6d 00 ff 6d 24 00 6d 24 55 6d 24 aa 6d 24 ff 6d 49 00 6d 49 55 6d 49 aa 6d 49 ff 6d 6d 00 6d 6d 55 6d 6d aa 6d 6d ff 6d 92 00 6d 92 55 6d 92 aa 6d 92 ff 6d b6 00 6d b6 55 6d b6 aa 6d b6 ff 6d db 00 6d db 55 6d db aa 6d db ff 6d ff 00 6d ff 55 6d ff aa 6d ff ff 92 00 00 92 00 55 92 00 aa 92 00 ff 92 24 00 92 24 55 92 24 aa 92 24 ff 92 49 00 92 49 55 92 49 aa 92 49 ff 92 6d 00 92 6d 55 92 6d aa 92 6d ff 92 92 00 92 92 55 92 92 aa 92 92 ff 92 b6 00 92 b6 55 92 b6 aa 92 b6 ff 92 db 00 92 db 55 92 db aa 92 db ff 92 ff 00 92 ff 55 92 ff aa 92 ff ff b6 00 00 b6 00 55 b6 00 aa b6 00 ff b6 24 00 b6 24 55 b6 24 aa b6 24 ff b6 49 00 b6 49 55 b6 49 aa b6 49 ff b6 6d 00 b6 6d 55 b6 6d aa b6 6d ff b6 92 00 b6 92 55 b6 92 aa b6 92 ff b6 b6 00 b6 b6 55 b6 b6 aa b6 b6 ff b6 db 00 b6 db 55 b6 db aa b6 db ff b6 ff 00 b6 ff 55 b6 ff aa b6 ff ff db 00 00 db 00 55 db 00 aa db 00 ff db 24 00 db 24 55 db 24 aa db 24 ff db 49 00 db 49 55 db 49 aa db 49 ff db 6d 00 db 6d 55 db 6d aa db 6d ff db 92 00 db 92 55 db 92 aa db 92 ff db b6 00 db b6 55 db b6 aa db b6 ff db db 00 db db 55 db db aa db db ff db ff 00 db ff 55 db ff aa db ff ff ff 00 00 ff 00 55 ff 00 aa ff 00 ff ff 24 00 ff 24 55 ff 24 aa ff 24 ff ff 49 00 ff 49 55 ff 49 aa ff 49 ff ff 6d 00 ff 6d 55 ff 6d aa ff 6d ff ff 92 00 ff 92 55 ff 92 aa ff 92 ff ff b6 00 ff b6 55 ff b6 aa ff b6 ff ff db 00 ff db 55 ff db aa ff db ff ff ff 00 ff ff 55 ff ff aa ff ff ff 21 f9 04 01 00 00 ff 00 2c 00 00 00 00 10 00 2e 00 40 08 77 00 ff 09 1c 48 b0 a0 c1 7f 00 00 08 54 78 70 61 c2 87 0d 07 3e 64 18 91 22 c2 86 13 27 46 dc 88 11 22 c7 84 0b 37 2a 1c 69 91 a3 c9 93 28 53 16 1c 89 b0 e4 4a 89 2e 09 82 0c 59 f1 e2 cc 8a 0c 63 ca f4 88 53 e3 41 92 3a 25 1a 0c aa b2 a8 51 94 1e 89 66 24 aa 32 a9 48 87 4c 53 3a ed c9 f3 e8 ce 9c 22 33 3e 45 aa b5 a6 d0 9f 51 69 52 d4 b9 f4 a6 55 94 01 01 00 3b}}
    set image_fromconnect {fromconnect.gif {47 49 46 38 39 61 10 00 52 00 f7 00 00 00 00 00 00 00 55 00 00 aa 00 00 ff 00 24 00 00 24 55 00 24 aa 00 24 ff 00 49 00 00 49 55 00 49 aa 00 49 ff 00 6d 00 00 6d 55 00 6d aa 00 6d ff 00 92 00 00 92 55 00 92 aa 00 92 ff 00 b6 00 00 b6 55 00 b6 aa 00 b6 ff 00 db 00 00 db 55 00 db aa 00 db ff 00 ff 00 00 ff 55 00 ff aa 00 ff ff 24 00 00 24 00 55 24 00 aa 24 00 ff 24 24 00 24 24 55 24 24 aa 24 24 ff 24 49 00 24 49 55 24 49 aa 24 49 ff 24 6d 00 24 6d 55 24 6d aa 24 6d ff 24 92 00 24 92 55 24 92 aa 24 92 ff 24 b6 00 24 b6 55 24 b6 aa 24 b6 ff 24 db 00 24 db 55 24 db aa 24 db ff 24 ff 00 24 ff 55 24 ff aa 24 ff ff 49 00 00 49 00 55 49 00 aa 49 00 ff 49 24 00 49 24 55 49 24 aa 49 24 ff 49 49 00 49 49 55 49 49 aa 49 49 ff 49 6d 00 49 6d 55 49 6d aa 49 6d ff 49 92 00 49 92 55 49 92 aa 49 92 ff 49 b6 00 49 b6 55 49 b6 aa 49 b6 ff 49 db 00 49 db 55 49 db aa 49 db ff 49 ff 00 49 ff 55 49 ff aa 49 ff ff 6d 00 00 6d 00 55 6d 00 aa 6d 00 ff 6d 24 00 6d 24 55 6d 24 aa 6d 24 ff 6d 49 00 6d 49 55 6d 49 aa 6d 49 ff 6d 6d 00 6d 6d 55 6d 6d aa 6d 6d ff 6d 92 00 6d 92 55 6d 92 aa 6d 92 ff 6d b6 00 6d b6 55 6d b6 aa 6d b6 ff 6d db 00 6d db 55 6d db aa 6d db ff 6d ff 00 6d ff 55 6d ff aa 6d ff ff 92 00 00 92 00 55 92 00 aa 92 00 ff 92 24 00 92 24 55 92 24 aa 92 24 ff 92 49 00 92 49 55 92 49 aa 92 49 ff 92 6d 00 92 6d 55 92 6d aa 92 6d ff 92 92 00 92 92 55 92 92 aa 92 92 ff 92 b6 00 92 b6 55 92 b6 aa 92 b6 ff 92 db 00 92 db 55 92 db aa 92 db ff 92 ff 00 92 ff 55 92 ff aa 92 ff ff b6 00 00 b6 00 55 b6 00 aa b6 00 ff b6 24 00 b6 24 55 b6 24 aa b6 24 ff b6 49 00 b6 49 55 b6 49 aa b6 49 ff b6 6d 00 b6 6d 55 b6 6d aa b6 6d ff b6 92 00 b6 92 55 b6 92 aa b6 92 ff b6 b6 00 b6 b6 55 b6 b6 aa b6 b6 ff b6 db 00 b6 db 55 b6 db aa b6 db ff b6 ff 00 b6 ff 55 b6 ff aa b6 ff ff db 00 00 db 00 55 db 00 aa db 00 ff db 24 00 db 24 55 db 24 aa db 24 ff db 49 00 db 49 55 db 49 aa db 49 ff db 6d 00 db 6d 55 db 6d aa db 6d ff db 92 00 db 92 55 db 92 aa db 92 ff db b6 00 db b6 55 db b6 aa db b6 ff db db 00 db db 55 db db aa db db ff db ff 00 db ff 55 db ff aa db ff ff ff 00 00 ff 00 55 ff 00 aa ff 00 ff ff 24 00 ff 24 55 ff 24 aa ff 24 ff ff 49 00 ff 49 55 ff 49 aa ff 49 ff ff 6d 00 ff 6d 55 ff 6d aa ff 6d ff ff 92 00 ff 92 55 ff 92 aa ff 92 ff ff b6 00 ff b6 55 ff b6 aa ff b6 ff ff db 00 ff db 55 ff db aa ff db ff ff ff 00 ff ff 55 ff ff aa ff ff ff 21 f9 04 01 00 00 ff 00 2c 00 00 00 00 10 00 52 00 40 08 b3 00 ff 09 1c 48 b0 a0 c1 83 08 05 02 f8 b7 10 c0 c2 84 0e 23 3e 44 38 91 61 c2 8b 18 33 56 c4 58 71 63 c6 8f 1a 09 7a 2c 28 91 a3 c4 91 03 4f a2 54 28 92 a2 c1 95 0c 4f 82 0c 99 92 a2 4a 98 20 6f c2 ec 68 92 e5 c5 92 3f 67 92 fc 29 93 a8 43 93 40 5f 2a b5 99 f4 e3 ce a2 4c 23 1a 95 3a 15 29 55 a5 57 5d 0e 15 ca f5 e5 cd a0 39 27 3e 6d da 55 e4 51 8b 10 a1 d2 8c 7a 96 ed ce 96 69 c9 6e 75 aa b6 6c ca ba 73 d1 c6 5d d9 56 ef 52 b8 5e cd 56 b5 7b 50 25 c7 b0 72 cd 26 ae c9 78 ef e1 c6 85 f1 02 d6 28 19 32 ca be 60 c5 ba c5 4c f8 62 40 00 3b}}
    set image_fromdisconnect {fromdisconnect.gif {47 49 46 38 39 61 10 00 63 00 f7 00 00 00 00 00 00 00 55 00 00 aa 00 00 ff 00 24 00 00 24 55 00 24 aa 00 24 ff 00 49 00 00 49 55 00 49 aa 00 49 ff 00 6d 00 00 6d 55 00 6d aa 00 6d ff 00 92 00 00 92 55 00 92 aa 00 92 ff 00 b6 00 00 b6 55 00 b6 aa 00 b6 ff 00 db 00 00 db 55 00 db aa 00 db ff 00 ff 00 00 ff 55 00 ff aa 00 ff ff 24 00 00 24 00 55 24 00 aa 24 00 ff 24 24 00 24 24 55 24 24 aa 24 24 ff 24 49 00 24 49 55 24 49 aa 24 49 ff 24 6d 00 24 6d 55 24 6d aa 24 6d ff 24 92 00 24 92 55 24 92 aa 24 92 ff 24 b6 00 24 b6 55 24 b6 aa 24 b6 ff 24 db 00 24 db 55 24 db aa 24 db ff 24 ff 00 24 ff 55 24 ff aa 24 ff ff 49 00 00 49 00 55 49 00 aa 49 00 ff 49 24 00 49 24 55 49 24 aa 49 24 ff 49 49 00 49 49 55 49 49 aa 49 49 ff 49 6d 00 49 6d 55 49 6d aa 49 6d ff 49 92 00 49 92 55 49 92 aa 49 92 ff 49 b6 00 49 b6 55 49 b6 aa 49 b6 ff 49 db 00 49 db 55 49 db aa 49 db ff 49 ff 00 49 ff 55 49 ff aa 49 ff ff 6d 00 00 6d 00 55 6d 00 aa 6d 00 ff 6d 24 00 6d 24 55 6d 24 aa 6d 24 ff 6d 49 00 6d 49 55 6d 49 aa 6d 49 ff 6d 6d 00 6d 6d 55 6d 6d aa 6d 6d ff 6d 92 00 6d 92 55 6d 92 aa 6d 92 ff 6d b6 00 6d b6 55 6d b6 aa 6d b6 ff 6d db 00 6d db 55 6d db aa 6d db ff 6d ff 00 6d ff 55 6d ff aa 6d ff ff 92 00 00 92 00 55 92 00 aa 92 00 ff 92 24 00 92 24 55 92 24 aa 92 24 ff 92 49 00 92 49 55 92 49 aa 92 49 ff 92 6d 00 92 6d 55 92 6d aa 92 6d ff 92 92 00 92 92 55 92 92 aa 92 92 ff 92 b6 00 92 b6 55 92 b6 aa 92 b6 ff 92 db 00 92 db 55 92 db aa 92 db ff 92 ff 00 92 ff 55 92 ff aa 92 ff ff b6 00 00 b6 00 55 b6 00 aa b6 00 ff b6 24 00 b6 24 55 b6 24 aa b6 24 ff b6 49 00 b6 49 55 b6 49 aa b6 49 ff b6 6d 00 b6 6d 55 b6 6d aa b6 6d ff b6 92 00 b6 92 55 b6 92 aa b6 92 ff b6 b6 00 b6 b6 55 b6 b6 aa b6 b6 ff b6 db 00 b6 db 55 b6 db aa b6 db ff b6 ff 00 b6 ff 55 b6 ff aa b6 ff ff db 00 00 db 00 55 db 00 aa db 00 ff db 24 00 db 24 55 db 24 aa db 24 ff db 49 00 db 49 55 db 49 aa db 49 ff db 6d 00 db 6d 55 db 6d aa db 6d ff db 92 00 db 92 55 db 92 aa db 92 ff db b6 00 db b6 55 db b6 aa db b6 ff db db 00 db db 55 db db aa db db ff db ff 00 db ff 55 db ff aa db ff ff ff 00 00 ff 00 55 ff 00 aa ff 00 ff ff 24 00 ff 24 55 ff 24 aa ff 24 ff ff 49 00 ff 49 55 ff 49 aa ff 49 ff ff 6d 00 ff 6d 55 ff 6d aa ff 6d ff ff 92 00 ff 92 55 ff 92 aa ff 92 ff ff b6 00 ff b6 55 ff b6 aa ff b6 ff ff db 00 ff db 55 ff db aa ff db ff ff ff 00 ff ff 55 ff ff aa ff ff ff 21 f9 04 01 00 00 ff 00 2c 00 00 00 00 10 00 63 00 40 08 d7 00 ff 09 1c 48 b0 a0 c1 7f 00 0e 2a 04 c0 50 60 42 85 08 19 4a 84 18 51 e2 43 88 16 29 22 8c b8 11 e3 44 8c 06 2f 1e 14 a9 51 24 49 8d 28 53 aa 1c 68 b1 a1 ca 93 04 5b c2 64 d9 92 a2 cc 91 09 6f 8e 0c 69 b3 e6 4a 9b 31 17 ca 9c f9 73 28 51 8e 0e 7f f6 cc e8 91 e9 c2 a0 20 95 a6 34 d9 93 a5 54 8f 48 9f 5a c5 09 15 a7 ce a9 4b 3f 0a 75 ea 55 ec d8 a3 15 cd 06 55 cb b3 20 da ab 70 b5 26 2d 4b 36 6e c7 b9 4d df ba 3c 9a 33 eb d9 92 3e e5 a2 fc 3a 38 ac cb b3 87 77 6e cd 5b b2 2b dd b7 2f 1d 97 05 ec 77 67 43 c8 78 63 e6 0c 6c 97 b0 db b6 a0 17 bb 1d 6a 57 73 dd d0 86 f9 72 0e 8d f6 f4 67 d1 21 57 bf 9e 2a db f1 cc c4 40 ef de 26 5d 1a 65 40 00 3b}}
    set image_grant {grant.gif {47 49 46 38 39 61 10 00 2e 00 f7 00 00 00 00 00 00 00 55 00 00 aa 00 00 ff 00 24 00 00 24 55 00 24 aa 00 24 ff 00 49 00 00 49 55 00 49 aa 00 49 ff 00 6d 00 00 6d 55 00 6d aa 00 6d ff 00 92 00 00 92 55 00 92 aa 00 92 ff 00 b6 00 00 b6 55 00 b6 aa 00 b6 ff 00 db 00 00 db 55 00 db aa 00 db ff 00 ff 00 00 ff 55 00 ff aa 00 ff ff 24 00 00 24 00 55 24 00 aa 24 00 ff 24 24 00 24 24 55 24 24 aa 24 24 ff 24 49 00 24 49 55 24 49 aa 24 49 ff 24 6d 00 24 6d 55 24 6d aa 24 6d ff 24 92 00 24 92 55 24 92 aa 24 92 ff 24 b6 00 24 b6 55 24 b6 aa 24 b6 ff 24 db 00 24 db 55 24 db aa 24 db ff 24 ff 00 24 ff 55 24 ff aa 24 ff ff 49 00 00 49 00 55 49 00 aa 49 00 ff 49 24 00 49 24 55 49 24 aa 49 24 ff 49 49 00 49 49 55 49 49 aa 49 49 ff 49 6d 00 49 6d 55 49 6d aa 49 6d ff 49 92 00 49 92 55 49 92 aa 49 92 ff 49 b6 00 49 b6 55 49 b6 aa 49 b6 ff 49 db 00 49 db 55 49 db aa 49 db ff 49 ff 00 49 ff 55 49 ff aa 49 ff ff 6d 00 00 6d 00 55 6d 00 aa 6d 00 ff 6d 24 00 6d 24 55 6d 24 aa 6d 24 ff 6d 49 00 6d 49 55 6d 49 aa 6d 49 ff 6d 6d 00 6d 6d 55 6d 6d aa 6d 6d ff 6d 92 00 6d 92 55 6d 92 aa 6d 92 ff 6d b6 00 6d b6 55 6d b6 aa 6d b6 ff 6d db 00 6d db 55 6d db aa 6d db ff 6d ff 00 6d ff 55 6d ff aa 6d ff ff 92 00 00 92 00 55 92 00 aa 92 00 ff 92 24 00 92 24 55 92 24 aa 92 24 ff 92 49 00 92 49 55 92 49 aa 92 49 ff 92 6d 00 92 6d 55 92 6d aa 92 6d ff 92 92 00 92 92 55 92 92 aa 92 92 ff 92 b6 00 92 b6 55 92 b6 aa 92 b6 ff 92 db 00 92 db 55 92 db aa 92 db ff 92 ff 00 92 ff 55 92 ff aa 92 ff ff b6 00 00 b6 00 55 b6 00 aa b6 00 ff b6 24 00 b6 24 55 b6 24 aa b6 24 ff b6 49 00 b6 49 55 b6 49 aa b6 49 ff b6 6d 00 b6 6d 55 b6 6d aa b6 6d ff b6 92 00 b6 92 55 b6 92 aa b6 92 ff b6 b6 00 b6 b6 55 b6 b6 aa b6 b6 ff b6 db 00 b6 db 55 b6 db aa b6 db ff b6 ff 00 b6 ff 55 b6 ff aa b6 ff ff db 00 00 db 00 55 db 00 aa db 00 ff db 24 00 db 24 55 db 24 aa db 24 ff db 49 00 db 49 55 db 49 aa db 49 ff db 6d 00 db 6d 55 db 6d aa db 6d ff db 92 00 db 92 55 db 92 aa db 92 ff db b6 00 db b6 55 db b6 aa db b6 ff db db 00 db db 55 db db aa db db ff db ff 00 db ff 55 db ff aa db ff ff ff 00 00 ff 00 55 ff 00 aa ff 00 ff ff 24 00 ff 24 55 ff 24 aa ff 24 ff ff 49 00 ff 49 55 ff 49 aa ff 49 ff ff 6d 00 ff 6d 55 ff 6d aa ff 6d ff ff 92 00 ff 92 55 ff 92 aa ff 92 ff ff b6 00 ff b6 55 ff b6 aa ff b6 ff ff db 00 ff db 55 ff db aa ff db ff ff ff 00 ff ff 55 ff ff aa ff ff ff 21 f9 04 01 00 00 ff 00 2c 00 00 00 00 10 00 2e 00 40 08 6b 00 ff 09 1c 48 b0 a0 c1 83 08 0d 02 48 f8 0f 80 c3 87 0c 1f 42 3c e8 90 60 45 86 18 2d 6a 4c 28 f1 22 c6 89 0a 07 4a cc 48 b2 a4 c9 93 02 3b 82 a4 d8 31 e2 46 84 0b 63 7e 7c 89 92 66 ca 88 2b 6b ea dc c9 b3 67 4a 95 0b 39 9a 54 e9 b2 24 51 a3 38 47 0a 55 0a 73 68 4b a1 22 61 56 cc f9 32 68 d0 90 05 af 2a 7c ea 93 64 40 00 3b}}
    set image_lock {lock.gif {47 49 46 38 39 61 10 00 22 00 f7 00 00 00 00 00 00 00 55 00 00 aa 00 00 ff 00 24 00 00 24 55 00 24 aa 00 24 ff 00 49 00 00 49 55 00 49 aa 00 49 ff 00 6d 00 00 6d 55 00 6d aa 00 6d ff 00 92 00 00 92 55 00 92 aa 00 92 ff 00 b6 00 00 b6 55 00 b6 aa 00 b6 ff 00 db 00 00 db 55 00 db aa 00 db ff 00 ff 00 00 ff 55 00 ff aa 00 ff ff 24 00 00 24 00 55 24 00 aa 24 00 ff 24 24 00 24 24 55 24 24 aa 24 24 ff 24 49 00 24 49 55 24 49 aa 24 49 ff 24 6d 00 24 6d 55 24 6d aa 24 6d ff 24 92 00 24 92 55 24 92 aa 24 92 ff 24 b6 00 24 b6 55 24 b6 aa 24 b6 ff 24 db 00 24 db 55 24 db aa 24 db ff 24 ff 00 24 ff 55 24 ff aa 24 ff ff 49 00 00 49 00 55 49 00 aa 49 00 ff 49 24 00 49 24 55 49 24 aa 49 24 ff 49 49 00 49 49 55 49 49 aa 49 49 ff 49 6d 00 49 6d 55 49 6d aa 49 6d ff 49 92 00 49 92 55 49 92 aa 49 92 ff 49 b6 00 49 b6 55 49 b6 aa 49 b6 ff 49 db 00 49 db 55 49 db aa 49 db ff 49 ff 00 49 ff 55 49 ff aa 49 ff ff 6d 00 00 6d 00 55 6d 00 aa 6d 00 ff 6d 24 00 6d 24 55 6d 24 aa 6d 24 ff 6d 49 00 6d 49 55 6d 49 aa 6d 49 ff 6d 6d 00 6d 6d 55 6d 6d aa 6d 6d ff 6d 92 00 6d 92 55 6d 92 aa 6d 92 ff 6d b6 00 6d b6 55 6d b6 aa 6d b6 ff 6d db 00 6d db 55 6d db aa 6d db ff 6d ff 00 6d ff 55 6d ff aa 6d ff ff 92 00 00 92 00 55 92 00 aa 92 00 ff 92 24 00 92 24 55 92 24 aa 92 24 ff 92 49 00 92 49 55 92 49 aa 92 49 ff 92 6d 00 92 6d 55 92 6d aa 92 6d ff 92 92 00 92 92 55 92 92 aa 92 92 ff 92 b6 00 92 b6 55 92 b6 aa 92 b6 ff 92 db 00 92 db 55 92 db aa 92 db ff 92 ff 00 92 ff 55 92 ff aa 92 ff ff b6 00 00 b6 00 55 b6 00 aa b6 00 ff b6 24 00 b6 24 55 b6 24 aa b6 24 ff b6 49 00 b6 49 55 b6 49 aa b6 49 ff b6 6d 00 b6 6d 55 b6 6d aa b6 6d ff b6 92 00 b6 92 55 b6 92 aa b6 92 ff b6 b6 00 b6 b6 55 b6 b6 aa b6 b6 ff b6 db 00 b6 db 55 b6 db aa b6 db ff b6 ff 00 b6 ff 55 b6 ff aa b6 ff ff db 00 00 db 00 55 db 00 aa db 00 ff db 24 00 db 24 55 db 24 aa db 24 ff db 49 00 db 49 55 db 49 aa db 49 ff db 6d 00 db 6d 55 db 6d aa db 6d ff db 92 00 db 92 55 db 92 aa db 92 ff db b6 00 db b6 55 db b6 aa db b6 ff db db 00 db db 55 db db aa db db ff db ff 00 db ff 55 db ff aa db ff ff ff 00 00 ff 00 55 ff 00 aa ff 00 ff ff 24 00 ff 24 55 ff 24 aa ff 24 ff ff 49 00 ff 49 55 ff 49 aa ff 49 ff ff 6d 00 ff 6d 55 ff 6d aa ff 6d ff ff 92 00 ff 92 55 ff 92 aa ff 92 ff ff b6 00 ff b6 55 ff b6 aa ff b6 ff ff db 00 ff db 55 ff db aa ff db ff ff ff 00 ff ff 55 ff ff aa ff ff ff 21 f9 04 01 00 00 ff 00 2c 00 00 00 00 10 00 22 00 40 08 5c 00 ff 09 1c 48 b0 a0 c1 81 00 00 fc 53 78 10 61 42 86 0d 0b 26 8c 48 b1 a2 c5 8b 08 09 42 94 f8 b0 23 46 8b 10 27 1a ec 48 92 e2 c6 8d 07 3d 9a 2c 89 11 65 46 89 1f 63 56 3c 39 73 a1 4b 81 24 55 c2 1c b9 f2 65 c3 9c 32 23 02 15 aa 71 e6 c3 98 37 17 f2 4c 99 33 69 50 8a 01 01 00 3b}}
    set image_modify {modify.gif {47 49 46 38 39 61 11 00 30 00 f7 00 00 05 05 05 fb fb fb 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 00 00 00 21 f9 04 01 00 00 ff 00 2c 00 00 00 00 11 00 30 00 40 08 83 00 ff 09 1c 48 b0 a0 41 81 00 12 16 04 b0 90 61 c2 87 0c 0f 0e 84 a8 50 e2 c4 87 16 09 52 cc f8 0f 23 47 8a 1e 39 4e fc b8 51 22 c8 8a 07 23 6a 14 c9 d2 20 c4 94 0e 5b 22 5c 99 51 65 47 93 27 6d ca b4 68 53 27 cd 9f 3c 7d ba 44 79 73 a7 d1 8f 47 3b 0a 6d e8 71 69 d1 85 50 9f 4a 65 5a b2 e5 52 85 20 93 0e 3d 69 72 a6 57 92 44 83 86 4d 09 14 e6 4b ad 54 cf e2 2c 2b b6 66 48 b1 55 d1 ca 0c 08 00 3b}}
    set image_modifyform {modifyform.gif {47 49 46 38 39 61 10 00 4d 00 f7 00 00 00 00 00 00 00 55 00 00 aa 00 00 ff 00 24 00 00 24 55 00 24 aa 00 24 ff 00 49 00 00 49 55 00 49 aa 00 49 ff 00 6d 00 00 6d 55 00 6d aa 00 6d ff 00 92 00 00 92 55 00 92 aa 00 92 ff 00 b6 00 00 b6 55 00 b6 aa 00 b6 ff 00 db 00 00 db 55 00 db aa 00 db ff 00 ff 00 00 ff 55 00 ff aa 00 ff ff 24 00 00 24 00 55 24 00 aa 24 00 ff 24 24 00 24 24 55 24 24 aa 24 24 ff 24 49 00 24 49 55 24 49 aa 24 49 ff 24 6d 00 24 6d 55 24 6d aa 24 6d ff 24 92 00 24 92 55 24 92 aa 24 92 ff 24 b6 00 24 b6 55 24 b6 aa 24 b6 ff 24 db 00 24 db 55 24 db aa 24 db ff 24 ff 00 24 ff 55 24 ff aa 24 ff ff 49 00 00 49 00 55 49 00 aa 49 00 ff 49 24 00 49 24 55 49 24 aa 49 24 ff 49 49 00 49 49 55 49 49 aa 49 49 ff 49 6d 00 49 6d 55 49 6d aa 49 6d ff 49 92 00 49 92 55 49 92 aa 49 92 ff 49 b6 00 49 b6 55 49 b6 aa 49 b6 ff 49 db 00 49 db 55 49 db aa 49 db ff 49 ff 00 49 ff 55 49 ff aa 49 ff ff 6d 00 00 6d 00 55 6d 00 aa 6d 00 ff 6d 24 00 6d 24 55 6d 24 aa 6d 24 ff 6d 49 00 6d 49 55 6d 49 aa 6d 49 ff 6d 6d 00 6d 6d 55 6d 6d aa 6d 6d ff 6d 92 00 6d 92 55 6d 92 aa 6d 92 ff 6d b6 00 6d b6 55 6d b6 aa 6d b6 ff 6d db 00 6d db 55 6d db aa 6d db ff 6d ff 00 6d ff 55 6d ff aa 6d ff ff 92 00 00 92 00 55 92 00 aa 92 00 ff 92 24 00 92 24 55 92 24 aa 92 24 ff 92 49 00 92 49 55 92 49 aa 92 49 ff 92 6d 00 92 6d 55 92 6d aa 92 6d ff 92 92 00 92 92 55 92 92 aa 92 92 ff 92 b6 00 92 b6 55 92 b6 aa 92 b6 ff 92 db 00 92 db 55 92 db aa 92 db ff 92 ff 00 92 ff 55 92 ff aa 92 ff ff b6 00 00 b6 00 55 b6 00 aa b6 00 ff b6 24 00 b6 24 55 b6 24 aa b6 24 ff b6 49 00 b6 49 55 b6 49 aa b6 49 ff b6 6d 00 b6 6d 55 b6 6d aa b6 6d ff b6 92 00 b6 92 55 b6 92 aa b6 92 ff b6 b6 00 b6 b6 55 b6 b6 aa b6 b6 ff b6 db 00 b6 db 55 b6 db aa b6 db ff b6 ff 00 b6 ff 55 b6 ff aa b6 ff ff db 00 00 db 00 55 db 00 aa db 00 ff db 24 00 db 24 55 db 24 aa db 24 ff db 49 00 db 49 55 db 49 aa db 49 ff db 6d 00 db 6d 55 db 6d aa db 6d ff db 92 00 db 92 55 db 92 aa db 92 ff db b6 00 db b6 55 db b6 aa db b6 ff db db 00 db db 55 db db aa db db ff db ff 00 db ff 55 db ff aa db ff ff ff 00 00 ff 00 55 ff 00 aa ff 00 ff ff 24 00 ff 24 55 ff 24 aa ff 24 ff ff 49 00 ff 49 55 ff 49 aa ff 49 ff ff 6d 00 ff 6d 55 ff 6d aa ff 6d ff ff 92 00 ff 92 55 ff 92 aa ff 92 ff ff b6 00 ff b6 55 ff b6 aa ff b6 ff ff db 00 ff db 55 ff db aa ff db ff ff ff 00 ff ff 55 ff ff aa ff ff ff 21 f9 04 01 00 00 ff 00 2c 00 00 00 00 10 00 4d 00 40 08 b6 00 ff 09 1c 48 b0 a0 c1 7f 00 12 2a 3c 38 50 e1 42 86 02 1d 42 8c 38 91 22 42 82 00 2a 6a c4 f8 f0 a0 43 89 1e 3f 26 9c 28 92 24 46 92 1f 19 66 bc 68 51 25 c8 95 15 61 9e 64 49 d3 25 c8 98 23 37 ea dc 29 13 e5 4d 8f 33 77 42 94 d9 b3 61 51 9b 29 35 e6 1c 0a 94 63 49 83 23 9f 16 14 d9 11 69 cc a0 42 a1 12 1d 5a 35 ab d7 ab 5c 7f 6a 15 3b 95 67 52 95 66 c9 62 3d ea 94 6d 43 ac 63 bb 7e cd 28 77 2a 55 b4 65 c3 0a 55 1b 71 69 4b 84 74 37 52 75 5b f3 68 d4 b3 4d ff 82 b5 7b 37 6c dd b9 88 a1 c2 8d cb 34 6f 5c be 46 75 46 36 ba 35 f1 db af 01 01 00 3b}}
    set image_override {override.gif {47 49 46 38 39 61 10 00 39 00 f7 00 00 00 00 00 00 00 55 00 00 aa 00 00 ff 00 24 00 00 24 55 00 24 aa 00 24 ff 00 49 00 00 49 55 00 49 aa 00 49 ff 00 6d 00 00 6d 55 00 6d aa 00 6d ff 00 92 00 00 92 55 00 92 aa 00 92 ff 00 b6 00 00 b6 55 00 b6 aa 00 b6 ff 00 db 00 00 db 55 00 db aa 00 db ff 00 ff 00 00 ff 55 00 ff aa 00 ff ff 24 00 00 24 00 55 24 00 aa 24 00 ff 24 24 00 24 24 55 24 24 aa 24 24 ff 24 49 00 24 49 55 24 49 aa 24 49 ff 24 6d 00 24 6d 55 24 6d aa 24 6d ff 24 92 00 24 92 55 24 92 aa 24 92 ff 24 b6 00 24 b6 55 24 b6 aa 24 b6 ff 24 db 00 24 db 55 24 db aa 24 db ff 24 ff 00 24 ff 55 24 ff aa 24 ff ff 49 00 00 49 00 55 49 00 aa 49 00 ff 49 24 00 49 24 55 49 24 aa 49 24 ff 49 49 00 49 49 55 49 49 aa 49 49 ff 49 6d 00 49 6d 55 49 6d aa 49 6d ff 49 92 00 49 92 55 49 92 aa 49 92 ff 49 b6 00 49 b6 55 49 b6 aa 49 b6 ff 49 db 00 49 db 55 49 db aa 49 db ff 49 ff 00 49 ff 55 49 ff aa 49 ff ff 6d 00 00 6d 00 55 6d 00 aa 6d 00 ff 6d 24 00 6d 24 55 6d 24 aa 6d 24 ff 6d 49 00 6d 49 55 6d 49 aa 6d 49 ff 6d 6d 00 6d 6d 55 6d 6d aa 6d 6d ff 6d 92 00 6d 92 55 6d 92 aa 6d 92 ff 6d b6 00 6d b6 55 6d b6 aa 6d b6 ff 6d db 00 6d db 55 6d db aa 6d db ff 6d ff 00 6d ff 55 6d ff aa 6d ff ff 92 00 00 92 00 55 92 00 aa 92 00 ff 92 24 00 92 24 55 92 24 aa 92 24 ff 92 49 00 92 49 55 92 49 aa 92 49 ff 92 6d 00 92 6d 55 92 6d aa 92 6d ff 92 92 00 92 92 55 92 92 aa 92 92 ff 92 b6 00 92 b6 55 92 b6 aa 92 b6 ff 92 db 00 92 db 55 92 db aa 92 db ff 92 ff 00 92 ff 55 92 ff aa 92 ff ff b6 00 00 b6 00 55 b6 00 aa b6 00 ff b6 24 00 b6 24 55 b6 24 aa b6 24 ff b6 49 00 b6 49 55 b6 49 aa b6 49 ff b6 6d 00 b6 6d 55 b6 6d aa b6 6d ff b6 92 00 b6 92 55 b6 92 aa b6 92 ff b6 b6 00 b6 b6 55 b6 b6 aa b6 b6 ff b6 db 00 b6 db 55 b6 db aa b6 db ff b6 ff 00 b6 ff 55 b6 ff aa b6 ff ff db 00 00 db 00 55 db 00 aa db 00 ff db 24 00 db 24 55 db 24 aa db 24 ff db 49 00 db 49 55 db 49 aa db 49 ff db 6d 00 db 6d 55 db 6d aa db 6d ff db 92 00 db 92 55 db 92 aa db 92 ff db b6 00 db b6 55 db b6 aa db b6 ff db db 00 db db 55 db db aa db db ff db ff 00 db ff 55 db ff aa db ff ff ff 00 00 ff 00 55 ff 00 aa ff 00 ff ff 24 00 ff 24 55 ff 24 aa ff 24 ff ff 49 00 ff 49 55 ff 49 aa ff 49 ff ff 6d 00 ff 6d 55 ff 6d aa ff 6d ff ff 92 00 ff 92 55 ff 92 aa ff 92 ff ff b6 00 ff b6 55 ff b6 aa ff b6 ff ff db 00 ff db 55 ff db aa ff db ff ff ff 00 ff ff 55 ff ff aa ff ff ff 21 f9 04 01 00 00 ff 00 2c 00 00 00 00 10 00 39 00 40 08 8e 00 ff 09 1c 48 b0 a0 c1 7f 00 12 2a 3c 48 50 21 00 86 03 1d 26 84 28 70 22 42 8a 0d 1f 1e d4 d8 10 a3 c7 8f 11 25 2e 84 c8 f1 22 49 89 18 1d 82 f4 28 72 25 4b 8b 25 5d 46 ac 38 73 e3 c3 96 24 3b e6 04 59 32 66 c1 9b 08 7d ea fc a8 92 22 ce 8d 06 85 ca 5c 2a 13 a6 d1 8b 16 4f 46 25 6a 53 a4 d2 8a 28 79 da 0c 5a 94 e1 d5 a4 59 bd 0e 45 5a d3 6b 58 a6 19 35 7e 3d 8a 36 e4 54 b3 5d c9 12 1d 69 36 a3 d8 9f 75 43 1a a5 cb 34 20 00 3b}}
    set image_promote {promote.gif {47 49 46 38 39 61 10 00 36 00 f7 00 00 00 00 00 00 00 55 00 00 aa 00 00 ff 00 24 00 00 24 55 00 24 aa 00 24 ff 00 49 00 00 49 55 00 49 aa 00 49 ff 00 6d 00 00 6d 55 00 6d aa 00 6d ff 00 92 00 00 92 55 00 92 aa 00 92 ff 00 b6 00 00 b6 55 00 b6 aa 00 b6 ff 00 db 00 00 db 55 00 db aa 00 db ff 00 ff 00 00 ff 55 00 ff aa 00 ff ff 24 00 00 24 00 55 24 00 aa 24 00 ff 24 24 00 24 24 55 24 24 aa 24 24 ff 24 49 00 24 49 55 24 49 aa 24 49 ff 24 6d 00 24 6d 55 24 6d aa 24 6d ff 24 92 00 24 92 55 24 92 aa 24 92 ff 24 b6 00 24 b6 55 24 b6 aa 24 b6 ff 24 db 00 24 db 55 24 db aa 24 db ff 24 ff 00 24 ff 55 24 ff aa 24 ff ff 49 00 00 49 00 55 49 00 aa 49 00 ff 49 24 00 49 24 55 49 24 aa 49 24 ff 49 49 00 49 49 55 49 49 aa 49 49 ff 49 6d 00 49 6d 55 49 6d aa 49 6d ff 49 92 00 49 92 55 49 92 aa 49 92 ff 49 b6 00 49 b6 55 49 b6 aa 49 b6 ff 49 db 00 49 db 55 49 db aa 49 db ff 49 ff 00 49 ff 55 49 ff aa 49 ff ff 6d 00 00 6d 00 55 6d 00 aa 6d 00 ff 6d 24 00 6d 24 55 6d 24 aa 6d 24 ff 6d 49 00 6d 49 55 6d 49 aa 6d 49 ff 6d 6d 00 6d 6d 55 6d 6d aa 6d 6d ff 6d 92 00 6d 92 55 6d 92 aa 6d 92 ff 6d b6 00 6d b6 55 6d b6 aa 6d b6 ff 6d db 00 6d db 55 6d db aa 6d db ff 6d ff 00 6d ff 55 6d ff aa 6d ff ff 92 00 00 92 00 55 92 00 aa 92 00 ff 92 24 00 92 24 55 92 24 aa 92 24 ff 92 49 00 92 49 55 92 49 aa 92 49 ff 92 6d 00 92 6d 55 92 6d aa 92 6d ff 92 92 00 92 92 55 92 92 aa 92 92 ff 92 b6 00 92 b6 55 92 b6 aa 92 b6 ff 92 db 00 92 db 55 92 db aa 92 db ff 92 ff 00 92 ff 55 92 ff aa 92 ff ff b6 00 00 b6 00 55 b6 00 aa b6 00 ff b6 24 00 b6 24 55 b6 24 aa b6 24 ff b6 49 00 b6 49 55 b6 49 aa b6 49 ff b6 6d 00 b6 6d 55 b6 6d aa b6 6d ff b6 92 00 b6 92 55 b6 92 aa b6 92 ff b6 b6 00 b6 b6 55 b6 b6 aa b6 b6 ff b6 db 00 b6 db 55 b6 db aa b6 db ff b6 ff 00 b6 ff 55 b6 ff aa b6 ff ff db 00 00 db 00 55 db 00 aa db 00 ff db 24 00 db 24 55 db 24 aa db 24 ff db 49 00 db 49 55 db 49 aa db 49 ff db 6d 00 db 6d 55 db 6d aa db 6d ff db 92 00 db 92 55 db 92 aa db 92 ff db b6 00 db b6 55 db b6 aa db b6 ff db db 00 db db 55 db db aa db db ff db ff 00 db ff 55 db ff aa db ff ff ff 00 00 ff 00 55 ff 00 aa ff 00 ff ff 24 00 ff 24 55 ff 24 aa ff 24 ff ff 49 00 ff 49 55 ff 49 aa ff 49 ff ff 6d 00 ff 6d 55 ff 6d aa ff 6d ff ff 92 00 ff 92 55 ff 92 aa ff 92 ff ff b6 00 ff b6 55 ff b6 aa ff b6 ff ff db 00 ff db 55 ff db aa ff db ff ff ff 00 ff ff 55 ff ff aa ff ff ff 21 f9 04 01 00 00 ff 00 2c 00 00 00 00 10 00 36 00 40 08 84 00 ff 09 1c 48 b0 a0 41 00 08 13 1a 24 98 50 e1 42 81 0d 11 3e 9c 38 11 00 c3 87 11 1d 52 dc f8 2f a3 44 8a 0d 37 5a e4 08 f1 22 c9 93 28 51 3a 1c 89 d1 64 ca 96 03 59 72 94 79 30 22 48 9b 15 71 e6 fc b8 53 63 41 9d 30 5d be 1c fa 73 24 cd 9f 1d 3b 1e 2d ca b3 66 46 90 29 43 42 8d 79 53 2a 51 a6 3e 17 2e d5 0a d4 69 56 a4 54 ab 6e 0d 5b b2 67 d3 83 2a bb 82 2d cb 75 2c 59 a3 18 3d 5e 7d 19 10 00 3b}}
    set image_read {read.gif {47 49 46 38 39 61 10 00 22 00 f7 00 00 00 00 00 00 00 55 00 00 aa 00 00 ff 00 24 00 00 24 55 00 24 aa 00 24 ff 00 49 00 00 49 55 00 49 aa 00 49 ff 00 6d 00 00 6d 55 00 6d aa 00 6d ff 00 92 00 00 92 55 00 92 aa 00 92 ff 00 b6 00 00 b6 55 00 b6 aa 00 b6 ff 00 db 00 00 db 55 00 db aa 00 db ff 00 ff 00 00 ff 55 00 ff aa 00 ff ff 24 00 00 24 00 55 24 00 aa 24 00 ff 24 24 00 24 24 55 24 24 aa 24 24 ff 24 49 00 24 49 55 24 49 aa 24 49 ff 24 6d 00 24 6d 55 24 6d aa 24 6d ff 24 92 00 24 92 55 24 92 aa 24 92 ff 24 b6 00 24 b6 55 24 b6 aa 24 b6 ff 24 db 00 24 db 55 24 db aa 24 db ff 24 ff 00 24 ff 55 24 ff aa 24 ff ff 49 00 00 49 00 55 49 00 aa 49 00 ff 49 24 00 49 24 55 49 24 aa 49 24 ff 49 49 00 49 49 55 49 49 aa 49 49 ff 49 6d 00 49 6d 55 49 6d aa 49 6d ff 49 92 00 49 92 55 49 92 aa 49 92 ff 49 b6 00 49 b6 55 49 b6 aa 49 b6 ff 49 db 00 49 db 55 49 db aa 49 db ff 49 ff 00 49 ff 55 49 ff aa 49 ff ff 6d 00 00 6d 00 55 6d 00 aa 6d 00 ff 6d 24 00 6d 24 55 6d 24 aa 6d 24 ff 6d 49 00 6d 49 55 6d 49 aa 6d 49 ff 6d 6d 00 6d 6d 55 6d 6d aa 6d 6d ff 6d 92 00 6d 92 55 6d 92 aa 6d 92 ff 6d b6 00 6d b6 55 6d b6 aa 6d b6 ff 6d db 00 6d db 55 6d db aa 6d db ff 6d ff 00 6d ff 55 6d ff aa 6d ff ff 92 00 00 92 00 55 92 00 aa 92 00 ff 92 24 00 92 24 55 92 24 aa 92 24 ff 92 49 00 92 49 55 92 49 aa 92 49 ff 92 6d 00 92 6d 55 92 6d aa 92 6d ff 92 92 00 92 92 55 92 92 aa 92 92 ff 92 b6 00 92 b6 55 92 b6 aa 92 b6 ff 92 db 00 92 db 55 92 db aa 92 db ff 92 ff 00 92 ff 55 92 ff aa 92 ff ff b6 00 00 b6 00 55 b6 00 aa b6 00 ff b6 24 00 b6 24 55 b6 24 aa b6 24 ff b6 49 00 b6 49 55 b6 49 aa b6 49 ff b6 6d 00 b6 6d 55 b6 6d aa b6 6d ff b6 92 00 b6 92 55 b6 92 aa b6 92 ff b6 b6 00 b6 b6 55 b6 b6 aa b6 b6 ff b6 db 00 b6 db 55 b6 db aa b6 db ff b6 ff 00 b6 ff 55 b6 ff aa b6 ff ff db 00 00 db 00 55 db 00 aa db 00 ff db 24 00 db 24 55 db 24 aa db 24 ff db 49 00 db 49 55 db 49 aa db 49 ff db 6d 00 db 6d 55 db 6d aa db 6d ff db 92 00 db 92 55 db 92 aa db 92 ff db b6 00 db b6 55 db b6 aa db b6 ff db db 00 db db 55 db db aa db db ff db ff 00 db ff 55 db ff aa db ff ff ff 00 00 ff 00 55 ff 00 aa ff 00 ff ff 24 00 ff 24 55 ff 24 aa ff 24 ff ff 49 00 ff 49 55 ff 49 aa ff 49 ff ff 6d 00 ff 6d 55 ff 6d aa ff 6d ff ff 92 00 ff 92 55 ff 92 aa ff 92 ff ff b6 00 ff b6 55 ff b6 aa ff b6 ff ff db 00 ff db 55 ff db aa ff db ff ff ff 00 ff ff 55 ff ff aa ff ff ff 21 f9 04 01 00 00 ff 00 2c 00 00 00 00 10 00 22 00 40 08 63 00 ff 09 1c 48 b0 a0 c1 7f 00 12 2a 3c c8 b0 21 42 00 03 13 3a 9c e8 10 62 43 85 0b 2f 62 b4 68 70 63 46 8a 1a 3d 72 a4 38 b2 e3 43 89 21 05 96 04 69 52 e5 4a 82 2b 5f b2 9c 19 51 e4 4b 8b 1c 65 c2 fc c8 d0 63 45 84 40 41 f2 3c 88 52 27 50 88 28 43 1a 6d d9 71 e1 d0 88 50 83 36 f5 49 b3 aa c0 80 00 3b}}
    set image_revise {revise.gif {47 49 46 38 39 61 10 00 2b 00 f7 00 00 00 00 00 00 00 55 00 00 aa 00 00 ff 00 24 00 00 24 55 00 24 aa 00 24 ff 00 49 00 00 49 55 00 49 aa 00 49 ff 00 6d 00 00 6d 55 00 6d aa 00 6d ff 00 92 00 00 92 55 00 92 aa 00 92 ff 00 b6 00 00 b6 55 00 b6 aa 00 b6 ff 00 db 00 00 db 55 00 db aa 00 db ff 00 ff 00 00 ff 55 00 ff aa 00 ff ff 24 00 00 24 00 55 24 00 aa 24 00 ff 24 24 00 24 24 55 24 24 aa 24 24 ff 24 49 00 24 49 55 24 49 aa 24 49 ff 24 6d 00 24 6d 55 24 6d aa 24 6d ff 24 92 00 24 92 55 24 92 aa 24 92 ff 24 b6 00 24 b6 55 24 b6 aa 24 b6 ff 24 db 00 24 db 55 24 db aa 24 db ff 24 ff 00 24 ff 55 24 ff aa 24 ff ff 49 00 00 49 00 55 49 00 aa 49 00 ff 49 24 00 49 24 55 49 24 aa 49 24 ff 49 49 00 49 49 55 49 49 aa 49 49 ff 49 6d 00 49 6d 55 49 6d aa 49 6d ff 49 92 00 49 92 55 49 92 aa 49 92 ff 49 b6 00 49 b6 55 49 b6 aa 49 b6 ff 49 db 00 49 db 55 49 db aa 49 db ff 49 ff 00 49 ff 55 49 ff aa 49 ff ff 6d 00 00 6d 00 55 6d 00 aa 6d 00 ff 6d 24 00 6d 24 55 6d 24 aa 6d 24 ff 6d 49 00 6d 49 55 6d 49 aa 6d 49 ff 6d 6d 00 6d 6d 55 6d 6d aa 6d 6d ff 6d 92 00 6d 92 55 6d 92 aa 6d 92 ff 6d b6 00 6d b6 55 6d b6 aa 6d b6 ff 6d db 00 6d db 55 6d db aa 6d db ff 6d ff 00 6d ff 55 6d ff aa 6d ff ff 92 00 00 92 00 55 92 00 aa 92 00 ff 92 24 00 92 24 55 92 24 aa 92 24 ff 92 49 00 92 49 55 92 49 aa 92 49 ff 92 6d 00 92 6d 55 92 6d aa 92 6d ff 92 92 00 92 92 55 92 92 aa 92 92 ff 92 b6 00 92 b6 55 92 b6 aa 92 b6 ff 92 db 00 92 db 55 92 db aa 92 db ff 92 ff 00 92 ff 55 92 ff aa 92 ff ff b6 00 00 b6 00 55 b6 00 aa b6 00 ff b6 24 00 b6 24 55 b6 24 aa b6 24 ff b6 49 00 b6 49 55 b6 49 aa b6 49 ff b6 6d 00 b6 6d 55 b6 6d aa b6 6d ff b6 92 00 b6 92 55 b6 92 aa b6 92 ff b6 b6 00 b6 b6 55 b6 b6 aa b6 b6 ff b6 db 00 b6 db 55 b6 db aa b6 db ff b6 ff 00 b6 ff 55 b6 ff aa b6 ff ff db 00 00 db 00 55 db 00 aa db 00 ff db 24 00 db 24 55 db 24 aa db 24 ff db 49 00 db 49 55 db 49 aa db 49 ff db 6d 00 db 6d 55 db 6d aa db 6d ff db 92 00 db 92 55 db 92 aa db 92 ff db b6 00 db b6 55 db b6 aa db b6 ff db db 00 db db 55 db db aa db db ff db ff 00 db ff 55 db ff aa db ff ff ff 00 00 ff 00 55 ff 00 aa ff 00 ff ff 24 00 ff 24 55 ff 24 aa ff 24 ff ff 49 00 ff 49 55 ff 49 aa ff 49 ff ff 6d 00 ff 6d 55 ff 6d aa ff 6d ff ff 92 00 ff 92 55 ff 92 aa ff 92 ff ff b6 00 ff b6 55 ff b6 aa ff b6 ff ff db 00 ff db 55 ff db aa ff db ff ff ff 00 ff ff 55 ff ff aa ff ff ff 21 f9 04 01 00 00 ff 00 2c 00 00 00 00 10 00 2b 00 40 08 75 00 ff 09 1c 48 b0 a0 41 81 00 12 02 38 f8 2f 61 43 85 0e 19 36 94 48 71 62 c5 8b 03 23 2e 94 b8 d0 e1 46 86 10 2f 76 7c 08 32 23 42 8c 18 47 46 04 d9 f1 63 4a 94 22 21 ba 3c a8 b1 62 48 96 1e 57 16 94 a9 10 a6 cf 9f 14 7b 5a c4 29 14 a8 c1 96 43 59 92 3c da f2 66 49 93 1c 8d ea 64 3a d5 28 41 a1 33 77 ca b4 aa 35 63 d6 93 08 bf 7a e5 f9 f4 aa d5 80 00 3b}}
    set image_revoke {revoke.gif {47 49 46 38 39 61 10 00 32 00 f7 00 00 00 00 00 00 00 55 00 00 aa 00 00 ff 00 24 00 00 24 55 00 24 aa 00 24 ff 00 49 00 00 49 55 00 49 aa 00 49 ff 00 6d 00 00 6d 55 00 6d aa 00 6d ff 00 92 00 00 92 55 00 92 aa 00 92 ff 00 b6 00 00 b6 55 00 b6 aa 00 b6 ff 00 db 00 00 db 55 00 db aa 00 db ff 00 ff 00 00 ff 55 00 ff aa 00 ff ff 24 00 00 24 00 55 24 00 aa 24 00 ff 24 24 00 24 24 55 24 24 aa 24 24 ff 24 49 00 24 49 55 24 49 aa 24 49 ff 24 6d 00 24 6d 55 24 6d aa 24 6d ff 24 92 00 24 92 55 24 92 aa 24 92 ff 24 b6 00 24 b6 55 24 b6 aa 24 b6 ff 24 db 00 24 db 55 24 db aa 24 db ff 24 ff 00 24 ff 55 24 ff aa 24 ff ff 49 00 00 49 00 55 49 00 aa 49 00 ff 49 24 00 49 24 55 49 24 aa 49 24 ff 49 49 00 49 49 55 49 49 aa 49 49 ff 49 6d 00 49 6d 55 49 6d aa 49 6d ff 49 92 00 49 92 55 49 92 aa 49 92 ff 49 b6 00 49 b6 55 49 b6 aa 49 b6 ff 49 db 00 49 db 55 49 db aa 49 db ff 49 ff 00 49 ff 55 49 ff aa 49 ff ff 6d 00 00 6d 00 55 6d 00 aa 6d 00 ff 6d 24 00 6d 24 55 6d 24 aa 6d 24 ff 6d 49 00 6d 49 55 6d 49 aa 6d 49 ff 6d 6d 00 6d 6d 55 6d 6d aa 6d 6d ff 6d 92 00 6d 92 55 6d 92 aa 6d 92 ff 6d b6 00 6d b6 55 6d b6 aa 6d b6 ff 6d db 00 6d db 55 6d db aa 6d db ff 6d ff 00 6d ff 55 6d ff aa 6d ff ff 92 00 00 92 00 55 92 00 aa 92 00 ff 92 24 00 92 24 55 92 24 aa 92 24 ff 92 49 00 92 49 55 92 49 aa 92 49 ff 92 6d 00 92 6d 55 92 6d aa 92 6d ff 92 92 00 92 92 55 92 92 aa 92 92 ff 92 b6 00 92 b6 55 92 b6 aa 92 b6 ff 92 db 00 92 db 55 92 db aa 92 db ff 92 ff 00 92 ff 55 92 ff aa 92 ff ff b6 00 00 b6 00 55 b6 00 aa b6 00 ff b6 24 00 b6 24 55 b6 24 aa b6 24 ff b6 49 00 b6 49 55 b6 49 aa b6 49 ff b6 6d 00 b6 6d 55 b6 6d aa b6 6d ff b6 92 00 b6 92 55 b6 92 aa b6 92 ff b6 b6 00 b6 b6 55 b6 b6 aa b6 b6 ff b6 db 00 b6 db 55 b6 db aa b6 db ff b6 ff 00 b6 ff 55 b6 ff aa b6 ff ff db 00 00 db 00 55 db 00 aa db 00 ff db 24 00 db 24 55 db 24 aa db 24 ff db 49 00 db 49 55 db 49 aa db 49 ff db 6d 00 db 6d 55 db 6d aa db 6d ff db 92 00 db 92 55 db 92 aa db 92 ff db b6 00 db b6 55 db b6 aa db b6 ff db db 00 db db 55 db db aa db db ff db ff 00 db ff 55 db ff aa db ff ff ff 00 00 ff 00 55 ff 00 aa ff 00 ff ff 24 00 ff 24 55 ff 24 aa ff 24 ff ff 49 00 ff 49 55 ff 49 aa ff 49 ff ff 6d 00 ff 6d 55 ff 6d aa ff 6d ff ff 92 00 ff 92 55 ff 92 aa ff 92 ff ff b6 00 ff b6 55 ff b6 aa ff b6 ff ff db 00 ff db 55 ff db aa ff db ff ff ff 00 ff ff 55 ff ff aa ff ff ff 21 f9 04 01 00 00 ff 00 2c 00 00 00 00 10 00 32 00 40 08 80 00 ff 09 1c 48 b0 a0 c1 7f 00 10 22 4c 68 10 80 c3 87 0f 0f 12 84 28 b1 62 45 87 03 31 5a dc c8 51 22 c3 85 16 21 6a e4 38 f2 a0 c8 8f 05 4f 96 ec 18 92 21 4a 93 11 49 26 7c c9 d2 e4 c4 90 35 29 6e 8c 49 b3 66 c6 8c 3d 7f a6 f4 49 b4 28 4c 97 2d 75 7a bc 89 73 25 50 95 36 1b ee 8c 79 91 a9 47 91 46 8f 06 9d 88 b5 6a 4e a4 55 67 6e 15 a8 b4 63 50 8a 54 87 92 5d ab b5 6c 56 8e 01 01 00 3b}}
    set image_schedule {schedule.gif {47 49 46 38 39 61 10 00 39 00 f7 00 00 00 00 00 00 00 55 00 00 aa 00 00 ff 00 24 00 00 24 55 00 24 aa 00 24 ff 00 49 00 00 49 55 00 49 aa 00 49 ff 00 6d 00 00 6d 55 00 6d aa 00 6d ff 00 92 00 00 92 55 00 92 aa 00 92 ff 00 b6 00 00 b6 55 00 b6 aa 00 b6 ff 00 db 00 00 db 55 00 db aa 00 db ff 00 ff 00 00 ff 55 00 ff aa 00 ff ff 24 00 00 24 00 55 24 00 aa 24 00 ff 24 24 00 24 24 55 24 24 aa 24 24 ff 24 49 00 24 49 55 24 49 aa 24 49 ff 24 6d 00 24 6d 55 24 6d aa 24 6d ff 24 92 00 24 92 55 24 92 aa 24 92 ff 24 b6 00 24 b6 55 24 b6 aa 24 b6 ff 24 db 00 24 db 55 24 db aa 24 db ff 24 ff 00 24 ff 55 24 ff aa 24 ff ff 49 00 00 49 00 55 49 00 aa 49 00 ff 49 24 00 49 24 55 49 24 aa 49 24 ff 49 49 00 49 49 55 49 49 aa 49 49 ff 49 6d 00 49 6d 55 49 6d aa 49 6d ff 49 92 00 49 92 55 49 92 aa 49 92 ff 49 b6 00 49 b6 55 49 b6 aa 49 b6 ff 49 db 00 49 db 55 49 db aa 49 db ff 49 ff 00 49 ff 55 49 ff aa 49 ff ff 6d 00 00 6d 00 55 6d 00 aa 6d 00 ff 6d 24 00 6d 24 55 6d 24 aa 6d 24 ff 6d 49 00 6d 49 55 6d 49 aa 6d 49 ff 6d 6d 00 6d 6d 55 6d 6d aa 6d 6d ff 6d 92 00 6d 92 55 6d 92 aa 6d 92 ff 6d b6 00 6d b6 55 6d b6 aa 6d b6 ff 6d db 00 6d db 55 6d db aa 6d db ff 6d ff 00 6d ff 55 6d ff aa 6d ff ff 92 00 00 92 00 55 92 00 aa 92 00 ff 92 24 00 92 24 55 92 24 aa 92 24 ff 92 49 00 92 49 55 92 49 aa 92 49 ff 92 6d 00 92 6d 55 92 6d aa 92 6d ff 92 92 00 92 92 55 92 92 aa 92 92 ff 92 b6 00 92 b6 55 92 b6 aa 92 b6 ff 92 db 00 92 db 55 92 db aa 92 db ff 92 ff 00 92 ff 55 92 ff aa 92 ff ff b6 00 00 b6 00 55 b6 00 aa b6 00 ff b6 24 00 b6 24 55 b6 24 aa b6 24 ff b6 49 00 b6 49 55 b6 49 aa b6 49 ff b6 6d 00 b6 6d 55 b6 6d aa b6 6d ff b6 92 00 b6 92 55 b6 92 aa b6 92 ff b6 b6 00 b6 b6 55 b6 b6 aa b6 b6 ff b6 db 00 b6 db 55 b6 db aa b6 db ff b6 ff 00 b6 ff 55 b6 ff aa b6 ff ff db 00 00 db 00 55 db 00 aa db 00 ff db 24 00 db 24 55 db 24 aa db 24 ff db 49 00 db 49 55 db 49 aa db 49 ff db 6d 00 db 6d 55 db 6d aa db 6d ff db 92 00 db 92 55 db 92 aa db 92 ff db b6 00 db b6 55 db b6 aa db b6 ff db db 00 db db 55 db db aa db db ff db ff 00 db ff 55 db ff aa db ff ff ff 00 00 ff 00 55 ff 00 aa ff 00 ff ff 24 00 ff 24 55 ff 24 aa ff 24 ff ff 49 00 ff 49 55 ff 49 aa ff 49 ff ff 6d 00 ff 6d 55 ff 6d aa ff 6d ff ff 92 00 ff 92 55 ff 92 aa ff 92 ff ff b6 00 ff b6 55 ff b6 aa ff b6 ff ff db 00 ff db 55 ff db aa ff db ff ff ff 00 ff ff 55 ff ff aa ff ff ff 21 f9 04 01 00 00 ff 00 2c 00 00 00 00 10 00 39 00 40 08 8c 00 ff 09 1c 48 b0 a0 c1 7f 00 12 0a 04 70 b0 21 c3 86 06 1f 3a 54 88 f0 60 c2 8b 18 21 6a dc c8 b1 a3 43 8d 18 29 4e cc e8 51 a2 45 89 26 09 92 ac e8 b1 25 c7 90 29 17 c2 14 79 72 a5 c5 97 33 63 ba 54 19 12 64 cf 88 37 21 c2 fc 88 d0 e6 ce a3 48 77 52 d4 39 90 a1 53 a6 4d 2f 8e 1c 0a b4 ea 54 9a 20 37 52 4d 5a 74 66 50 94 38 b1 9e 5c 98 f5 a9 56 a9 3e 8d 16 84 1a d5 2b 57 95 70 d3 42 5d 2a b6 a9 4c b2 23 bb 26 0d 08 00 3b}}
    set image_show {show.gif {47 49 46 38 39 61 10 00 26 00 f7 00 00 00 00 00 00 00 55 00 00 aa 00 00 ff 00 24 00 00 24 55 00 24 aa 00 24 ff 00 49 00 00 49 55 00 49 aa 00 49 ff 00 6d 00 00 6d 55 00 6d aa 00 6d ff 00 92 00 00 92 55 00 92 aa 00 92 ff 00 b6 00 00 b6 55 00 b6 aa 00 b6 ff 00 db 00 00 db 55 00 db aa 00 db ff 00 ff 00 00 ff 55 00 ff aa 00 ff ff 24 00 00 24 00 55 24 00 aa 24 00 ff 24 24 00 24 24 55 24 24 aa 24 24 ff 24 49 00 24 49 55 24 49 aa 24 49 ff 24 6d 00 24 6d 55 24 6d aa 24 6d ff 24 92 00 24 92 55 24 92 aa 24 92 ff 24 b6 00 24 b6 55 24 b6 aa 24 b6 ff 24 db 00 24 db 55 24 db aa 24 db ff 24 ff 00 24 ff 55 24 ff aa 24 ff ff 49 00 00 49 00 55 49 00 aa 49 00 ff 49 24 00 49 24 55 49 24 aa 49 24 ff 49 49 00 49 49 55 49 49 aa 49 49 ff 49 6d 00 49 6d 55 49 6d aa 49 6d ff 49 92 00 49 92 55 49 92 aa 49 92 ff 49 b6 00 49 b6 55 49 b6 aa 49 b6 ff 49 db 00 49 db 55 49 db aa 49 db ff 49 ff 00 49 ff 55 49 ff aa 49 ff ff 6d 00 00 6d 00 55 6d 00 aa 6d 00 ff 6d 24 00 6d 24 55 6d 24 aa 6d 24 ff 6d 49 00 6d 49 55 6d 49 aa 6d 49 ff 6d 6d 00 6d 6d 55 6d 6d aa 6d 6d ff 6d 92 00 6d 92 55 6d 92 aa 6d 92 ff 6d b6 00 6d b6 55 6d b6 aa 6d b6 ff 6d db 00 6d db 55 6d db aa 6d db ff 6d ff 00 6d ff 55 6d ff aa 6d ff ff 92 00 00 92 00 55 92 00 aa 92 00 ff 92 24 00 92 24 55 92 24 aa 92 24 ff 92 49 00 92 49 55 92 49 aa 92 49 ff 92 6d 00 92 6d 55 92 6d aa 92 6d ff 92 92 00 92 92 55 92 92 aa 92 92 ff 92 b6 00 92 b6 55 92 b6 aa 92 b6 ff 92 db 00 92 db 55 92 db aa 92 db ff 92 ff 00 92 ff 55 92 ff aa 92 ff ff b6 00 00 b6 00 55 b6 00 aa b6 00 ff b6 24 00 b6 24 55 b6 24 aa b6 24 ff b6 49 00 b6 49 55 b6 49 aa b6 49 ff b6 6d 00 b6 6d 55 b6 6d aa b6 6d ff b6 92 00 b6 92 55 b6 92 aa b6 92 ff b6 b6 00 b6 b6 55 b6 b6 aa b6 b6 ff b6 db 00 b6 db 55 b6 db aa b6 db ff b6 ff 00 b6 ff 55 b6 ff aa b6 ff ff db 00 00 db 00 55 db 00 aa db 00 ff db 24 00 db 24 55 db 24 aa db 24 ff db 49 00 db 49 55 db 49 aa db 49 ff db 6d 00 db 6d 55 db 6d aa db 6d ff db 92 00 db 92 55 db 92 aa db 92 ff db b6 00 db b6 55 db b6 aa db b6 ff db db 00 db db 55 db db aa db db ff db ff 00 db ff 55 db ff aa db ff ff ff 00 00 ff 00 55 ff 00 aa ff 00 ff ff 24 00 ff 24 55 ff 24 aa ff 24 ff ff 49 00 ff 49 55 ff 49 aa ff 49 ff ff 6d 00 ff 6d 55 ff 6d aa ff 6d ff ff 92 00 ff 92 55 ff 92 aa ff 92 ff ff b6 00 ff b6 55 ff b6 aa ff b6 ff ff db 00 ff db 55 ff db aa ff db ff ff ff 00 ff ff 55 ff ff aa ff ff ff 21 f9 04 01 00 00 ff 00 2c 00 00 00 00 10 00 26 00 40 08 65 00 ff 09 1c 48 b0 a0 c1 7f 00 12 1e 34 98 b0 21 80 85 02 1f 42 1c e8 90 e2 44 89 13 29 2a cc 18 b1 21 c7 8f 20 43 16 94 e8 91 e3 46 91 10 31 22 bc e8 50 a5 c6 96 27 47 76 2c 89 b2 a6 cd 99 21 2b b2 fc 08 f3 a2 48 9d 29 09 ba 1c d9 32 27 4b a0 42 61 c6 b4 c8 70 e1 46 9a 4d 11 92 4c a9 10 ea 4d 8e 01 01 00 3b}}
    set image_thaw {thaw.gif {47 49 46 38 39 61 10 00 26 00 f7 00 00 00 00 00 00 00 55 00 00 aa 00 00 ff 00 24 00 00 24 55 00 24 aa 00 24 ff 00 49 00 00 49 55 00 49 aa 00 49 ff 00 6d 00 00 6d 55 00 6d aa 00 6d ff 00 92 00 00 92 55 00 92 aa 00 92 ff 00 b6 00 00 b6 55 00 b6 aa 00 b6 ff 00 db 00 00 db 55 00 db aa 00 db ff 00 ff 00 00 ff 55 00 ff aa 00 ff ff 24 00 00 24 00 55 24 00 aa 24 00 ff 24 24 00 24 24 55 24 24 aa 24 24 ff 24 49 00 24 49 55 24 49 aa 24 49 ff 24 6d 00 24 6d 55 24 6d aa 24 6d ff 24 92 00 24 92 55 24 92 aa 24 92 ff 24 b6 00 24 b6 55 24 b6 aa 24 b6 ff 24 db 00 24 db 55 24 db aa 24 db ff 24 ff 00 24 ff 55 24 ff aa 24 ff ff 49 00 00 49 00 55 49 00 aa 49 00 ff 49 24 00 49 24 55 49 24 aa 49 24 ff 49 49 00 49 49 55 49 49 aa 49 49 ff 49 6d 00 49 6d 55 49 6d aa 49 6d ff 49 92 00 49 92 55 49 92 aa 49 92 ff 49 b6 00 49 b6 55 49 b6 aa 49 b6 ff 49 db 00 49 db 55 49 db aa 49 db ff 49 ff 00 49 ff 55 49 ff aa 49 ff ff 6d 00 00 6d 00 55 6d 00 aa 6d 00 ff 6d 24 00 6d 24 55 6d 24 aa 6d 24 ff 6d 49 00 6d 49 55 6d 49 aa 6d 49 ff 6d 6d 00 6d 6d 55 6d 6d aa 6d 6d ff 6d 92 00 6d 92 55 6d 92 aa 6d 92 ff 6d b6 00 6d b6 55 6d b6 aa 6d b6 ff 6d db 00 6d db 55 6d db aa 6d db ff 6d ff 00 6d ff 55 6d ff aa 6d ff ff 92 00 00 92 00 55 92 00 aa 92 00 ff 92 24 00 92 24 55 92 24 aa 92 24 ff 92 49 00 92 49 55 92 49 aa 92 49 ff 92 6d 00 92 6d 55 92 6d aa 92 6d ff 92 92 00 92 92 55 92 92 aa 92 92 ff 92 b6 00 92 b6 55 92 b6 aa 92 b6 ff 92 db 00 92 db 55 92 db aa 92 db ff 92 ff 00 92 ff 55 92 ff aa 92 ff ff b6 00 00 b6 00 55 b6 00 aa b6 00 ff b6 24 00 b6 24 55 b6 24 aa b6 24 ff b6 49 00 b6 49 55 b6 49 aa b6 49 ff b6 6d 00 b6 6d 55 b6 6d aa b6 6d ff b6 92 00 b6 92 55 b6 92 aa b6 92 ff b6 b6 00 b6 b6 55 b6 b6 aa b6 b6 ff b6 db 00 b6 db 55 b6 db aa b6 db ff b6 ff 00 b6 ff 55 b6 ff aa b6 ff ff db 00 00 db 00 55 db 00 aa db 00 ff db 24 00 db 24 55 db 24 aa db 24 ff db 49 00 db 49 55 db 49 aa db 49 ff db 6d 00 db 6d 55 db 6d aa db 6d ff db 92 00 db 92 55 db 92 aa db 92 ff db b6 00 db b6 55 db b6 aa db b6 ff db db 00 db db 55 db db aa db db ff db ff 00 db ff 55 db ff aa db ff ff ff 00 00 ff 00 55 ff 00 aa ff 00 ff ff 24 00 ff 24 55 ff 24 aa ff 24 ff ff 49 00 ff 49 55 ff 49 aa ff 49 ff ff 6d 00 ff 6d 55 ff 6d aa ff 6d ff ff 92 00 ff 92 55 ff 92 aa ff 92 ff ff b6 00 ff b6 55 ff b6 aa ff b6 ff ff db 00 ff db 55 ff db aa ff db ff ff ff 00 ff ff 55 ff ff aa ff ff ff 21 f9 04 01 00 00 ff 00 2c 00 00 00 00 10 00 26 00 40 08 61 00 ff 09 1c 48 b0 a0 c1 7f 00 12 1e 34 98 b0 21 80 83 0e 23 2e 7c 58 90 e2 c4 85 10 15 62 bc 08 71 a3 c7 8f 20 07 52 6c 08 52 63 48 8b 1d 1d 6e 8c 88 52 64 c7 8c 2c 27 b6 0c 49 f3 a4 c9 8f 2a 57 ce 84 49 12 e3 4e 99 39 2f 3e fc c9 f0 66 d1 a0 2f 75 b2 fc 69 d4 27 43 a0 12 93 d6 9c 7a 30 20 00 3b}}
    set image_toconnect {toconnect.gif {47 49 46 38 39 61 10 00 49 00 f7 00 00 00 00 00 00 00 55 00 00 aa 00 00 ff 00 24 00 00 24 55 00 24 aa 00 24 ff 00 49 00 00 49 55 00 49 aa 00 49 ff 00 6d 00 00 6d 55 00 6d aa 00 6d ff 00 92 00 00 92 55 00 92 aa 00 92 ff 00 b6 00 00 b6 55 00 b6 aa 00 b6 ff 00 db 00 00 db 55 00 db aa 00 db ff 00 ff 00 00 ff 55 00 ff aa 00 ff ff 24 00 00 24 00 55 24 00 aa 24 00 ff 24 24 00 24 24 55 24 24 aa 24 24 ff 24 49 00 24 49 55 24 49 aa 24 49 ff 24 6d 00 24 6d 55 24 6d aa 24 6d ff 24 92 00 24 92 55 24 92 aa 24 92 ff 24 b6 00 24 b6 55 24 b6 aa 24 b6 ff 24 db 00 24 db 55 24 db aa 24 db ff 24 ff 00 24 ff 55 24 ff aa 24 ff ff 49 00 00 49 00 55 49 00 aa 49 00 ff 49 24 00 49 24 55 49 24 aa 49 24 ff 49 49 00 49 49 55 49 49 aa 49 49 ff 49 6d 00 49 6d 55 49 6d aa 49 6d ff 49 92 00 49 92 55 49 92 aa 49 92 ff 49 b6 00 49 b6 55 49 b6 aa 49 b6 ff 49 db 00 49 db 55 49 db aa 49 db ff 49 ff 00 49 ff 55 49 ff aa 49 ff ff 6d 00 00 6d 00 55 6d 00 aa 6d 00 ff 6d 24 00 6d 24 55 6d 24 aa 6d 24 ff 6d 49 00 6d 49 55 6d 49 aa 6d 49 ff 6d 6d 00 6d 6d 55 6d 6d aa 6d 6d ff 6d 92 00 6d 92 55 6d 92 aa 6d 92 ff 6d b6 00 6d b6 55 6d b6 aa 6d b6 ff 6d db 00 6d db 55 6d db aa 6d db ff 6d ff 00 6d ff 55 6d ff aa 6d ff ff 92 00 00 92 00 55 92 00 aa 92 00 ff 92 24 00 92 24 55 92 24 aa 92 24 ff 92 49 00 92 49 55 92 49 aa 92 49 ff 92 6d 00 92 6d 55 92 6d aa 92 6d ff 92 92 00 92 92 55 92 92 aa 92 92 ff 92 b6 00 92 b6 55 92 b6 aa 92 b6 ff 92 db 00 92 db 55 92 db aa 92 db ff 92 ff 00 92 ff 55 92 ff aa 92 ff ff b6 00 00 b6 00 55 b6 00 aa b6 00 ff b6 24 00 b6 24 55 b6 24 aa b6 24 ff b6 49 00 b6 49 55 b6 49 aa b6 49 ff b6 6d 00 b6 6d 55 b6 6d aa b6 6d ff b6 92 00 b6 92 55 b6 92 aa b6 92 ff b6 b6 00 b6 b6 55 b6 b6 aa b6 b6 ff b6 db 00 b6 db 55 b6 db aa b6 db ff b6 ff 00 b6 ff 55 b6 ff aa b6 ff ff db 00 00 db 00 55 db 00 aa db 00 ff db 24 00 db 24 55 db 24 aa db 24 ff db 49 00 db 49 55 db 49 aa db 49 ff db 6d 00 db 6d 55 db 6d aa db 6d ff db 92 00 db 92 55 db 92 aa db 92 ff db b6 00 db b6 55 db b6 aa db b6 ff db db 00 db db 55 db db aa db db ff db ff 00 db ff 55 db ff aa db ff ff ff 00 00 ff 00 55 ff 00 aa ff 00 ff ff 24 00 ff 24 55 ff 24 aa ff 24 ff ff 49 00 ff 49 55 ff 49 aa ff 49 ff ff 6d 00 ff 6d 55 ff 6d aa ff 6d ff ff 92 00 ff 92 55 ff 92 aa ff 92 ff ff b6 00 ff b6 55 ff b6 aa ff b6 ff ff db 00 ff db 55 ff db aa ff db ff ff ff 00 ff ff 55 ff ff aa ff ff ff 21 f9 04 01 00 00 ff 00 2c 00 00 00 00 10 00 49 00 40 08 9f 00 ff 09 1c 48 b0 a0 c1 83 08 05 02 20 b8 30 e1 3f 00 10 1b 3a 64 38 31 a2 44 83 17 15 56 8c 98 30 e3 c3 89 20 43 32 b4 c8 d1 21 44 8d 1d 45 3e 24 69 92 25 42 92 1e 0b c2 7c a9 b2 a6 cd 8f 03 63 de 54 58 32 e5 c2 93 1d 5d be 14 7a 70 66 ca 9c 26 29 ee 54 ca 74 29 d2 a7 18 75 46 35 ea b4 aa d5 ab 20 61 02 a5 29 72 ab d4 95 16 b1 82 45 39 34 6c d7 96 66 cb f6 2c da 74 ea 5a 8c 2a a9 5a 95 0b 17 aa da a0 6d f3 ea dc ba 12 ed d7 9b 74 65 e6 95 f9 76 b0 da b4 82 13 47 15 1b 10 00 3b}}
    set image_todisconnect {todisconnect.gif {47 49 46 38 39 61 10 00 53 00 f7 00 00 00 00 00 00 00 55 00 00 aa 00 00 ff 00 24 00 00 24 55 00 24 aa 00 24 ff 00 49 00 00 49 55 00 49 aa 00 49 ff 00 6d 00 00 6d 55 00 6d aa 00 6d ff 00 92 00 00 92 55 00 92 aa 00 92 ff 00 b6 00 00 b6 55 00 b6 aa 00 b6 ff 00 db 00 00 db 55 00 db aa 00 db ff 00 ff 00 00 ff 55 00 ff aa 00 ff ff 24 00 00 24 00 55 24 00 aa 24 00 ff 24 24 00 24 24 55 24 24 aa 24 24 ff 24 49 00 24 49 55 24 49 aa 24 49 ff 24 6d 00 24 6d 55 24 6d aa 24 6d ff 24 92 00 24 92 55 24 92 aa 24 92 ff 24 b6 00 24 b6 55 24 b6 aa 24 b6 ff 24 db 00 24 db 55 24 db aa 24 db ff 24 ff 00 24 ff 55 24 ff aa 24 ff ff 49 00 00 49 00 55 49 00 aa 49 00 ff 49 24 00 49 24 55 49 24 aa 49 24 ff 49 49 00 49 49 55 49 49 aa 49 49 ff 49 6d 00 49 6d 55 49 6d aa 49 6d ff 49 92 00 49 92 55 49 92 aa 49 92 ff 49 b6 00 49 b6 55 49 b6 aa 49 b6 ff 49 db 00 49 db 55 49 db aa 49 db ff 49 ff 00 49 ff 55 49 ff aa 49 ff ff 6d 00 00 6d 00 55 6d 00 aa 6d 00 ff 6d 24 00 6d 24 55 6d 24 aa 6d 24 ff 6d 49 00 6d 49 55 6d 49 aa 6d 49 ff 6d 6d 00 6d 6d 55 6d 6d aa 6d 6d ff 6d 92 00 6d 92 55 6d 92 aa 6d 92 ff 6d b6 00 6d b6 55 6d b6 aa 6d b6 ff 6d db 00 6d db 55 6d db aa 6d db ff 6d ff 00 6d ff 55 6d ff aa 6d ff ff 92 00 00 92 00 55 92 00 aa 92 00 ff 92 24 00 92 24 55 92 24 aa 92 24 ff 92 49 00 92 49 55 92 49 aa 92 49 ff 92 6d 00 92 6d 55 92 6d aa 92 6d ff 92 92 00 92 92 55 92 92 aa 92 92 ff 92 b6 00 92 b6 55 92 b6 aa 92 b6 ff 92 db 00 92 db 55 92 db aa 92 db ff 92 ff 00 92 ff 55 92 ff aa 92 ff ff b6 00 00 b6 00 55 b6 00 aa b6 00 ff b6 24 00 b6 24 55 b6 24 aa b6 24 ff b6 49 00 b6 49 55 b6 49 aa b6 49 ff b6 6d 00 b6 6d 55 b6 6d aa b6 6d ff b6 92 00 b6 92 55 b6 92 aa b6 92 ff b6 b6 00 b6 b6 55 b6 b6 aa b6 b6 ff b6 db 00 b6 db 55 b6 db aa b6 db ff b6 ff 00 b6 ff 55 b6 ff aa b6 ff ff db 00 00 db 00 55 db 00 aa db 00 ff db 24 00 db 24 55 db 24 aa db 24 ff db 49 00 db 49 55 db 49 aa db 49 ff db 6d 00 db 6d 55 db 6d aa db 6d ff db 92 00 db 92 55 db 92 aa db 92 ff db b6 00 db b6 55 db b6 aa db b6 ff db db 00 db db 55 db db aa db db ff db ff 00 db ff 55 db ff aa db ff ff ff 00 00 ff 00 55 ff 00 aa ff 00 ff ff 24 00 ff 24 55 ff 24 aa ff 24 ff ff 49 00 ff 49 55 ff 49 aa ff 49 ff ff 6d 00 ff 6d 55 ff 6d aa ff 6d ff ff 92 00 ff 92 55 ff 92 aa ff 92 ff ff b6 00 ff b6 55 ff b6 aa ff b6 ff ff db 00 ff db 55 ff db aa ff db ff ff ff 00 ff ff 55 ff ff aa ff ff ff 21 f9 04 01 00 00 ff 00 2c 00 00 00 00 10 00 53 00 40 08 bd 00 ff 09 1c 48 b0 a0 c1 7f 00 0e 2a 04 c0 50 60 42 85 08 19 4a 84 18 51 e2 43 88 16 29 22 8c b8 11 e3 44 8c 06 2f 16 6c a8 b1 a4 49 8d 16 49 9a 14 19 32 25 c5 94 2c 47 ba 6c 59 f1 63 c8 9b 20 07 c6 74 08 73 e7 49 9d 3d 5f 5e f4 f9 13 68 46 8f 47 17 12 24 da b1 e8 ca a5 42 75 3a 8d aa f2 a0 48 9f 55 89 f6 64 5a 13 e5 4c 9c 50 ad 4e 1d 4b 56 a9 54 ab 41 cb 86 75 e8 b5 ea c2 87 4c 13 ca e5 9a f4 6d 5d b0 25 61 fe 8c fb 15 ed dd 91 6b ed d2 0d dc f2 2f d9 ab 6d e9 ce 45 c9 91 2b 61 9e 35 dd 1e ee 0b b8 32 5e b6 7e 29 97 d5 9b 13 33 52 ad 7b d3 5e 6e 2a 53 2d c1 80 00 3b}}
    set image_unlock {unlock.gif {47 49 46 38 39 61 10 00 2f 00 f7 00 00 05 05 05 fb fb fb 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 00 00 00 21 f9 04 01 00 00 ff 00 2c 00 00 00 00 10 00 2f 00 40 08 75 00 ff 09 1c 48 b0 a0 c1 81 00 00 fc 53 78 10 61 42 86 0d 0d 42 3c f8 f0 61 c3 89 02 31 46 dc c8 91 22 41 8d 11 41 2e ac 98 b0 a3 c9 93 1f 1d 52 24 69 31 64 ca 8d 15 39 b2 5c c9 52 64 46 92 30 5f 9a 14 59 13 a5 cf 9f 32 75 5e 1c 79 b1 26 c8 a3 30 21 da 1c 19 13 28 cd 96 43 11 ca 84 5a d0 28 52 89 49 9b 46 dd 89 d3 e3 49 8d 4b ab 16 9d e9 d5 a9 c1 80 00 3b}}
    set image_utilspace {utilspace.gif {47 49 46 38 39 61 03 00 03 00 f7 00 00 00 00 00 33 00 00 66 00 00 99 00 00 cc 00 00 ff 00 00 00 33 00 33 33 00 66 33 00 99 33 00 cc 33 00 ff 33 00 00 66 00 33 66 00 66 66 00 99 66 00 cc 66 00 ff 66 00 00 99 00 33 99 00 66 99 00 99 99 00 cc 99 00 ff 99 00 00 cc 00 33 cc 00 66 cc 00 99 cc 00 cc cc 00 ff cc 00 00 ff 00 33 ff 00 66 ff 00 99 ff 00 cc ff 00 ff ff 00 00 00 33 33 00 33 66 00 33 99 00 33 cc 00 33 ff 00 33 00 33 33 33 33 33 66 33 33 99 33 33 cc 33 33 ff 33 33 00 66 33 33 66 33 66 66 33 99 66 33 cc 66 33 ff 66 33 00 99 33 33 99 33 66 99 33 99 99 33 cc 99 33 ff 99 33 00 cc 33 33 cc 33 66 cc 33 99 cc 33 cc cc 33 ff cc 33 00 ff 33 33 ff 33 66 ff 33 99 ff 33 cc ff 33 ff ff 33 00 00 66 33 00 66 66 00 66 99 00 66 cc 00 66 ff 00 66 00 33 66 33 33 66 66 33 66 99 33 66 cc 33 66 ff 33 66 00 66 66 33 66 66 66 66 66 99 66 66 cc 66 66 ff 66 66 00 99 66 33 99 66 66 99 66 99 99 66 cc 99 66 ff 99 66 00 cc 66 33 cc 66 66 cc 66 99 cc 66 cc cc 66 ff cc 66 00 ff 66 33 ff 66 66 ff 66 99 ff 66 cc ff 66 ff ff 66 00 00 99 33 00 99 66 00 99 99 00 99 cc 00 99 ff 00 99 00 33 99 33 33 99 66 33 99 99 33 99 cc 33 99 ff 33 99 00 66 99 33 66 99 66 66 99 99 66 99 cc 66 99 ff 66 99 00 99 99 33 99 99 66 99 99 99 99 99 cc 99 99 ff 99 99 00 cc 99 33 cc 99 66 cc 99 99 cc 99 cc cc 99 ff cc 99 00 ff 99 33 ff 99 66 ff 99 99 ff 99 cc ff 99 ff ff 99 00 00 cc 33 00 cc 66 00 cc 99 00 cc cc 00 cc ff 00 cc 00 33 cc 33 33 cc 66 33 cc 99 33 cc cc 33 cc ff 33 cc 00 66 cc 33 66 cc 66 66 cc 99 66 cc cc 66 cc ff 66 cc 00 99 cc 33 99 cc 66 99 cc 99 99 cc cc 99 cc ff 99 cc 00 cc cc 33 cc cc 66 cc cc 99 cc cc cc cc cc ff cc cc 00 ff cc 33 ff cc 66 ff cc 99 ff cc cc ff cc ff ff cc 00 00 ff 33 00 ff 66 00 ff 99 00 ff cc 00 ff ff 00 ff 00 33 ff 33 33 ff 66 33 ff 99 33 ff cc 33 ff ff 33 ff 00 66 ff 33 66 ff 66 66 ff 99 66 ff cc 66 ff ff 66 ff 00 99 ff 33 99 ff 66 99 ff 99 99 ff cc 99 ff ff 99 ff 00 cc ff 33 cc ff 66 cc ff 99 cc ff cc cc ff ff cc ff 00 ff ff 33 ff ff 66 ff ff 99 ff ff cc ff ff ff ff ff 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 21 f9 04 01 00 00 d7 00 2c 00 00 00 00 03 00 03 00 40 08 07 00 af 09 1c 38 30 20 00 3b}}
    set image_viewform {viewform.gif {47 49 46 38 39 61 10 00 42 00 f7 00 00 05 05 05 fb fb fb 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 00 00 00 21 f9 04 01 00 00 ff 00 2c 00 00 00 00 10 00 42 00 40 08 9b 00 ff 09 1c 48 b0 a0 41 81 00 0e 1e 4c 38 90 a1 42 87 ff 20 12 04 40 b1 22 45 85 05 2f 62 8c 68 51 62 43 8e 1e 37 8a 1c 69 b0 63 48 92 13 4f 3e 44 a8 11 e5 c2 84 26 1f 5a 74 89 32 26 46 9b 2b 3f de ec b8 11 a7 cc 96 25 11 ea cc 49 b2 62 51 a0 3b 19 aa 0c ba 90 66 ca 93 4b 9d 4a bd d9 93 67 52 a3 54 6b 5a 25 3a d2 27 53 a1 55 91 7e 8d 18 16 eb d4 8f 66 7f 6e cd 38 b6 a4 d8 ab 22 df ba 9d 99 55 2b d8 95 30 a3 d2 75 0b 32 ed 58 a8 51 65 52 5d 9b 31 f0 d9 8d 01 01 00 3b}}
    set image_filter {filter.gif {47 49 46 38 39 61 12 00 27 00 f7 00 00 00 00 00 80 00 00 00 80 00 80 80 00 00 00 80 80 00 80 00 80 80 c0 c0 c0 c0 dc c0 a6 ca f0 00 00 00 ff ff ff 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ff fb f0 a0 a0 a4 80 80 80 ff 00 00 00 ff 00 ff ff 00 00 00 ff ff 00 ff 00 ff ff ff ff ff 21 f9 4 00 00 00 00 00 2c 00 00 00 00 12 00 27 00 87 00 00 00 80 00 00 00 80 00 80 80 00 00 00 80 80 00 80 00 80 80 c0 c0 c0 c0 dc c0 a6 ca f0 00 00 00 ff ff ff 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ff fb f0 a0 a0 a4 80 80 80 ff 00 00 00 ff 00 ff ff 00 00 00 ff ff 00 ff 00 ff ff ff ff ff 8 6b 00 17 8 1c 48 b0 a0 c1 83 8 13 2a 44 8 00 c0 c2 82 e 1f 12 8c 28 90 62 c2 86 18 2d 32 cc a8 f1 a0 c5 8e 12 1f 36 5c 00 d2 20 c6 8a 22 49 a2 5c c8 b1 24 c4 93 29 7 ba 24 d9 72 66 45 8e 31 43 9a bc 58 d3 65 4f 9f 1e 75 ae f4 e8 b0 25 4f 9a 19 73 aa 14 aa 70 a4 4e 9b 3b 91 e6 a4 e8 b3 27 cf 9a 17 83 32 dd ca b5 6b 40 00 3b 00}}

    set images [list $ematrix_logo $plus $moins $matrix_type $matrixone_logo]
    set lTempImageNames [info vars \"image_*\"]
    foreach sVarName $lTempImageNames {
        lappend images [subst $[subst $sVarName]]
    }

    foreach image $images {
        Create_Image_File $Image_Directory/[lindex $image 0] [lindex $image 1]
    }

}


proc pSpinnerDumper { } {

   global nMxVer

# Schema Element Procs To Generate Lists
   pDumpProgram
   pDumpRole
   pDumpGroup
   pDumpAssociation
   pDumpAttribute
   pDumpType
   pDumpRelationship
   pDumpFormat
   pDumpPolicy
   pDumpPolicyState
   pDumpPolicyStateSignature
   pDumpCommand
   pDumpInquiry
   pDumpMenu
   pDumpTable
   pDumpTableColumn
   pDumpTrigger
   pDumpProperty
   pDumpRule
   pDumpWebForm
   pDumpWebFormField
   if {$nMxVer >= 10.5} {
      pDumpChannel
      pDumpPortal
   }
   if {$nMxVer >= 10.6} {
      pDumpPage
      pDumpInterface
      pDumpExpression
   }
   if {$nMxVer >= 10.7} {
      pDumpDimension
      pDumpDimensionUnit
   }
   pDumpSite
   pDumpLocation
   pDumpStore
   pDumpServer
   pDumpVault
   pDumpIndex
}

proc pDumpProperty { } {

   upvar 2 aAdmin aAdmin
    
   global bStatus
   global sDumpSchemaDirBusiness
   global nMxVer

   if {$bStatus} {puts \"Start Processing Property ...\"}
   
   set sPath \"${sDumpSchemaDirBusiness}/SpinnerPropertyData.xls\"
   set sFile \"Schema Type\\tSchema Name\\tProperty Name\\tProperty Value\\tTo Schema Type\\tTo Schema Name\\n\"
   set lsType [list vault store program group role attribute type relationship format policy command inquiry menu table form]
   
   if {$nMxVer >= 10.5} {
       lappend lsType channel portal
   }
   if {$nMxVer >= 10.6} {
       lappend lsType page interface expression
   }
   if {$nMxVer >= 10.7} {
       lappend lsType dimension
   }

   foreach sType $lsType {
      set lsName $aAdmin($sType)

      foreach sName $lsName {
         if {$sType == \"table\"} {
            set lsPrint [split [mql print $sType $sName system select property dump |] |]
         } else {
            set lsPrint [split [mql print $sType $sName select property dump |] |]
         }
   
         foreach sPrint $lsPrint {
            set sToType \"\"
            set sToName \"\"
            set sPropertyValue \"\"
            if {[string first \" value \" $sPrint] > -1} {
               regsub \" value \" $sPrint \"|\" slsPrint
               set lslsPrint [split $slsPrint |]
               set sPropertyValue [lindex $lslsPrint 1]
               set sPrint [lindex $lslsPrint 0]
            }
            if {[string first \" to \" $sPrint] > -1} {
               regsub \" to \" $sPrint \"|\" slsPrint
               set lslsPrint [split $slsPrint |]
               set sPropertyName [lindex $lslsPrint 0]
               set slsToTypeName [lindex $lslsPrint 1]
               regsub \" \" $slsToTypeName \"|\" slsToTypeName
               set lslsToTypeName [split $slsToTypeName |]
               set sToType [lindex $lslsToTypeName 0]
               set sToName [lindex $lslsToTypeName 1]
            } else {
               set sPropertyName [string trim $sPrint]
            }

            if {$sType != \"policy\" || [string first \"state_\" $sPropertyName] != 0} {
                append sFile \"$sType\\t$sName\\t$sPropertyName\\t$sPropertyValue\\t$sToType\\t$sToName\\n\"
            }
         }
      }
   }

   set iFile [open $sPath w]
   puts $iFile $sFile
   close $iFile
   if {$bStatus} {puts \"Property data loaded in file $sPath\"}
}

proc pDumpAttribute { } {

   upvar 2 aAdmin aAdmin
    
   global sDumpSchemaDirBusiness
   global bStatus
   global nMxVer

   if {$bStatus} {puts \"Start Processing Spinner Attributes ...\"}

#  Set up array for symbolic name mapping
#
   set lsPropertyName \"\"
   catch {set lsPropertyName [split [mql print program eServiceSchemaVariableMapping.tcl select property.name dump |] |]} sMsg
   set sTypeReplace \"att \"

   foreach sPropertyName $lsPropertyName {
      set sSchemaTest [lindex [split $sPropertyName \"_\"] 0]
      if {$sSchemaTest == \"attribute\"} {
         set sPropertyTo [mql print program eServiceSchemaVariableMapping.tcl select property\\[$sPropertyName\\].to dump]
         regsub $sTypeReplace $sPropertyTo \"\" sPropertyTo
         regsub \"_\" $sPropertyName \"|\" sSymbolicName
         set sSymbolicName [lindex [split $sSymbolicName |] 1]
         array set aSymbolic [list $sPropertyTo $sSymbolicName]
      }
   }

   set sPath \"$sDumpSchemaDirBusiness/SpinnerAttributeData.xls\"
   set lsAttribute $aAdmin(attribute)
   if {[ llength $lsAttribute ] == 0} {return 0}
   set sFile \"Attribute Name\\tRegistry Name\\tType\\tDescription\\tDefault\\tRanges (use \\\"|\\\" delim)\\tMultiline (boolean)\\tHidden (boolean)\\tDimension\\tIcon File\\n\"

   foreach sAttribute $lsAttribute {
      set sName [mql print attribute $sAttribute select name dump]
      set sOrigName \"\"
      catch {set sOrigName $aSymbolic($sAttribute)} sMsg
      regsub -all \" \" $sAttribute \"\" sOrigNameTest
      if {$sOrigNameTest == $sOrigName} {
         set sOrigName $sAttribute
      }
      set sDescription [mql print attribute $sAttribute select description dump]
      set sType [mql print attribute $sAttribute select type dump]
      set sDefault [mql print attribute $sAttribute select default dump]
      if {$sDefault == \"True\" || $sDefault == \"true\" || $sDefault == \"False\" || $sDefault == \"false\"} {
         set sDefault \"'$sDefault\"
      }         
      set bMultiline [mql print attribute $sAttribute select multiline dump]
      set bHidden [mql print attribute $sAttribute select hidden dump]
      set slsRange [mql print attribute $sAttribute select range dump \" | \"]
      if {$nMxVer >= 10.8} {
         set sDimension [mql print attribute $sAttribute select dimension dump]
         append sFile \"$sName\\t$sOrigName\\t$sType\\t$sDescription\\t$sDefault\\t $slsRange\\t$bMultiline\\t$bHidden\\t$sDimension\\n\"
      } else {
         append sFile \"$sName\\t$sOrigName\\t$sType\\t$sDescription\\t$sDefault\\t $slsRange\\t$bMultiline\\t$bHidden\\n\"
      }
   }
   set iFile [open $sPath w]
   puts $iFile $sFile
   close $iFile
   if {$bStatus} {puts \"Attribute data loaded in file $sPath\"}
}

proc pDumpRole { } {

   global sDumpSchemaDirBusiness
   global bStatus
   global nMxVer
   upvar 2 aAdmin aAdmin

   if {$bStatus} {puts \"Start Processing Spinner Role ...\"}

#  Set up array for symbolic name mapping
#
   set lsPropertyName \"\"
   catch {set lsPropertyName [split [mql print program eServiceSchemaVariableMapping.tcl select property.name dump |] |]} sMsg
   set sTypeReplace \"role \"

   foreach sPropertyName $lsPropertyName {
      set sSchemaTest [lindex [split $sPropertyName \"_\"] 0]
      if {$sSchemaTest == \"role\"} {
         set sPropertyTo [mql print program eServiceSchemaVariableMapping.tcl select property\\[$sPropertyName\\].to dump]
         regsub $sTypeReplace $sPropertyTo \"\" sPropertyTo
         regsub \"_\" $sPropertyName \"|\" sSymbolicName
         set sSymbolicName [lindex [split $sSymbolicName |] 1]
         array set aSymbolic [list $sPropertyTo $sSymbolicName]
      }
   }

   set sPath \"$sDumpSchemaDirBusiness/SpinnerRoleData.xls\"
   set lsRole $aAdmin(role)
   if { [ llength $lsRole ] == 0 } {return 0}
   set sFile \"Role Name\\tOriginal Name for AEF\\tDescription\\tParent Roles (use | delimiter)\\tChild Roles (use | delimiter)\\tAssignments (use | delimiter)\\tSite\\tHidden ( true / false or \\\"\\\" )\\tIcon File (not path)\\n\"

   foreach sRole $lsRole {
      set sName [mql print role $sRole select name dump]
      set sDescription [mql print role $sRole select description dump]
      set slsParentRole [mql print role $sRole select parent dump \" | \"]
      set lsChildRole [pContinue [split [mql print role $sRole select child dump |] |] ]
      set iLast [llength $lsChildRole]
      set lsAssignment [pContinue [split [mql print role $sRole select assignment dump |] |] ]
      if {[llength $lsAssignment] > $iLast} {
         set iLast [llength $lsAssignment]
      }
      set bHidden [mql print role $sRole select hidden dump]
      set sOrigName \"\"
      catch {set sOrigName $aSymbolic($sRole)} sMsg
      regsub -all \" \" $sRole \"\" sOrigNameTest
      if {$sOrigNameTest == $sOrigName} {
         set sOrigName $sRole
      }
      set sSite \"\"
      set lsSiteTemp [split [mql print role $sRole] \\n]
      foreach sSiteTemp $lsSiteTemp {
         set sSiteTemp [string trim $sSiteTemp]
         if {[string first \"site\" $sSiteTemp] == 0} {
            regsub \"site \" $sSiteTemp \"\" sSite
            break
         }
      }
      set iCounter 1
      set sMultiline \"\"
      if {$iLast > 1} {
         set sMultiline \" <MULTILINE.1.$iLast>\"
      }
      foreach sOnce [list 1] sChildRole $lsChildRole sAssignment $lsAssignment {
         regsub -all \"\\\\\\(\" $sName \"\\\\\\(\" sTestName
         regsub -all \"\\\\\\)\" $sTestName \"\\\\\\)\" sTestName
         regsub \"$sTestName \" $sAssignment \"\" sAssignment
         regsub -all \"\\\\| $sTestName \" $sAssignment \"\\| \" sAssignment
         if {[string range $sAssignment 0 0] == \"\\\"\" && [string range $sAssignment end end] == \"\\\"\"} {
            set sAssignment [string range $sAssignment 1 [expr [string length $sAssignment] - 2]]
         }
         if {$iCounter == 1} {
            append sFile \"$sName$sMultiline\\t$sOrigName\\t$sDescription\\t$slsParentRole\\t$sChildRole\\t$sAssignment\\t$sSite\\t$bHidden\\n\"
            set bFirst FALSE
         } else {
            set sMultiline \" <MULTILINE.$iCounter.$iLast>\"
            append sFile \"$sName$sMultiline\\t\\t\\t\\t$sChildRole\\t$sAssignment\\n\"
         }
         incr iCounter
      }
   }
   set iFile [open $sPath w]
   puts $iFile $sFile
   close $iFile
   if {$bStatus} {puts \"Role data loaded in file $sPath\"}
}

proc pDumpProgram { } {

   upvar 2 aAdmin aAdmin
    
   global bStatus
   global sDumpSchemaDirBusiness
   global sDumpSchemaDirBusinessSource
   global nMxVer

   if {$bStatus} {puts \"Start Processing Spinner Program ...\"}
    
#  Set up array for symbolic name mapping
#
   set lsPropertyName \"\"
   catch {set lsPropertyName [split [mql print program eServiceSchemaVariableMapping.tcl select property.name dump |] |]} sMsg
   set sTypeReplace \"program \"

   foreach sPropertyName $lsPropertyName {
      set sSchemaTest [lindex [split $sPropertyName \"_\"] 0]
      if {$sSchemaTest == \"program\"} {
         set sPropertyTo [mql print program eServiceSchemaVariableMapping.tcl select property\\[$sPropertyName\\].to dump]
         regsub $sTypeReplace $sPropertyTo \"\" sPropertyTo
         regsub \"_\" $sPropertyName \"|\" sSymbolicName
         set sSymbolicName [lindex [split $sSymbolicName |] 1]
         array set aSymbolic [list $sPropertyTo $sSymbolicName]
      }
   }

   set sPath \"$sDumpSchemaDirBusiness/SpinnerProgramData.xls\"
   set sSourceFileDir \"$sDumpSchemaDirBusinessSource\"
   set lsProgram $aAdmin(program)
   if { [ llength $lsProgram ] == 0 } {return 0}
   set sFile \"Program Name\\tRegistry Name\\tDescription\\tType (java / mql or \\\"\\\" / external)\\tExecute (immediate or \\\"\\\" / deferred)\\tNeeds Bus Obj (boolean)\\tDownloadable (boolean)\\tPiped (boolean)\\tPooled (boolean)\\tHidden (boolean)\\tUser\\tIcon File\\n\"

   foreach sProgram $lsProgram {
      if {[mql print program $sProgram select iswizardprogram dump] != \"TRUE\"} {
         set sName [mql print program $sProgram select name dump]
         set sOrigName \"\"
         catch {set sOrigName $aSymbolic($sProgram)} sMsg
         regsub -all \" \" $sProgram \"\" sOrigNameTest
         if {$sOrigNameTest == $sOrigName} {
            set sOrigName $sProgram
         }
         set sDescription [mql print program $sProgram select description dump]

         if {$nMxVer > 8.9 && [mql print program $sProgram select isjavaprogram dump] == \"TRUE\"} {
            set sProgType java
         } elseif {[mql print program $sProgram select ismqlprogram dump] == \"TRUE\"} {
            set sProgType mql
         } else {
            set sProgType external
         }
         
         set sExecute [mql print program $sProgram select execute dump]
         set bNeedBusObj [mql print program $sProgram select doesneedcontext dump]
         set bDownload [mql print program $sProgram select downloadable dump]
         set sUser \"\"
         if {$nMxVer >= 10.5} {
            set sUser [mql print program $sProgram select user dump]
         }
         set lsProgram [split [mql print program $sProgram] \\n]

         set bPooled FALSE
         set bPiped FALSE

         foreach sProg $lsProgram {
            set sProg [string trim $sProg]
            if {[string first \"code\" $sProg] == 0} {
               break
            } elseif {$sProg == \"pooled\"} {
               set bPooled TRUE
            } elseif {$sProg == \"pipe\"} {
               set bPiped TRUE
            }
         }

         set bHidden [mql print program $sProgram select hidden dump]

         regsub -all \"/\" $sProgram \"SLASH\" sProgramFile 
         regsub -all \":\" $sProgramFile \"COLON\" sProgramFile
         regsub -all \"\\134\\174\" $sProgramFile \"PYPE\" sProgramFile
         regsub -all \">\" $sProgramFile \"GTHAN\" sProgramFile
         regsub -all \"<\" $sProgramFile \"LTHAN\" sProgramFile
         mql print program $sProgram select code dump output \"$sSourceFileDir/$sProgramFile\"

         append sFile \"$sName\\t$sOrigName\\t$sDescription\\t$sProgType\\t$sExecute\\t$bNeedBusObj\\t$bDownload\\t$bPiped\\t$bPooled\\t$bHidden\\t$sUser\\n\"
      }
   }
   set iFile [open $sPath w]
   puts $iFile $sFile
   close $iFile
   if {$bStatus} {puts \"Program data loaded in file $sPath\\nSource files loaded in directory $sSourceFileDir\"}
}

proc pDumpGroup { } {

   upvar 2 aAdmin aAdmin
    
   global bStatus
   global sDumpSchemaDirBusiness
   global nMxVer

   if {$bStatus} {puts \"Start Processing Spinner Group ...\"}

#  Set up array for symbolic name mapping
#
   set lsPropertyName \"\"
   catch {set lsPropertyName [split [mql print program eServiceSchemaVariableMapping.tcl select property.name dump |] |]} sMsg
   set sTypeReplace \"group \"

   foreach sPropertyName $lsPropertyName {
      set sSchemaTest [lindex [split $sPropertyName \"_\"] 0]
      if {$sSchemaTest == \"group\"} {
         set sPropertyTo [mql print program eServiceSchemaVariableMapping.tcl select property\\[$sPropertyName\\].to dump]
         regsub $sTypeReplace $sPropertyTo \"\" sPropertyTo
         regsub \"_\" $sPropertyName \"|\" sSymbolicName
         set sSymbolicName [lindex [split $sSymbolicName |] 1]
         array set aSymbolic [list $sPropertyTo $sSymbolicName]
      }
   }

   set sPath \"$sDumpSchemaDirBusiness/SpinnerGroupData.xls\"
   set lsGroup $aAdmin(group)
   if { [ llength $lsGroup ] == 0 } {return 0}
   set sFile \"Group Name\\tRegistry Name\\tDescription\\tParent Groups (use \\\"|\\\" delim)\\tChild Groups (use \\\"|\\\" delim)\\tAssignments (use \\\"|\\\" delim)\\tSite\\tHidden (boolean)\\tIcon File\\n\"

   foreach sGroup $lsGroup {
      set sName [mql print group $sGroup select name dump]
      set sDescription [mql print group $sGroup select description dump]
      set slsParentGroup [mql print group $sGroup select parent dump \" | \"]
      set lsChildGroup [pContinue [split [mql print group $sGroup select child dump |] |] ]
      set iLast [llength $lsChildGroup]
      set lsAssignment [pContinue [split [mql print group $sGroup select assignment dump |] |] ]
      if {[llength $lsAssignment] > $iLast} {
         set iLast [llength $lsAssignment]
      }
      set bHidden [mql print group $sGroup select hidden dump]
      set sOrigName \"\"
      catch {set sOrigName $aSymbolic($sGroup)} sMsg
      regsub -all \" \" $sGroup \"\" sOrigNameTest
      if {$sOrigNameTest == $sOrigName} {
         set sOrigName $sGroup
      }
      set sSite \"\"
      set lsSiteTemp [split [mql print group $sGroup] \\n]
      foreach sSiteTemp $lsSiteTemp {
         set sSiteTemp [string trim $sSiteTemp]
         if {[string first \"site\" $sSiteTemp] == 0} {
            regsub \"site \" $sSiteTemp \"\" sSite
            break
         }
      }
      set iCounter 1
      set sMultiline \"\"
      if {$iLast > 1} {
         set sMultiline \" <MULTILINE.1.$iLast>\"
      }
      foreach sOnce [list 1] sChildGroup $lsChildGroup sAssignment $lsAssignment {
         regsub -all \"\\\\\\(\" $sName \"\\\\\\(\" sTestName
         regsub -all \"\\\\\\)\" $sTestName \"\\\\\\)\" sTestName
         regsub \"$sTestName \" $sAssignment \"\" sAssignment
         regsub -all \"\\\\| $sTestName \" $sAssignment \"\\| \" sAssignment
         if {[string range $sAssignment 0 0] == \"\\\"\" && [string range $sAssignment end end] == \"\\\"\"} {
            set sAssignment [string range $sAssignment 1 [expr [string length $sAssignment] - 2]]
         }
         if {$iCounter == 1} {
            append sFile \"$sName$sMultiline\\t$sOrigName\\t$sDescription\\t$slsParentGroup\\t$sChildGroup\\t$sAssignment\\t$sSite\\t$bHidden\\n\"
            set bFirst FALSE
         } else {
            set sMultiline \" <MULTILINE.$iCounter.$iLast>\"
            append sFile \"$sName$sMultiline\\t\\t\\t\\t$sChildGroup\\t$sAssignment\\n\"
         }
         incr iCounter
      }
   }
   set iFile [open $sPath w]
   puts $iFile $sFile
   close $iFile
   if {$bStatus} {puts \"Group data loaded in file $sPath\"}
}

proc pDumpAssociation { } {

   upvar 2 aAdmin aAdmin
    
   global bStatus
   global sDumpSchemaDirBusiness
   global nMxVer

   if {$bStatus} {puts \"Start Processing Spinner Association ...\"}

#  Set up array for symbolic name mapping
#
   set lsPropertyName \"\"
   catch {set lsPropertyName [split [mql print program eServiceSchemaVariableMapping.tcl select property.name dump |] |]} sMsg
   set sTypeReplace \"association \"

   foreach sPropertyName $lsPropertyName {
      set sSchemaTest [lindex [split $sPropertyName \"_\"] 0]
      if {$sSchemaTest == \"association\"} {
         set sPropertyTo [mql print program eServiceSchemaVariableMapping.tcl select property\\[$sPropertyName\\].to dump]
         regsub $sTypeReplace $sPropertyTo \"\" sPropertyTo
         regsub \"_\" $sPropertyName \"|\" sSymbolicName
         set sSymbolicName [lindex [split $sSymbolicName |] 1]
         array set aSymbolic [list $sPropertyTo $sSymbolicName]
      }
   }

   set sPath \"$sDumpSchemaDirBusiness/SpinnerAssociationData.xls\"
   set sFile \"Name\\tOriginal Name for AEF\\tDescription\\tDefinition (use format \\\"user | and / or | user\\\" ...)\\tHidden ( true / false or \\\"\\\")\\tIcon File\\n\"
   set lsAssociation $aAdmin(association)
   if { [ llength $lsAssociation ] == 0 } {return 0}

   foreach sAssociation $lsAssociation {
      set sDescription \"\"
      set sDefinition \"\"
      set sModified \"\"
      set sHidden \"\"
      set sOrigName \"\"
      set sSpinnerAgent \"\"
      set lsPrint [split [mql print association $sAssociation] \\n]

      foreach sPrint $lsPrint {
         set sPrint [string trim $sPrint]
         set sOrigName \"\"
         catch {set sOrigName $aSymbolic($sAssociation)} sMsg
         regsub -all \" \" $sAssociation \"\" sOrigNameTest
         if {$sOrigNameTest == $sOrigName} {
            set sOrigName $sAssociation
         }
         if {[string first \"description\" $sPrint] == 0} {
            regsub \"description\" $sPrint \"\" sDescription
            set sDescription [string trim $sDescription]
         } elseif {[string first \"modified\" $sPrint] == 0} {
            regsub \"modified\" $sPrint \"\" sModified
            set sModified [string trim $sModified]
         } elseif {[string first \"property SpinnerAgent\" $sPrint] == 0} {
            regsub \"property SpinnerAgent\" $sPrint \"\" sSpinnerAgent
            set sSpinnerAgent [string trim $sSpinnerAgent]
         } elseif {[string first \"definition\" $sPrint] == 0} {
            regsub \"definition\" $sPrint \"\" sDefinition
            regsub -all \"\\\"\" $sDefinition \"\" sDefinition
            regsub -all \"&&\" $sDefinition \"| and |\" sDefinition
            regsub -all \"\\\\\\|\\\\\\|\" $sDefinition \"| or |\" sDefinition
            set sDefinition [string trim $sDefinition]
         } elseif {$sPrint == \"hidden\"} {
            set sHidden true
         } elseif {$sPrint == \"nothidden\"} {
            set sHidden false
         }
      }
      append sFile \"$sAssociation\\t$sOrigName\\t$sDescription\\t$sDefinition\\t$sHidden\\n\"
   }

   set iFile [open $sPath w]
   puts $iFile $sFile
   close $iFile
   if {$bStatus} {puts \"Association data loaded in file $sPath\"}
}

proc pDumpType { } {

   upvar 2 aAdmin aAdmin
    
   global bStatus
   global sDumpSchemaDirBusiness
   global nMxVer

   if {$bStatus} {puts \"Start Processing Spinner Type ...\"}
    
#  Set up array for symbolic name mapping
#
   set lsPropertyName \"\"
   catch {set lsPropertyName [split [mql print program eServiceSchemaVariableMapping.tcl select property.name dump |] |]} sMsg
   set sTypeReplace \"type \"

   foreach sPropertyName $lsPropertyName {
      set sSchemaTest [lindex [split $sPropertyName \"_\"] 0]
      if {$sSchemaTest == \"type\"} {
         set sPropertyTo [mql print program eServiceSchemaVariableMapping.tcl select property\\[$sPropertyName\\].to dump]
         regsub $sTypeReplace $sPropertyTo \"\" sPropertyTo
         regsub \"_\" $sPropertyName \"|\" sSymbolicName
         set sSymbolicName [lindex [split $sSymbolicName |] 1]
         array set aSymbolic [list $sPropertyTo $sSymbolicName]
      }
   }

   set sPath \"$sDumpSchemaDirBusiness/SpinnerTypeData.xls\"
   set lsType $aAdmin(type)
   if { [ llength $lsType ] == 0 } {return 0}
   set sFile \"Name\\tRegistry Name\\tParent Type\\tAbstract (boolean)\\tDescription\\tAttributes (use \\\"|\\\" delim)\\tMethods (use \\\"|\\\" delim)\\tHidden (boolean)\\tSparse (boolean)\\tIcon File\\n\"

   foreach sType $lsType {
      set sName [mql print type $sType select name dump]
      set sOrigName \"\"
      catch {set sOrigName $aSymbolic($sType)} sMsg
      regsub -all \" \" $sType \"\" sOrigNameTest
      if {$sOrigNameTest == $sOrigName} {
         set sOrigName $sType
      }
      set sDescription [mql print type $sType select description dump]
      set sHidden [mql print type $sType select hidden dump]
      set bSparse [mql print type $sType select sparse dump]
      set slsAttribute [mql print type $sType select immediateattribute dump \" | \"]
      set sDerived [mql print type $sType select derived dump]

      if {$sDerived != \"\"} {
         set lsMethod [split [mql print type $sType select method dump |] |]
         set lsMethodDerived [split [mql print type $sDerived select method dump |] |]
         set lsMethodDerivative \"\"
         foreach sMethod $lsMethod {
            if {[lsearch $lsMethodDerived $sMethod] < 0} {
               lappend lsMethodDerivative $sMethod
            }
         }
         set slsMethod \"\"
         if {[llength $lsMethodDerivative] > 1} {
            set slsMethod [join $lsMethodDerivative \" | \"]
         }
   # Modified for the Incident 318282 by Venkatesh - Start
         if {[llength $lsMethodDerivative] == 1} {
      # make sure output file doesn't include curly brackets around programs whose name contain spaces
            set slsMethod [lindex $lsMethodDerivative 0]
         }
   # Modified for the Incident 318282 by Venkatesh - End

      } else {
         set slsMethod [mql print type $sType select method dump \" | \"]
      }

      set lsTypeData [split [mql print type $sType] \\n]
      set bAbstract false
      foreach sTypeData $lsTypeData {
         set sTypeData [string trim $sTypeData]
         if {[string range $sTypeData 0 7] == \"abstract\"} {
            regsub \"abstract \" $sTypeData \"\" bAbstract
            break
         }
      }
      append sFile \"$sName\\t$sOrigName\\t$sDerived\\t$bAbstract\\t$sDescription\\t$slsAttribute\\t$slsMethod\\t$sHidden\\t$bSparse\\n\"
   }
   set iFile [open $sPath w]
   puts $iFile $sFile
   close $iFile
   if {$bStatus} {puts \"Type data loaded in file $sPath\"}
}

proc pDumpRelationship { } {

   upvar 2 aAdmin aAdmin
    
   global bStatus
   global sDumpSchemaDirBusiness
   global nMxVer

   if {$bStatus} {puts \"Start Processing Spinner Relationship ...\"}
    
#  Set up array for symbolic name mapping
#
   set lsPropertyName \"\"
   catch {set lsPropertyName [split [mql print program eServiceSchemaVariableMapping.tcl select property.name dump |] |]} sMsg
   set sTypeReplace \"relationship \"

   foreach sPropertyName $lsPropertyName {
      set sSchemaTest [lindex [split $sPropertyName \"_\"] 0]
      if {$sSchemaTest == \"relationship\"} {
         set sPropertyTo [mql print program eServiceSchemaVariableMapping.tcl select property\\[$sPropertyName\\].to dump]
         regsub $sTypeReplace $sPropertyTo \"\" sPropertyTo
         regsub \"_\" $sPropertyName \"|\" sSymbolicName
         set sSymbolicName [lindex [split $sSymbolicName |] 1]
         array set aSymbolic [list $sPropertyTo $sSymbolicName]
      }
   }

   set sPath \"$sDumpSchemaDirBusiness/SpinnerRelationshipData.xls\"
   set lsRelationship $aAdmin(relationship)
   if { [ llength $lsRelationship ] == 0 } {return 0}
   set sFile \"Name\\tRegistry Name\\tDescription\\tAttributes (use \\\"|\\\" delim)\\tSparse (boolean)\\tHidden (boolean)\\tPreventDuplicates (boolean)\\tFrom Types (use \\\"|\\\" delim)\\tFrom Meaning\\tFrom Revision (none or \\\"\\\"/ float / replicate)\\tFrom Clone (none or \\\"\\\" / float / replicate)\\tFrom Cardinality (one / many or \\\"\\\")\\tFrom Propagate Modify (boolean)\\tTo Types (use \\\"|\\\" delim)\\tTo Meaning\\tTo Revision (none or \\\"\\\" / float / replicate)\\tTo Clone (none or \\\"\\\" / float / replicate)\\tTo Cardinality (one / many or \\\"\\\")\\tTo Propagate Modify (boolean)\\tFrom Propagate Connect (boolean)\\tTo Propagate Connect (boolean)\\tIcon File\\n\"
   if {$nMxVer >= 10.8} {
      set sFile \"Name\\tRegistry Name\\tDescription\\tAttributes (use \\\"|\\\" delim)\\tSparse (boolean)\\tHidden (boolean)\\tPreventDuplicates (boolean)\\tFrom Types (use \\\"|\\\" delim)\\tFrom Rels (use \\\"|\\\" delim)\\tFrom Revision (none or \\\"\\\"/ float / replicate)\\tFrom Clone (none or \\\"\\\" / float / replicate)\\tFrom Cardinality (one / many or \\\"\\\")\\tFrom Propagate Modify (boolean)\\tTo Types (use \\\"|\\\" delim)\\tTo Rels (use \\\"|\\\" delim)\\tTo Revision (none or \\\"\\\" / float / replicate)\\tTo Clone (none or \\\"\\\" / float / replicate)\\tTo Cardinality (one / many or \\\"\\\")\\tTo Propagate Modify (boolean)\\tFrom Propagate Connect (boolean)\\tTo Propagate Connect (boolean)\\tIcon File\\n\"
   }

   foreach sRelationship $lsRelationship {
      set sName [mql print relationship $sRelationship select name dump]
      set sOrigName \"\"
      catch {set sOrigName $aSymbolic($sRelationship)} sMsg
      regsub -all \" \" $sRelationship \"\" sOrigNameTest
      if {$sOrigNameTest == $sOrigName} {
         set sOrigName $sRelationship
      }
      set sDescription [mql print relationship $sRelationship select description dump]
      set bSparse [mql print relationship $sRelationship select sparse dump]
      set bHidden [mql print relationship $sRelationship select hidden dump]
      set bPreventDuplicate [mql print relationship $sRelationship select preventduplicates dump]
      set sFromMeaning [mql print relationship $sRelationship select frommeaning dump]
      set sFromRevision [mql print relationship $sRelationship select fromreviseaction dump]
      set sFromClone [mql print relationship $sRelationship select fromcloneaction dump]
      set sFromCardinality [mql print relationship $sRelationship select fromcardinality dump]
      set sToMeaning [mql print relationship $sRelationship select tomeaning dump]
      set sToRevision [mql print relationship $sRelationship select toreviseaction dump]
      set sToClone [mql print relationship $sRelationship select tocloneaction dump]
      set sToCardinality [mql print relationship $sRelationship select tocardinality dump]
      set slsFromType [mql print relationship $sRelationship select fromtype dump \" | \"]
      set slsToType [mql print relationship $sRelationship select totype dump \" | \"]
      if {$nMxVer >= 10.8} {
         set slsFromRel [mql print relationship $sRelationship select fromrel dump \" | \"]
         set slsToRel [mql print relationship $sRelationship select torel dump \" | \"]
      }

      if {$nMxVer < 10.5} {
         set bFromPropConnect \"\"
         set bToPropConnect \"\"
         if {$slsFromType == \"\"} {
            set lsPrint [split [mql print relationship $sRelationship] \\n]
            set bTrip FALSE
            foreach sPrint $lsPrint {
               set sPrint [string trim $sPrint]
               if {$bTrip} {
                  if {$sPrint == \"to\"} {
                     break
                  } elseif {$sPrint == \"type all\"} {
                     set slsFromType all
                  }
               } elseif {$sPrint == \"from\"} {
                  set bTrip TRUE
               }
            }
         }
         if {$slsToType == \"\"} {
            set lsPrint [split [mql print relationship $sRelationship] \\n]
            set bTrip FALSE
            foreach sPrint $lsPrint {
               set sPrint [string trim $sPrint]
               if {$bTrip} {
                  if {$sPrint == \"type all\"} {
                     set slsToType all
                  }
               } elseif {$sPrint == \"to\"} {
                  set bTrip TRUE
               }
            }
         }
   
         set lsRel [split [mql print rel $sRelationship] \\n]
         set iCounter 0
         foreach sRel $lsRel {
            set sRel [string trim $sRel]
            if {[string first \"propagate modify\" $sRel] == 0} {
               incr iCounter
               set lslsRel [split $sRel \" \"]
               if {$iCounter == 1} {
                  set bFromPropModify [lindex $lslsRel 2]
               } else {
                  set bToPropModify [lindex $lslsRel 2]
               }
            }
            if {$iCounter > 1} {
               break
            }
         }
      } else {
         set bFromPropModify [mql print relationship $sRelationship select frompropagatemodify dump]
         set bToPropModify [mql print relationship $sRelationship select topropagatemodify dump]
         set bFromPropConnect [mql print relationship $sRelationship select frompropagateconnection dump]
         set bToPropConnect [mql print relationship $sRelationship select topropagateconnection dump]
      }

      set slsAttribute [mql print relationship $sRelationship select attribute dump \" | \"]
      if {$nMxVer >= 10.8} {
         append sFile \"$sName\\t$sOrigName\\t$sDescription\\t$slsAttribute\\t$bSparse\\t$bHidden\\t$bPreventDuplicate\\t$slsFromType\\t$slsFromRel\\t$sFromRevision\\t$sFromClone\\t$sFromCardinality\\t$bFromPropModify\\t$slsToType\\t$slsToRel\\t$sToRevision\\t$sToClone\\t$sToCardinality\\t$bToPropModify\\t$bFromPropConnect\\t$bToPropConnect\\n\"
      } else {
         append sFile \"$sName\\t$sOrigName\\t$sDescription\\t$slsAttribute\\t$bSparse\\t$bHidden\\t$bPreventDuplicate\\t$slsFromType\\t$sFromMeaning\\t$sFromRevision\\t$sFromClone\\t$sFromCardinality\\t$bFromPropModify\\t$slsToType\\t$sToMeaning\\t$sToRevision\\t$sToClone\\t$sToCardinality\\t$bToPropModify\\t$bFromPropConnect\\t$bToPropConnect\\n\"
      }
   }
   set iFile [open $sPath w]
   puts $iFile $sFile
   close $iFile
   if {$bStatus} {puts \"Relationship data loaded in file $sPath\"}
}

proc pDumpFormat { } {

   upvar 2 aAdmin aAdmin
    
   global bStatus
   global sDumpSchemaDirBusiness
   global nMxVer

   if {$bStatus} {puts \"Start Processing Spinner Format ...\"}

#  Set up array for symbolic name mapping
#
   set lsPropertyName \"\"
   catch {set lsPropertyName [split [mql print program eServiceSchemaVariableMapping.tcl select property.name dump |] |]} sMsg
   set sTypeReplace \"format \"

   foreach sPropertyName $lsPropertyName {
      set sSchemaTest [lindex [split $sPropertyName \"_\"] 0]
      if {$sSchemaTest == \"format\"} {
         set sPropertyTo [mql print program eServiceSchemaVariableMapping.tcl select property\\[$sPropertyName\\].to dump]
         regsub $sTypeReplace $sPropertyTo \"\" sPropertyTo
         regsub \"_\" $sPropertyName \"|\" sSymbolicName
         set sSymbolicName [lindex [split $sSymbolicName |] 1]
         array set aSymbolic [list $sPropertyTo $sSymbolicName]
      }
   }

   set sPath \"$sDumpSchemaDirBusiness/SpinnerFormatData.xls\"
   set sFile \"Format Name\\tRegistry Name\\tDescription\\tVersion\\tFile Suffix\\tFile Creator\\tFile Type\\tView Command\\tEdit Command\\tPrint Command\\tMime\\tHidden (boolean)\\tIcon File\\n\"
   set lsFormat $aAdmin(format)
   if { [ llength $lsFormat ] == 0 } {return 0}

   foreach sFormat $lsFormat {
      set sOrigName \"\"
      catch {set sOrigName $aSymbolic($sFormat)} sMsg
      regsub -all \" \" $sFormat \"\" sOrigNameTest
      if {$sOrigNameTest == $sOrigName} {
         set sOrigName $sFormat
      }
      set sDescription [mql print format $sFormat select description dump]
      set bHidden [mql print format $sFormat select hidden dump]
      set sVersion [mql print format $sFormat select version dump]
      set sFileSuffix [mql print format $sFormat select filesuffix dump]
      set sViewCommand [mql print format $sFormat select view dump]
      set sEditCommand [mql print format $sFormat select edit dump]
      set sPrintCommand [mql print format $sFormat select print dump]

      set sMime \"\"
      set sFileCreator \"\"
      set sFileType \"\"
      set lsPrint \"\"
      set lsPrint [split [mql print format $sFormat] \\n]
      
      foreach sPrint $lsPrint {
         set sPrint [string trim $sPrint]
         
         if {[string first \"type\" $sPrint] == 0} {
            regsub \"type\" $sPrint \"\" sFileType
            set sFileType [string trim $sFileType]
            set sFileCreator $sFileType
         } elseif {[string first \"mime\" $sPrint] == 0} {
            regsub \"mime\" $sPrint \"\" sMime
            set sMime [string trim $sMime]
         }
      }
      append sFile \"$sFormat\\t$sOrigName\\t$sDescription\\t$sVersion\\t$sFileSuffix\\t$sFileCreator\\t$sFileType\\t$sViewCommand\\t$sEditCommand\\t$sPrintCommand\\t$sMime\\t$bHidden\\n\"
   }

   set iFile [open $sPath w]
   puts $iFile $sFile
   close $iFile
   if {$bStatus} {puts \"Format data loaded in file $sPath\"}
}

proc pDumpPolicy { } {

   upvar 2 aAdmin aAdmin
    
   global bStatus
   global sDumpSchemaDirBusiness
   global nMxVer

   if {$bStatus} {puts \"Start Processing Spinner Policy ...\"}
    
#  Set up array for symbolic name mapping
#
   set lsPropertyName \"\"
   catch {set lsPropertyName [split [mql print program eServiceSchemaVariableMapping.tcl select property.name dump |] |]} sMsg
   set sTypeReplace \"policy \"

   foreach sPropertyName $lsPropertyName {
      set sSchemaTest [lindex [split $sPropertyName \"_\"] 0]
      if {$sSchemaTest == \"policy\"} {
         set sPropertyTo [mql print program eServiceSchemaVariableMapping.tcl select property\\[$sPropertyName\\].to dump]
         regsub $sTypeReplace $sPropertyTo \"\" sPropertyTo
         regsub \"_\" $sPropertyName \"|\" sSymbolicName
         set sSymbolicName [lindex [split $sSymbolicName |] 1]
         array set aSymbolic [list $sPropertyTo $sSymbolicName]
      }
   }

   set sPath \"$sDumpSchemaDirBusiness/SpinnerPolicyData.xls\"
   set lsPolicy $aAdmin(policy)
   if { [ llength $lsPolicy ] == 0 } {return 0}
   set sFile \"Name\\tRegistry Name\\tDescription\\tRev Sequence (use 'continue' for '...')\\tStore\\tHidden (boolean)\\tTypes (use \\\"|\\\" delim)\\tFormats (use \\\"|\\\" delim)\\tDefault Format\\tLocking (boolean)\\tState Names (in order-use \\\"|\\\" delim)\\tState Registry Names (in order-use \\\"|\\\" delim)\\tAllstate (boolean)\\tIcon file\\n\"

   foreach sPolicy $lsPolicy {
      set sName [mql print policy $sPolicy select name dump]
      set sOrigName \"\"
      catch {set sOrigName $aSymbolic($sPolicy)} sMsg
      regsub -all \" \" $sPolicy \"\" sOrigNameTest
      if {$sOrigNameTest == $sOrigName} {
         set sOrigName $sPolicy
      }
      set sRevSequence [mql print policy $sPolicy select revision dump]
      regsub -all \"\\\\.\\\\.\\\\.\" $sRevSequence \"continue\" sRevSequence
      set bHidden [mql print policy $sPolicy select hidden dump]
      set bLocking [mql print policy $sPolicy select islockingenforced dump]
      
      set slsType [mql print policy $sPolicy select type dump \" | \"]
      set slsFormat [mql print policy $sPolicy select format dump \" | \"]
      set slsState [mql print policy $sPolicy select state dump \" | \"]
      
### State registration reporting fix - MJO 06-09-2005
      set lsState [split [mql print policy $sPolicy select state dump |] |]
      foreach sState $lsState {
      	  array set aStateOrig [list $sState \"\"]
      } 
### End fix

      set lsStateProp [split [mql print policy $sPolicy select property dump |] |]
      foreach sStateProp $lsStateProp {
         if {[string first \"state_\" $sStateProp] == 0} {
            regsub \"state_\" $sStateProp \"\" sStateProp
            regsub \"value \" $sStateProp \"\" sStateProp
            regsub \" \" $sStateProp \"|\" sStateProp
            set lsStateName [split $sStateProp |]
            set sStateOrig [lindex $lsStateName 0]
            set sStateName [lindex $lsStateName 1]
            array set aStateOrig [list $sStateName $sStateOrig]
         }
      }

      set lsState [split $slsState |]
      set slsStateOrig \"\"
      set bFirstFlag TRUE
      foreach sState $lsState {
         set sState [string trim $sState]
         set sStateOrig \"\"
         catch {set sStateOrig $aStateOrig($sState)} sMsg
         regsub -all \" \" $sState \"\" sStateTest
         if {$sStateTest == $sStateOrig} {
            set sStateOrig $sState
         }
         if {$bFirstFlag == \"TRUE\"} {
            set slsStateOrig $sStateOrig
            set bFirstFlag FALSE
         } else {
            append slsStateOrig \" | $sStateOrig\"
         }
      }

      set sStore [mql print policy $sPolicy select store dump]
      set sDefaultFormat [mql print policy $sPolicy select defaultformat dump]
      set sDescription [mql print policy $sPolicy select description dump]
      set bAllstate \"\"
      if {$nMxVer >= 10.8} {set bAllstate [mql print policy $sPolicy select allstate dump]}
      
      append sFile \"$sName\\t$sOrigName\\t$sDescription\\t$sRevSequence\\t$sStore\\t$bHidden\\t$slsType\\t$slsFormat\\t$sDefaultFormat\\t$bLocking\\t$slsState\\t$slsStateOrig\\t$bAllstate\\n\"
   }
   set iFile [open $sPath w]
   puts $iFile $sFile
   close $iFile
   if {$bStatus} {puts \"Policy data loaded in file $sPath\"}
}

proc pDumpPolicyState { } {

   upvar 2 aAdmin aAdmin
    
   global bStatus
   global sDumpSchemaDirBusiness
   global nMxVer

   if {$bStatus} {puts \"Start Processing Spinner Policy State ...\"}

   set sPath \"$sDumpSchemaDirBusiness/SpinnerPolicyStateData.xls\"
   set lsPolicy $aAdmin(policy)
   if { [ llength $lsPolicy ] == 0 } {return 0}
   set sFile \"Policy Name\\tState Name\\tRevision (boolean)\\tVersion (boolean)\\tPromote (boolean)\\tCheckout History (boolean)\\tUsers for Access (use \\\"|\\\" delim)\\tNotify Users (use \\\"|\\\" delim)\\tNotify Message\\tRoute User\\tRoute Message\\tSignatures (use \\\"|\\\" delim)\\tIcon File\\n\"

   foreach sPolicy $lsPolicy {
      set lsState [split [mql print policy $sPolicy select state dump |] |]
      foreach sState $lsState {
         set sRevision [string tolower [mql print policy $sPolicy select state\\[$sState\\].revisionable dump]]
         set sVersion [string tolower [mql print policy $sPolicy select state\\[$sState\\].versionable dump]]
         set sPromote [string tolower [mql print policy $sPolicy select state\\[$sState\\].autopromote dump]]
         set sCheckout [string tolower [mql print policy $sPolicy select state\\[$sState\\].checkouthistory dump]]
         set sNotifyMsg [mql print policy $sPolicy select state\\[$sState\\].notify dump]
         set sRouteMsg [mql print policy $sPolicy select state\\[$sState\\].route dump]
         set slsSignature [mql print policy $sPolicy select state\\[$sState\\].signature dump \" | \"]

         set lsAccess \"\"
         set slsAccess \"\"

         set lsAccessTemp [split [mql print policy $sPolicy select state\\[$sState\\].access] \\n]
         foreach sAccessTemp $lsAccessTemp {
            set sAccessTemp [string trim $sAccessTemp]
            if {[string first \"\\].access\\[\" $sAccessTemp] > -1} {
               set iFirst [expr [string first \"access\\[\" $sAccessTemp] + 7]
               set iSecond [expr [string first \"\\] =\" $sAccessTemp] -1]
               lappend lsAccess [string range $sAccessTemp $iFirst $iSecond]
            }
         }
         set slsAccess [join $lsAccess \" | \"]

         set slsNotify \"\"
         set lsNotifyTemp [split [mql print policy $sPolicy] \\n]
         set bTrip \"FALSE\"
         foreach sNotifyTemp $lsNotifyTemp {
            set sNotifyTemp [string trim $sNotifyTemp]
            if {$sNotifyTemp == \"state $sState\"} {
               set bTrip TRUE
            } elseif {$bTrip == \"TRUE\" && [string range $sNotifyTemp 0 4] == \"state\"} {
               break
            } elseif {$bTrip == \"TRUE\"} {
               if {[string range $sNotifyTemp 0 5] == \"notify\"} {
                  regsub \"notify \" $sNotifyTemp \"\" sNotifyTemp
                  regsub -all \"'\" $sNotifyTemp \"\" sNotifyTemp
                  if {$sNotifyMsg != \"\" } {regsub \" $sNotifyMsg\" $sNotifyTemp \"\" sNotifyTemp}
                  set sNotifyTemp [string trim $sNotifyTemp]
                  regsub -all \",\" $sNotifyTemp \" | \" slsNotify
                  break
               }
            }
         }

         set sRoute \"\"
         set lsRouteTemp [split [mql print policy $sPolicy] \\n]
         set bTrip \"FALSE\"
         foreach sRouteTemp $lsRouteTemp {
            set sRouteTemp [string trim $sRouteTemp]
            if {$sRouteTemp == \"state $sState\"} {
               set bTrip TRUE
            } elseif {$bTrip == \"TRUE\" && [string range $sRouteTemp 0 4] == \"state\"} {
               break
            } elseif {$bTrip == \"TRUE\"} {
               if {[string range $sRouteTemp 0 4] == \"route\"} {
                  regsub \"route \" $sRouteTemp \"\" sRouteTemp
                  regsub -all \"'\" $sRouteTemp \"\" sRouteTemp
                  if {$sRouteMsg != \"\"} {regsub \" $sRouteMsg\" $sRouteTemp \"\" sRouteTemp}
                  set sRoute [string trim $sRouteTemp]
                  break
               }
            }
         }
         append sFile \"$sPolicy\\t$sState\\t$sRevision\\t$sVersion\\t$sPromote\\t$sCheckout\\t$slsAccess\\t$slsNotify\\t$sNotifyMsg\\t$sRoute\\t$sRouteMsg\\t$slsSignature\\n\"
      }
   }
   set iFile [open $sPath w]
   puts $iFile $sFile
   close $iFile
   if {$bStatus} {puts \"Policy State data loaded in file $sPath\"}
}

proc pDumpPolicyStateSignature { } {

   upvar 2 aAdmin aAdmin
    
   global bStatus
   global sDumpSchemaDirBusiness
   global nMxVer

   if {$bStatus} {puts \"Start Processing Spinner Policy State Signature ...\"}
    
   set sPath \"$sDumpSchemaDirBusiness/SpinnerPolicyStateSignatureData.xls\"
   set sFile \"Policy Name\\tState Name\\tSignature Name\\tUsers for Approve (use \\\"|\\\" delim)\\tUsers for Reject (use \\\"|\\\" delim)\\tUsers for Ignore (use \\\"|\\\" delim)\\tBranch State\\tFilter\\n\"
   set lsPolicy $aAdmin(policy)
   if { [ llength $lsPolicy ] == 0 } {return 0}

   foreach sPolicy $lsPolicy {
      set lsState [split [mql print policy $sPolicy select state dump |] |]
      foreach sState $lsState {
         set lsSignature [split [mql print policy $sPolicy select state\\[$sState\\].signature dump |] |]
         foreach sSignature $lsSignature {
            set slsApprove [mql print policy $sPolicy select state\\[$sState\\].signature\\[$sSignature\\].approve dump \" | \"]
            set slsReject [mql print policy $sPolicy select state\\[$sState\\].signature\\[$sSignature\\].reject dump \" | \"]
            set slsIgnore [mql print policy $sPolicy select state\\[$sState\\].signature\\[$sSignature\\].ignore dump \" | \"]

            set sBranch \"\"
            set sFilter \"\"
            set sCatchStringOne \"state $sState\"
            set sCatchStringTwo \"\"
            set bPass false
            set bTrip1 false
            set bTrip2 false

            set lsPrint [split [mql print policy $sPolicy] \\n]

            foreach sPrint $lsPrint {
               set sPrint [string trim $sPrint]

               if {$sCatchStringTwo == \"\"} {
                  if {[string first $sCatchStringOne $sPrint] == 0} {
                     set sCatchStringTwo \"state\"
                  }
               } elseif {[string first $sCatchStringTwo $sPrint] == 0} {
                  break
               }

               if {$sCatchStringTwo != \"\"} {

                  if {[string first \"signature $sSignature\" $sPrint] == 0} {
                     set bPass true
                  } elseif {$bPass == \"true\"} {

                     if {[string first \"branch\" $sPrint] == 0} {
				 #Added if condition to check if Branch value is empty to fix incident 358272 by Solutions Library team on 27th july 08 - start
				 if {$sBranch == \"\"} {
				 #Added if condition to check if Branch value is empty to fix incident 358272 by Solutions Library team on 27th july 08 - end
                        set bTrip1 \"true\"
                        regsub \"branch \" $sPrint \"\" sBranch
                        set sBranch [string trim $sBranch]
                     }
			     #closing brace for 358272 fix
                     } 

                     if {[string first \"filter\" $sPrint] == 0} {
                        set bTrip2 \"true\"
                        regsub \"filter \" $sPrint \"\" sFilter
                        set sFilter [string trim $sFilter]
                     }

                     if {$bTrip1 == \"true\" && $bTrip2 == \"true\"} {
                        break
                     }
                  }
               }
            }
            append sFile \"$sPolicy\\t$sState\\t$sSignature\\t$slsApprove\\t$slsReject\\t$slsIgnore\\t$sBranch\\t$sFilter\\n\"
         }
      }
   }
   set iFile [open $sPath w]
   puts $iFile $sFile
   close $iFile
   if {$bStatus} {puts \"Policy State Signature data loaded in file $sPath\"}
}

proc pDumpCommand { } {

   upvar 2 aAdmin aAdmin
    
   global bStatus
   global sDumpSchemaDirBusiness
   global bDumpMQL

   if {$bStatus} {puts \"Start Processing Spinner Command ...\"}
    
#  Set up array for symbolic name mapping
#
   set lsPropertyName \"\"
   catch {set lsPropertyName [split [mql print program eServiceSchemaVariableMapping.tcl select property.name dump |] |]} sMsg
   set sTypeReplace \"command \"

   foreach sPropertyName $lsPropertyName {
      set sSchemaTest [lindex [split $sPropertyName \"_\"] 0]
      if {$sSchemaTest == \"command\"} {
         set sPropertyTo [mql print program eServiceSchemaVariableMapping.tcl select property\\[$sPropertyName\\].to dump]
         regsub $sTypeReplace $sPropertyTo \"\" sPropertyTo
         regsub \"_\" $sPropertyName \"|\" sSymbolicName
         set sSymbolicName [lindex [split $sSymbolicName |] 1]
         array set aSymbolic [list $sPropertyTo $sSymbolicName]
      }
   }

   set sPath \"$sDumpSchemaDirBusiness/SpinnerCommandData.xls\"
   set lsCommand $aAdmin(command)
   if { [ llength $lsCommand ] == 0 } {return 0}
   set sFile \"Name\\tRegistry Name\\tDescription\\tLabel\\tHref\\tAlt\\tSetting Name (use \\\"|\\\" delim)\\tSetting Value (use \\\"|\\\" delim)\\tUsers (use \\\"|\\\" delim)\\tHidden (boolean)\\tCode\\tIcon File\\n\"
   foreach sCommand $lsCommand {
      set sName [mql print command $sCommand select name dump]
      set sOrigName \"\"
      catch {set sOrigName $aSymbolic($sCommand)} sMsg
      regsub -all \" \" $sCommand \"\" sOrigNameTest
      if {$sOrigNameTest == $sOrigName} {
         set sOrigName $sCommand
      }
      set sDescription [mql print command $sCommand select description dump]
      set sLabel [mql print command $sCommand select label dump]
      set sHref [mql print command $sCommand select href dump]
      set sAlt [mql print command $sCommand select alt dump]
      set sHidden [mql print command $sCommand select hidden dump]
      set sCode [mql print command $sCommand select code dump]
      set slsSettingName [mql print command $sCommand select setting.name dump \" | \"]
      set slsSettingValue [mql print command $sCommand select setting.value dump \" | \"]
      set slsUser [mql print command $sCommand select user dump \" | \"]
      append sFile \"$sName\\t$sOrigName\\t$sDescription\\t$sLabel\\t$sHref\\t$sAlt\\t$slsSettingName\\t$slsSettingValue\\t$slsUser\\t$sHidden\\t$sCode\\n\"
      
      set sCode \"\\n\\n\"
      append sCode \"puts stdout \\\"Add command ...\\\"\"
      append sCode \"\\n\\nset bRegister 1\\n\\n\"
      append sCode \"set sMql \\\"mql add command \\\\\\\"$sName\\\\\\\"\\\"\\n\"
      append sCode \"pProcessMqlCmd \\$bRegister \\$sMql\\n\\n\"
      append sCode \"puts stdout \\\"Mod command ...\\\"\\n\\n\"
      append sCode \"set bRegister 0\\n\\n\"
      append sCode \"set sMql \\\"mql mod command \\\\\\\"$sName\\\\\\\" \\\\\\n\"
      append sCode \"    description \\\\\\\"$sDescription\\\\\\\" \\\\\\n\"
      append sCode \"    label \\\\\\\"$sLabel\\\\\\\" \\\\\\n\"
      regsub -all -- {\\$} $sHref {\\\\\\\\\\$} sHref
      append sCode \"    href \\\\\\\"$sHref\\\\\\\" \\\\\\n\"
      append sCode \"    alt \\\\\\\"$sAlt\\\\\\\" \\\\\\n\"
      set sSetNa [ split $slsSettingName | ]
      set sSetVa [ split $slsSettingValue | ]
      foreach sSetName $sSetNa sSetValue $sSetVa {
          set sSetName [string trim $sSetName]
          set sSetValue [string trim $sSetValue]
          regsub -all -- {\\$} $sSetValue {\\\\\\\\\\$} sSetValue
          append sCode \"    add setting \\\\\\\"$sSetName\\\\\\\" \\\\\\\"$sSetValue\\\\\\\" \\\\\\n\"
      }
      set lUse [split $slsUser |]
      foreach sUse $lUse {
          set sUse [string trim $sUse]
          append sCode \"    add user \\\\\\\"$sUse\\\\\\\" \\\\\\n\"
      }
      append sCode \"  \\\"\\n\\n\"
      append sCode \"pProcessMqlCmd \\$bRegister \\$sMql\\n\\n\"
      lappend lMql $sCode
   }
   set iFile [open $sPath w]
   puts $iFile $sFile
   close $iFile
   if {$bStatus} {puts \"Command data loaded in file $sPath\"}
   set lMql [join $lMql \\n]
   if {$bDumpMQL} {pfile_write [file join $sDumpSchemaDirBusiness command.tcl] $lMql}
}

proc pDumpInquiry { } {

   upvar 2 aAdmin aAdmin
    
   global bStatus
   global sDumpSchemaDirBusiness
   global bDumpMQL

   if {$bStatus} {puts \"Start Processing Spinner Inquiry ...\"}
    
#  Set up array for symbolic name mapping
#
   set lsPropertyName \"\"
   catch {set lsPropertyName [split [mql print program eServiceSchemaVariableMapping.tcl select property.name dump |] |]} sMsg
   set sTypeReplace \"inquiry \"

   foreach sPropertyName $lsPropertyName {
      set sSchemaTest [lindex [split $sPropertyName \"_\"] 0]
      if {$sSchemaTest == \"inquiry\"} {
         set sPropertyTo [mql print program eServiceSchemaVariableMapping.tcl select property\\[$sPropertyName\\].to dump]
         regsub $sTypeReplace $sPropertyTo \"\" sPropertyTo
         regsub \"_\" $sPropertyName \"|\" sSymbolicName
         set sSymbolicName [lindex [split $sSymbolicName |] 1]
         array set aSymbolic [list $sPropertyTo $sSymbolicName]
      }
   }

   set sPath \"$sDumpSchemaDirBusiness/SpinnerInquiryData.xls\"
   set lsInquiry $aAdmin(inquiry)
   if { [ llength $lsInquiry ] == 0 } {return 0}
   set sFile \"Name\\tRegistry Name\\tDescription\\tPattern\\tFormat\\tArgument Name (use \\\"|\\\" delim)\\tArgument Value (use \\\"|\\\" delim)\\tCode (use \\\"<ESC>\\\" & \\\"<NEWLINE>\\\")\\tHidden (boolean)\\tIcon File\\n\"
   set lMql [list ]
   foreach sInquiry $lsInquiry {
      set sName [mql print inquiry $sInquiry select name dump]
      set sOrigName \"\"
      catch {set sOrigName $aSymbolic($sInquiry)} sMsg
      regsub -all \" \" $sInquiry \"\" sOrigNameTest
      if {$sOrigNameTest == $sOrigName} {
         set sOrigName $sInquiry
      }
      set sDescription [mql print inquiry $sInquiry select description dump]
      set sHidden [mql print inquiry $sInquiry select hidden dump]
      set slsPattern [mql print inquiry $sInquiry select pattern dump]
      set slsFormat [mql print inquiry $sInquiry select format dump]
      set sCode [mql print inquiry $sInquiry select code dump]
      regsub -all \"\\\\\\\\\" $sCode \"<ESC>\" sCode
      regsub -all \"\\n\" $sCode \"<NEWLINE>\" sCode
      set slsSettingName [mql print inquiry $sInquiry select argument.name dump \" | \"]
      set slsSettingValue [mql print inquiry $sInquiry select argument.value dump \" | \"]
      append sFile \"$sName\\t$sOrigName\\t$sDescription\\t$slsPattern\\t$slsFormat\\t$slsSettingName\\t$slsSettingValue\\t$sCode\\t$sHidden\\n\"

     set sCodeI \"\\n\\n\"
     append sCodeI \"puts stdout \\\"Add inquiry ...\\\"\"
     append sCodeI \"\\n\\nset bRegister 1\\n\\n\"
     append sCodeI \"set sMql \\\"mql add inquiry \\\\\\\"$sName\\\\\\\"\\\"\\n\"
     append sCodeI \"pProcessMqlCmd \\$bRegister \\$sMql\\n\\n\"
     append sCodeI \"puts stdout \\\"Mod inquiry ...\\\"\\n\\n\"
     append sCodeI \"set bRegister 0\\n\\n\"
     append sCodeI \"set sMql \\\"mql mod inquiry \\\\\\\"$sName\\\\\\\" \\\\\\n\"
     append sCodeI \"    description \\\\\\\"$sDescription\\\\\\\" \\\\\\n\"
     regsub -all -- {\\$} $slsPattern {\\\\\\\\\\$} sPat
     append sCodeI \"    pattern \\\\\\\"$sPat\\\\\\\" \\\\\\n\"
     regsub -all -- {\\$} $slsFormat {\\\\\\\\\\$} sFor
     append sCodeI \"    format \\\\\\\"$sFor\\\\\\\" \\\\\\n\"
     regsub -all -- {\\$} $sCode {\\\\\\\\\\$} sCod
     append sCodeI \"    code \\\\\\\"$sCod\\\\\\\" \\\\\\n\"
     set sSetNa [ split $slsSettingName | ]
     set sSetVa [ split $slsSettingValue | ]
     foreach sSetName $sSetNa sSetValue $sSetVa {
        set sSetName [string trim $sSetName]
        set sSetValue [string trim $sSetValue]
        regsub -all -- {\\$} $sSetValue {\\\\\\\\\\$} sSetValue
        append sCodeI \"    add argument \\\\\\\"$sSetName\\\\\\\" \\\\\\\"$sSetValue\\\\\\\" \\\\\\n\"
     }
     append sCodeI \"  \\\"\\n\\n\"
     append sCodeI \"pProcessMqlCmd \\$bRegister \\$sMql\\n\\n\"
     lappend lMql $sCodeI
   }
   set iFile [open $sPath w]
   puts $iFile $sFile
   close $iFile
   if {$bStatus} {puts \"Inquiry data loaded in file $sPath\"}
   set lMql [join $lMql \\n]
   if {$bDumpMQL} {pfile_write [file join $sDumpSchemaDirBusiness inquiry.tcl] $lMql}
}

proc pDumpMenu { } {

   upvar 2 aAdmin aAdmin
    
   global bStatus
   global sDumpSchemaDirBusiness
   global bDumpMQL

   if {$bStatus} {puts \"Start Processing Spinner Menu ...\"}
    
#  Set up array for symbolic name mapping
#
   set lsPropertyName \"\"
   catch {set lsPropertyName [split [mql print program eServiceSchemaVariableMapping.tcl select property.name dump |] |]} sMsg
   set sTypeReplace \"menu \"

   foreach sPropertyName $lsPropertyName {
      set sSchemaTest [lindex [split $sPropertyName \"_\"] 0]
      if {$sSchemaTest == \"menu\"} {
         set sPropertyTo [mql print program eServiceSchemaVariableMapping.tcl select property\\[$sPropertyName\\].to dump]
         regsub $sTypeReplace $sPropertyTo \"\" sPropertyTo
         regsub \"_\" $sPropertyName \"|\" sSymbolicName
         set sSymbolicName [lindex [split $sSymbolicName |] 1]
         array set aSymbolic [list $sPropertyTo $sSymbolicName]
      }
   }

   set sPath \"$sDumpSchemaDirBusiness/SpinnerMenuData.xls\"
   set lsMenu $aAdmin(menu)
   if { [ llength $lsMenu ] == 0 } {return 0}
   set sFile \"Name\\tRegistry Name\\tDescription\\tLabel\\tHref\\tAlt\\tSetting Name (use '|' delim)\\tSetting Value (use '|' delim)\\tCommand/Menu Names (in order-use '|' delim)\\t(not used)\\tHidden (boolean)\\tIcon File\\n\"
   foreach sMenu $lsMenu {
      set sName [mql print menu $sMenu select name dump]
      set sOrigName \"\"
      catch {set sOrigName $aSymbolic($sMenu)} sMsg
      regsub -all \" \" $sMenu \"\" sOrigNameTest
      if {$sOrigNameTest == $sOrigName} {
         set sOrigName $sMenu
      }
      set sDescription [mql print menu $sMenu select description dump]
      set sLabel [mql print menu $sMenu select label dump]
      set sHref [mql print menu $sMenu select href dump]
      set sAlt [mql print menu $sMenu select alt dump]
      set sHidden [mql print menu $sMenu select hidden dump]
      set slsSettingName [mql print menu $sMenu select setting.name dump \" | \"]
      set slsSettingValue [mql print menu $sMenu select setting.value dump \" | \"]
      set slsCmdMenu [mql print menu $sMenu select child dump \" | \"]
      set slsCommand [mql print menu $sMenu select command dump \" | \"]
      set slsMenu [mql print menu $sMenu select menu dump \" | \"]
      append sFile \"$sName\\t$sOrigName\\t$sDescription\\t$sLabel\\t$sHref\\t$sAlt\\t$slsSettingName\\t$slsSettingValue\\t$slsCmdMenu\\t\\t$sHidden\\n\"
      
      set sCode \"\\n\\n\"
      append sCode \"puts stdout \\\"Add menu ...\\\"\"
      append sCode \"\\n\\nset bRegister 1\\n\\n\"
      append sCode \"set sMql \\\"mql add menu \\\\\\\"$sName\\\\\\\"\\\"\\n\"
      append sCode \"pProcessMqlCmd \\$bRegister \\$sMql\\n\\n\"
      append sCode \"puts stdout \\\"Mod menu ...\\\"\\n\\n\"
      append sCode \"set bRegister 0\\n\\n\"
      append sCode \"set sMql \\\"mql mod menu \\\\\\\"$sName\\\\\\\" \\\\\\n\"
      append sCode \"    description \\\\\\\"$sDescription\\\\\\\" \\\\\\n\"
      append sCode \"    label \\\\\\\"$sLabel\\\\\\\" \\\\\\n\"
      regsub -all -- {\\$} $sHref {\\\\\\\\\\$} sHref
      append sCode \"    href \\\\\\\"$sHref\\\\\\\" \\\\\\n\"
      append sCode \"    alt \\\\\\\"$sAlt\\\\\\\" \\\\\\n\"
      set sSetNa [ split $slsSettingName | ]
      set sSetVa [ split $slsSettingValue | ]
      foreach sSetName $sSetNa sSetValue $sSetVa {
          set sSetName [string trim $sSetName]
          set sSetValue [string trim $sSetValue]
          regsub -all -- {\\$} $sSetValue {\\\\\\\\\\$} sSetValue
          append sCode \"    add setting \\\\\\\"$sSetName\\\\\\\" \\\\\\\"$sSetValue\\\\\\\" \\\\\\n\"
      }
      set lCom [split $slsCommand |]
      foreach sCom $lCom {
          set sCom [string trim $sCom]
          append sCode \"    add command \\\\\\\"$sCom\\\\\\\" \\\\\\n\"
      }
      set lMen [split $slsMenu |]
      foreach sMen $lMen {
          set sMen [string trim $sMen]
          append sCode \"    add menu \\\\\\\"$sMen\\\\\\\" \\\\\\n\"
      }
      append sCode \"  \\\"\\n\\n\"
      append sCode \"pProcessMqlCmd \\$bRegister \\$sMql\\n\\n\"
      lappend lMql $sCode
   }
   set iFile [open $sPath w]
   puts $iFile $sFile
   close $iFile
   if {$bStatus} {puts \"Menu data loaded in file $sPath\"}
   set lMql [join $lMql \\n]
   if {$bDumpMQL} {pfile_write [file join $sDumpSchemaDirBusiness menu.tcl] $lMql}
}

proc pDumpTable { } {

   upvar 2 aAdmin aAdmin
    
   global bStatus
   global sDumpSchemaDirBusiness

   if {$bStatus} {puts \"Start Processing Spinner Table ...\"}

#  Set up array for symbolic name mapping
#
   set lsPropertyName \"\"
   catch {set lsPropertyName [split [mql print program eServiceSchemaVariableMapping.tcl select property.name dump |] |]} sMsg
   set sTypeReplace \"table \"

   foreach sPropertyName $lsPropertyName {
      set sSchemaTest [lindex [split $sPropertyName \"_\"] 0]
      if {$sSchemaTest == \"table\"} {
         set sPropertyTo [mql print program eServiceSchemaVariableMapping.tcl select property\\[$sPropertyName\\].to dump]
         regsub $sTypeReplace $sPropertyTo \"\" sPropertyTo
         regsub \"_\" $sPropertyName \"|\" sSymbolicName
         set sSymbolicName [lindex [split $sSymbolicName |] 1]
         array set aSymbolic [list $sPropertyTo $sSymbolicName]
      }
   }

   set sPath \"$sDumpSchemaDirBusiness/SpinnerTableData.xls\"
   set lsTable $aAdmin(table)
   if { [ llength $lsTable ] == 0 } {return 0}
   set sFile \"Name\\tRegistry Name\\tDescription\\tColumn Names (in order-use \\\"|\\\" delim)\\tHidden (boolean)\\n\"
   foreach sTable $lsTable {
      set sName [mql print table $sTable system select name dump]
      for {set i 0} {$i < [string length $sName]} {incr i} {
         if {[string range $sName $i $i] == \" \"} {
            regsub \" \" $sName \"<SPACE>\" sName
         } else {
            break
         }
      }
      set sOrigName \"\"
      catch {set sOrigName $aSymbolic($sTable)} sMsg
      regsub -all \" \" $sTable \"\" sOrigNameTest
      if {$sOrigNameTest == $sOrigName} {
         set sOrigName $sTable
      }
      set sDescription [mql print table $sTable system select description dump]
      set sHidden [mql print table $sTable system select hidden dump]
      set slsColumn [mql print table $sTable system select column dump \" | \"]
      for {set i 0} {$i < [string length $slsColumn]} {incr i} {
         if {[string range $slsColumn $i $i] == \" \"} {
            regsub \" \" $slsColumn \"<SPACE>\" slsColumn
         } else {
            break
         }
      }
      regsub -all \" \\\\\\|  \" $slsColumn \" \\| <SPACE>\" slsColumn
      append sFile \"$sName\\t$sOrigName\\t$sDescription\\t$slsColumn\\t$sHidden\\n\"
   }
   set iFile [open $sPath w]
   puts $iFile $sFile
   close $iFile
   if {$bStatus} {puts \"Table data loaded in file $sPath\"}
}

proc pDumpTableColumn { } {

   upvar 2 aAdmin aAdmin
    
   global bStatus
   global sDumpSchemaDirBusiness
   global nMxVer

   if {$bStatus} {puts \"Start Processing Spinner Table Column ...\"}
    
   set sPath \"$sDumpSchemaDirBusiness/SpinnerTableColumnData.xls\"
   set lsTable $aAdmin(table)
   if { [ llength $lsTable ] == 0 } {return 0}
   set sFile \"Table Name\\tColumn Name\\tColumn Label\\tCol Description\\tExpression Type (bus or \\\"\\\" / rel)\\tExpression\\tHref\\tSetting Names (use \\\"|\\\" delim)\\tSetting Values (use \\\"|\\\" delim)\\tUsers (use \\\"|\\\" delim)\\tAlt\\tRange\\tUpdate\\tSortType (alpha / numeric / other / none or \\\"\\\")\\n\"
   foreach sTable $lsTable {
      set lsColumn [split [mql print table $sTable system select column dump |] |]
      foreach sColumn $lsColumn {
         set sName $sColumn
         for {set i 0} {$i < [string length $sName]} {incr i} {
            if {[string range $sName $i $i] == \" \"} {
               regsub \" \" $sName \"<SPACE>\" sName
            } else {
               break
            }
         }
         set sLabel [mql print table $sTable system select column\\[$sColumn\\].label dump]
         set sDescription [mql print table $sTable system select column\\[$sColumn\\].description dump]
         set sExpressionType [mql print table $sTable system select column\\[$sColumn\\].expressiontype dump]
         set sExpression [mql print table $sTable system select column\\[$sColumn\\].expression dump]
         set sHref [mql print table $sTable system select column\\[$sColumn\\].href dump]
         set sAlt [mql print table $sTable system select column\\[$sColumn\\].alt dump]
         set sRange [mql print table $sTable system select column\\[$sColumn\\].range dump]
         set sUpdate [mql print table $sTable system select column\\[$sColumn\\].update dump]
         set slsSettingName [mql print table $sTable system select column\\[$sColumn\\].setting dump \" | \"]
         set slsSettingValue [mql print table $sTable system select column\\[$sColumn\\].setting.value dump \" | \"]
         if {$nMxVer >= 9.6} {
            set slsUser [mql print table $sTable system select column\\[$sColumn\\].user dump \" | \"]
            set sAlt [mql print table $sTable system select column\\[$sColumn\\].alt dump]
            set sRange [mql print table $sTable system select column\\[$sColumn\\].range dump]
            set sUpdate [mql print table $sTable system select column\\[$sColumn\\].update dump]
            set sSortType \"none\"
            set lsPrint [split [mql print table $sTable system] \\n]
            set bTrip \"FALSE\"
            foreach sPrint $lsPrint {
               set sPrint [string trim $sPrint]
               if {[string range $sPrint 0 3] == \"name\" && [string first $sColumn $sPrint] > 3} {
                  set bTrip TRUE
               } elseif {$bTrip && [string range $sPrint 0 3] == \"name\"} {
                  break
               } elseif {$bTrip} {
                  if {[string range $sPrint 0 7] == \"sorttype\"} {
                     regsub \"sorttype\" $sPrint \"\" sPrint
                     set sSortType [string trim $sPrint]
                     break
                  }
               } 
            }
         } else {
            set slsUser \"\"
            set sAlt \"\"
            set sRange \"\"
            set sUpdate \"\"
            set sSortType \"\"
         }
         set sTableName $sTable
         for {set i 0} {$i < [string length $sTableName]} {incr i} {
            if {[string range $sTableName $i $i] == \" \"} {
               regsub \" \" $sTableName \"<SPACE>\" sTableName
            } else {
               break
            }
         }
         append sFile \"$sTableName\\t$sName\\t$sLabel\\t$sDescription\\t$sExpressionType\\t$sExpression\\t$sHref\\t$slsSettingName\\t$slsSettingValue\\t$slsUser\\t$sAlt\\t$sRange\\t$sUpdate\\t$sSortType\\n\"
      }
   }
   set iFile [open $sPath w]
   puts $iFile $sFile
   close $iFile
   if {$bStatus} {puts \"Table Column data loaded in file $sPath\"}
}

proc pDumpDimension { } {

   upvar 2 aAdmin aAdmin
    
   global bStatus
   global sDumpSchemaDirBusiness

   if {$bStatus} {puts \"Start Processing Spinner Dimension ...\"}

#  Set up array for symbolic name mapping
#
   set lsPropertyName \"\"
   catch {set lsPropertyName [split [mql print program eServiceSchemaVariableMapping.tcl select property.name dump |] |]} sMsg
   set sTypeReplace \"dimension \"

   foreach sPropertyName $lsPropertyName {
      set sSchemaTest [lindex [split $sPropertyName \"_\"] 0]
      if {$sSchemaTest == \"dimension\"} {
         set sPropertyTo [mql print program eServiceSchemaVariableMapping.tcl select property\\[$sPropertyName\\].to dump]
         regsub $sTypeReplace $sPropertyTo \"\" sPropertyTo
         regsub \"_\" $sPropertyName \"|\" sSymbolicName
         set sSymbolicName [lindex [split $sSymbolicName |] 1]
         array set aSymbolic [list $sPropertyTo $sSymbolicName]
      }
   }

   set sPath \"$sDumpSchemaDirBusiness/SpinnerDimensionData.xls\"
   set lsDimension $aAdmin(dimension)
   if { [ llength $lsDimension ] == 0 } {return 0}
   set sFile \"Name\\tRegistry Name\\tDescription\\tUnit Names (in order-use \\\"|\\\" delim)\\tHidden (boolean)\\n\"
   foreach sDimension $lsDimension {
      set sName [mql print dimension $sDimension select name dump]
      set sOrigName \"\"
      catch {set sOrigName $aSymbolic($sDimension)} sMsg
      regsub -all \" \" $sDimension \"\" sOrigNameTest
      if {$sOrigNameTest == $sOrigName} {
         set sOrigName $sDimension
      }
      set sDescription [mql print dimension $sDimension select description dump]
      set sHidden [mql print dimension $sDimension select hidden dump]
      set slsUnit [mql print dimension $sDimension select \"unit\" dump \" | \"]
      append sFile \"$sName\\t$sOrigName\\t$sDescription\\t$slsUnit\\t$sHidden\\n\"
   }
   set iFile [open $sPath w]
   puts $iFile $sFile
   close $iFile
   if {$bStatus} {puts \"Dimension data loaded in file $sPath\"}
}

proc pDumpDimensionUnit { } {

   upvar 2 aAdmin aAdmin
    
   global bStatus
   global sDumpSchemaDirBusiness
   global nMxVer

   if {$bStatus} {puts \"Start Processing Spinner Dimension Unit ...\"}
    
   set sPath \"$sDumpSchemaDirBusiness/SpinnerDimensionUnitData.xls\"
   set lsDimension $aAdmin(dimension)
   if { [ llength $lsDimension ] == 0 } {return 0}
   set sFile \"Dimension Name\\tUnit Name\\tUnit Label\\tUnit Description\\tMultiplier (real)\\tOffset (real)\\tSetting Names (use \\\"|\\\" delim)\\tSetting Values (use \\\"|\\\" delim)\\tSystemName (use \\\"|\\\" delim)\\tSystemUnit (use \\\"|\\\" delim)\\tDefault (boolean)\\n\"
   foreach sDimension $lsDimension {
      set lsUnit [split [mql print dimension $sDimension select unit dump |] |]
      foreach sUnit $lsUnit {
         set sName $sUnit
         set sLabel [mql print dimension $sDimension select unit\\[$sUnit\\].label dump]
         set sDescription [mql print dimension $sDimension select unit\\[$sUnit\\].description dump]
         set sMultiplier [mql print dimension $sDimension select unit\\[$sUnit\\].multiplier dump]
         set sOffset [mql print dimension $sDimension select unit\\[$sUnit\\].offset dump]
         set slsSettingName [mql print dimension $sDimension select unit\\[$sUnit\\].setting dump \" | \"]
         set slsSettingValue [mql print dimension $sDimension select unit\\[$sUnit\\].setting.value dump \" | \"]
         set sDefault [mql print dimension $sDimension select unit\\[$sUnit\\].default dump]
         set lsSysName [list ]
         set lsSysUnit [list ]
         set lsPrint [split [mql print dimension \"$sDimension\"] \\n]
         set bTrip \"FALSE\"
         foreach sPrint $lsPrint {
            set sPrint [string trim $sPrint]
            if {[string range $sPrint 0 3] == \"unit\" && [string first $sUnit $sPrint] > 3} {
               set bTrip TRUE
            } elseif {$bTrip && [string range $sPrint 0 3] == \"unit\"} {
               break
            } elseif {$bTrip} {
               if {[string range $sPrint 0 5] == \"system\"} {
                  regsub \"system\" $sPrint \"\" sPrint
                  regsub \" to unit \" $sPrint \"\\|\" sPrint
                  set lsSysNameUnit [split $sPrint \"|\"]
                  lappend lsSysName [string trim [lindex $lsSysNameUnit 0]]
                  lappend lsSysUnit [string trim [lindex $lsSysNameUnit 1]]
               }
            }
         }
         set slsSysName [join $lsSysName \" | \"]
         set slsSysUnit [join $lsSysUnit \" | \"]
         append sFile \"$sDimension\\t$sName\\t$sLabel\\t$sDescription\\t$sMultiplier\\t$sOffset\\t$slsSettingName\\t$slsSettingValue\\t$slsSysName\\t$slsSysUnit\\t$sDefault\\n\"
      }
   }
   set iFile [open $sPath w]
   puts $iFile $sFile
   close $iFile
   if {$bStatus} {puts \"Dimension Unit data loaded in file $sPath\"}
}

proc pDumpTrigger { } {

   upvar 2 aAdmin aAdmin
    
   global bStatus
   global sDumpSchemaDirBusiness
   global nMxVer

   if {$bStatus} {puts \"Start Processing Spinner Trigger ...\"}
    
   set sPath \"$sDumpSchemaDirBusiness/SpinnerTriggerData.xls\"
   set sFile \"Schema Type\\tSchema Name\\tState (for Policy)\\tTrigger Event\\tTrigger Type (check / override / action)\\tProgram\\tInput\\n\"
   set lsType [list attribute type relationship policy]

   foreach sType $lsType {
      set lsName $aAdmin($sType)
      if {[ llength $lsName ] == 0} {continue}

      foreach sName $lsName {
   
         if {$sType == \"policy\"} {
            set lsState [split [mql print policy $sName select state dump |] |]
            set lsState [lsort -decreasing $lsState]
            set lsCatchTest [list action check trigger]
         } else {
            set lsCatchTest trigger
         }
   
         set sStateName \"\"
         set sProgram \"\"
         set sInput \"\"
         set lsPrint [split [mql print $sType $sName] \\n]
   
         foreach sPrint $lsPrint {                         
            set sPrint [string trim $sPrint]
   
            if {$sType == \"policy\"} {
               if {[string first \"state\" $sPrint] == 0} {
                  foreach sState $lsState {
                     if {[string first \"state $sState\" $sPrint] == 0} {
                        set sStateName $sState
                        break
                     }
                  }
               }
            }
                        
            set bCatchTest false
            
            foreach sCatchTest $lsCatchTest {
               if {[string first \"$sCatchTest \" $sPrint] == 0} {
                  set bCatchTest true
                  break
               }
            }
            
            if {$bCatchTest == \"true\"} {
               regsub \"$sCatchTest \" $sPrint \"\" sPrint
               
               if {$sCatchTest == \"trigger\"} {

# Change commented line below below with 2 following it
#                     set lsTrig [split $sPrint \",\"]
                  regsub -all \"\\\\\\),\" $sPrint \"|\" sPrint
                  set lsTrig [split $sPrint \"|\"]
# End Change - 04/20/2005 MJOsterman

                  foreach sTrig $lsTrig {
                     regsub \":\" $sTrig \"|\" sTrig
                     set lslsTrig [split $sTrig |]
                     set sTrigEventType [string tolower [lindex $lslsTrig 0]]
                     
                     if {$sTrigEventType == \"checkincheck\"} {
                        set sTrigEvent checkin
                        set sTrigType check
                     } elseif {$sTrigEventType == \"checkinaction\"} {
                        set sTrigEvent checkin
                        set sTrigType action
                     } elseif {$sTrigEventType == \"checkinoverride\"} {
                        set sTrigEvent checkin
                        set sTrigType override
                     } elseif {$sTrigEventType == \"checkoutcheck\"} {
                        set sTrigEvent checkout
                        set sTrigType check
                     } elseif {$sTrigEventType == \"checkoutaction\"} {
                        set sTrigEvent checkout
                        set sTrigType action
                     } elseif {$sTrigEventType == \"checkoutoverride\"} {
                        set sTrigEvent checkout
                        set sTrigType override
                     } elseif {[regsub \"check\" $sTrigEventType \"\" sTrigEvent] == 1} {
                        set sTrigType \"check\"
                     } elseif {[regsub \"action\" $sTrigEventType \"\" sTrigEvent] == 1} {
                        set sTrigType \"action\"
                     } elseif {[regsub \"override\" $sTrigEventType \"\" sTrigEvent] == 1} {
                        set sTrigType \"override\"
                     }
                     
                     set slsTrigProg [lindex $lslsTrig 1]
                     regsub \"\\\\(\" $slsTrigProg \"|\" slsTrigProg
                     set lslsTrigProg [split $slsTrigProg |]
                     set sProgram [lindex $lslsTrigProg 0]
                     set sInput [lindex $lslsTrigProg 1]
                     regsub \"\\\\)\" $sInput \"\" sInput
                     append sFile \"$sType\\t$sName\\t$sStateName\\t$sTrigEvent\\t$sTrigType\\t$sProgram\\t$sInput\\n\"
                  }
               } else {
                  set sTrigType $sCatchTest
                  regsub \" input \" $sPrint \"|\" sPrint
                  set lsTrig [split $sPrint |]
                  set sProgram [string trim [lindex $lsTrig 0]]
                  regsub -all \"'\" $sProgram \"\" sProgram
                  set sInput [string trim [lindex $lsTrig 1]]
                  regsub -all \"'\" $sInput \"\" sInput
                  append sFile \"$sType\\t$sName\\t$sStateName\\tevent\\t$sTrigType\\t$sProgram\\t$sInput\\n\"
               }
            }
         }
      }
   }

   set iFile [open $sPath w]
   puts $iFile $sFile
   close $iFile
   if {$bStatus} {puts \"Trigger data loaded in file $sPath\"}
}

#*******************************************************************************
# Procedure:   pSpinnerObjects
#
# Description: print details about the admin type and create spreadsheets
#
# Returns:     None.
#*******************************************************************************
proc pSpinnerObject { lList } {

    global sDumpSchemaDirObjects
    set sType [lindex $lList 0]
    set sVault [lindex $lList 1]
    set nLimit [lindex $lList 2]
    set sDelimit \"\\t\"
    set bContinue TRUE
    
    set fname \"${sType}_object.xls\" 
    set sCmd \"mql print type \\\"$sType\\\" select attribute dump \\\\t\"
    if {[catch {eval $sCmd} sMsg] == 0} {
        set sAttr1 $sMsg
    } else {
        puts \"Error with cmd $sCmd, message is:\\n$sMsg\"
        set bContinue FALSE
    }
    
    if {$bContinue} {
        set lBosData [list \"Type\\tName\\tRev\\t\\t\\tPolicy\\tState\\tVault\\tOwner\\tdescription\\t$sAttr1\"]
        set sCmd \"mql temp query bus \\\"$sType\\\" * * vault \\\"$sVault\\\" limit $nLimit select \\
            name grant policy current vault owner description attribute.value dump \\\\t recordsep <NEWRECORD>\"
        if { [ catch { eval $sCmd } sOutstr ] == 0 } {
	# Modified by Solution Library for the New Line Feeder error - Start
	     regsub -all \"\\n\" $sOutstr {<NEWLINE>} sOutstr
	     regsub -all \"<NEWRECORD>\" $sOutstr  \"\\n\" sOutstr
	# Modified by Solution Library for the New Line Feeder error - End
            lappend lBosData $sOutstr
            pfile_write [file join $sDumpSchemaDirObjects $fname] [join $lBosData \\n]
        } else {
            puts \"Error with cmd $sCmd, message is:\\n$sOutstr\\n\"
        }
    }
    puts \"Finish Processing \\\"$sType\\\"\"
    return
}

################################################################################
#
#   Parameters :
#   Return     :
#
proc pGet_BOAdminRel { sList } {

    global aDirs
#    $aDirs(sDumpSchemaDirRelationships)
#    global sDumpSchemaDirRelationships
    set sDumpSchemaDirRelationships $aDirs(sDumpSchemaDirRelationships)

    foreach sList1 $sList {
        # skip if abstract
        set sSplitRel [split $sList1 ,]
        set sType     [ string trim [ lindex \"$sSplitRel\" 0 ] ]
        set sRel      [ string trim [ lindex \"$sSplitRel\" 1 ] ]

        set sValue1 \"$sRel\"
        set sValue2 [join $sValue1 _]
        set fname \"rel_$sValue2\"
        puts \"Start backup of Business Object Relation $sRel ...\"
        set p_filename \"$sDumpSchemaDirRelationships/$fname\\.xls\"
        set bHeader TRUE
        if {[catch {set sTest $aFile($p_filename)} sMsg] == 0} {
           set p_file [open $p_filename a+]
           set bHeader FALSE
        } else {
           set p_file [open $p_filename w]
           set aFile($p_filename) $p_filename
        }
        set sQuery [ split [ mql temp query bus \"$sType\" * * select id dump | ] \\n ] 


        #
        # WRITE HEADER INFO INTO OUTPUT FILE.
        #
        if {$bHeader} {
        set sCmd \"mql print relationship \\\"$sRel\\\" select attribute dump \\\\t\"

        if {[catch {eval $sCmd} sMsg] == 0} {
            set sAttr1 $sMsg
        } else {
            puts \"Error with cmd $sCmd, message is:\\n$sMsg\"
            continue
        }

        if { \"$sAttr1\" == \"\" } {
           set lBos \"FromType\\tFromName\\tFromRev\\tToType\\tToName\\tToRev\\tDirection\\tRelationship\"
        } else {
           set lBos \"FromType\\tFromName\\tFromRev\\tToType\\tToName\\tToRev\\tDirection\\tRelationship\\t$sAttr1\"
        }        	
        puts $p_file \"$lBos\"
        }

        foreach sValue $sQuery { 
           regsub -all \"\\{\" $sValue \"\" sValue1
            regsub -all \"\\}\" $sValue1 \"\" sType1

            set lsLine          [split \"$sType1\" \"|\" ] 
            set sFromType       [ string trim [ lindex \"$lsLine\" 0 ] ]
            set sFromName       [ string trim [ lindex \"$lsLine\" 1 ] ]
            set sFromRev        [ string trim [ lindex \"$lsLine\" 2 ] ]

            if { \"$sAttr1\" == \"\" } {
#                set sExpand  [ split [ mql expand bus \"$sFromType\" \"$sFromName\" \"$sFromRev\" relationship \"$sRel\" dump |  ] \\n ]

                set sCmd  \"mql expand bus \\\"$sFromType\\\" \\\"$sFromName\\\" \\\"$sFromRev\\\" relationship \\\"$sRel\\\" dump |\"
                if {[catch {eval $sCmd} sMsg] == 0} {
                    set sExpand [split $sMsg \\n]
                } else {
                    puts \"Error with cmd $sCmd, message is:\\n$sMsg\"
                    continue
                }

                foreach sExpand1 $sExpand { 
                    regsub -all \"\\{\" $sExpand1 \"\" sExpand2
                    regsub -all \"\\}\" $sExpand2 \"\" sExpand1
                    set lsLine2       [split \"$sExpand1\" \"|\" ] 
                    set sToDir        [ string trim [ lindex \"$lsLine2\" 2 ] ]
                    set sToType       [ string trim [ lindex \"$lsLine2\" 3 ] ]
                    set sToName       [ string trim [ lindex \"$lsLine2\" 4 ] ]
                    set sToRev        [ string trim [ lindex \"$lsLine2\" 5 ] ]
                    if { \"$sToDir\" != \"from\" || $sFromType != $sToType  } {
                        set lBos \"$sFromType\\t$sFromName\\t$sFromRev\\t$sToType\\t$sToName\\t$sToRev\\t$sToDir\\t$sRel\"
                        puts $p_file \"$lBos\"
                    }
               }
            } else {
		# Modified by Solution Library for the New Line Feeder error
                set sCmd  \"mql expand bus \\\"$sFromType\\\" \\\"$sFromName\\\" \\\"$sFromRev\\\" relationship \\\"$sRel\\\" select relationship attribute.value dump | recordsep \\\"<NEWRECORD>\\\"\"
                if {[catch {eval $sCmd} sMsg] == 0} {
		# Modified by Solution Library for the New Line Feeder error - Start
                    if { $sMsg != \"\" } {
                        set sMsg [ string trimright $sMsg \"<NEWRECORD>\"]
			                  regsub -all \"\\n\" $sMsg {<NEWLINE>} sMsg
			                  regsub -all \"<NEWRECORD>\" $sMsg  \"\\n\" sMsg
		# Modified by Solution Library for the New Line Feeder error - End
			                  set sExpand [split $sMsg \"\\n\"]
			              } else {
			                  set sExpand \"\"
			              }

                } else {
                    puts \"Error with cmd $sCmd, message is:\\n$sMsg\"
                    continue
                }

                foreach sExpand1 $sExpand { 
                    regsub -all \"\\{\" $sExpand1 \"\" sExpand2
                    regsub -all \"\\}\" $sExpand2 \"\" sExpand1
                    set lsLine2       [split \"$sExpand1\" \"|\" ] 
                    set sToDir        [ string trim [ lindex \"$lsLine2\" 2 ] ]
                    set sToType       [ string trim [ lindex \"$lsLine2\" 3 ] ]
                    set sToName       [ string trim [ lindex \"$lsLine2\" 4 ] ]
                    set sToRev        [ string trim [ lindex \"$lsLine2\" 5 ] ]
                    set A1            [ lrange  \"$lsLine2\" 6 end ]
                    set A3            \"\"

                    foreach A2 $A1 {
                        append A3 \"\\t$A2\"
                    }

                    if { \"$sToDir\" != \"from\" || $sFromType != $sToType  } {
                        set lBos \"$sFromType\\t$sFromName\\t$sFromRev\\t$sToType\\t$sToName\\t$sToRev\\t$sToDir\\t$sRel$A3\"
                        puts $p_file \"$lBos\"
                    }
                }
            }
        }
        close $p_file
    }
}

proc pDumpWebForm { } {

   upvar 2 aAdmin aAdmin
    
   global bStatus
   global sDumpSchemaDirBusiness

   if {$bStatus} {puts \"Start Processing WebForm ...\"}

#  Set up array for symbolic name mapping
#
   set lsPropertyName \"\"
   catch {set lsPropertyName [split [mql print program eServiceSchemaVariableMapping.tcl select property.name dump |] |]} sMsg
   set sTypeReplace \"form \"

   foreach sPropertyName $lsPropertyName {
      set sSchemaTest [lindex [split $sPropertyName \"_\"] 0]
      if {$sSchemaTest == \"form\"} {
         set sPropertyTo [mql print program eServiceSchemaVariableMapping.tcl select property\\[$sPropertyName\\].to dump]
         regsub $sTypeReplace $sPropertyTo \"\" sPropertyTo
         regsub \"_\" $sPropertyName \"|\" sSymbolicName
         set sSymbolicName [lindex [split $sSymbolicName |] 1]
         array set aSymbolic [list $sPropertyTo $sSymbolicName]
      }
   }

   set sPath \"${sDumpSchemaDirBusiness}/SpinnerWebFormData.xls\"
   set lsWebForm $aAdmin(form)
   if {[ llength $lsWebForm ] == 0} {return 0}
   set sFile \"Name\\tRegistry Name\\tDescription\\tField Names (in order-use \\\"|\\\" delim)\\tHidden (boolean)\\tTypes (use \\\"|\\\" delim)\\n\"

   foreach sWebForm $lsWebForm {
      if {[mql print form $sWebForm select web dump] == \"TRUE\"} {
         set sName [mql print form $sWebForm select name dump]
         for {set i 0} {$i < [string length $sName]} {incr i} {
            if {[string range $sName $i $i] == \" \"} {
               regsub \" \" $sName \"<SPACE>\" sName
            } else {
               break
            }
         }
         set sOrigName \"\"
         catch {set sOrigName $aSymbolic($sWebForm)} sMsg
         regsub -all \" \" $sWebForm \"\" sOrigNameTest
         if {$sOrigNameTest == $sOrigName} {
            set sOrigName $sWebForm
         }
         set sDescription [mql print form $sWebForm select description dump]
         set slsType [mql print form $sWebForm select type dump \" | \"]
         set sHidden [mql print form $sWebForm select hidden dump]
         set slsField [mql print form $sWebForm select field dump \" | \"]
         for {set i 0} {$i < [string length $slsField]} {incr i} {
            if {[string range $slsField $i $i] == \" \"} {
               regsub \" \" $slsField \"<SPACE>\" slsField
            } else {
               break
            }
         }
         regsub -all \" \\\\\\|  \" $slsField \" \\| <SPACE>\" slsField
         append sFile \"$sName\\t$sOrigName\\t$sDescription\\t$slsField\\t$sHidden\\t$slsType\\n\"
      }
   }
   set iFile [open $sPath w]
   puts $iFile $sFile
   close $iFile
   if {$bStatus} {puts \"WebForm data loaded in file $sPath\"}
}

proc pDumpWebFormField { } {

   upvar 2 aAdmin aAdmin
    
   global bStatus
   global sDumpSchemaDirBusiness

   if {$bStatus} {puts \"Start Processing WebFormField ...\"}

   set sPath \"${sDumpSchemaDirBusiness}/SpinnerWebFormFieldData.xls\"
   set lsForm $aAdmin(form)
   if {[ llength $lsForm ] == 0} {return 0}
   set sFile \"WebForm Name\\tField Name\\tField Label\\tField Description\\tExpression Type (bus or \\\"\\\" / rel)\\tExpression\\tHref\\tSetting Names (use \\\"|\\\" delim)\\tSetting Values (use \\\"|\\\" delim)\\tUsers (use \\\"|\\\" delim)\\tAlt\\tRange\\tUpdate\\tField Order\\n\"

   foreach sForm $lsForm {
      if {[mql print form $sForm select web dump] == \"TRUE\"} {
         set lsField [split [mql print form $sForm] \\n]
         set bField FALSE
         set iCounter 1
         foreach sField $lsField {
            set sField [string trim $sField]
            if {[string range $sField 0 5] == \"field#\"} {
               set bField TRUE
               set sName \"\"
               set sLabel \"\"
               set sDescription \"\"
               set sExpressionType \"\"
               set sExpression \"\"
               set sHref \"\"
               set sAlt \"\"
               set sRange \"\"
               set sUpdate \"\"
               set lsSettingName \"\"
               set lsSettingValue \"\"
               set lsUser \"\"
               set iFieldOrder $iCounter
               incr iCounter
               set iSelect [string first \"select\" $sField]
               if {$iSelect >= 0} {
                  set sExpression [string range $sField [expr $iSelect + 7] end]
               }
            } elseif {$bField} {
               if {$sField == \"\"} {
                  set slsSettingName [join $lsSettingName \" | \"]
                  set slsSettingValue [join $lsSettingValue \" | \"]
                  set slsUser [join $lsUser \" | \"]
                  set sFormName $sForm
                  for {set i 0} {$i < [string length $sFormName]} {incr i} {
                     if {[string range $sFormName $i $i] == \" \"} {
                        regsub \" \" $sFormName \"<SPACE>\" sFormName
                     } else {
                        break
                     }
                  }
                  append sFile \"$sFormName\\t$sName\\t$sLabel\\t$sDescription\\t$sExpressionType\\t$sExpression\\t$sHref\\t$slsSettingName\\t$slsSettingValue\\t$slsUser\\t$sAlt\\t$sRange\\t$sUpdate\\t$iFieldOrder\\n\"
               } else {
                  regsub \" \" $sField \"^\" sFieldTemp
                  set lsFieldTemp [split $sFieldTemp ^]
                  set sChoice [lindex $lsFieldTemp 0]
                  set sValue [string trim [lindex $lsFieldTemp 1]]
                  if {$sChoice == \"name\"} {
                     regsub \"        \" $sValue \"\" sValue
                     for {set i 0} {$i < [string length $sValue]} {incr i} {
                        if {[string range $sValue $i $i] == \" \"} {
                           regsub \" \" $sValue \"<SPACE>\" sValue
                        } else {
                           break
                        }
                     }
                  } else {
                     set sValue [string trim $sValue]
                  }
                  switch $sChoice {
                     expressiontype {
                        set sExpressionType $sValue
                     } name {
                        set sName $sValue
                     } label {
                        set sLabel $sValue
                     } href {
                        set sHref $sValue
                     } alt {
                        set sAlt $sValue
                     } range {
                        set sRange $sValue
                     } update {
                        set sUpdate $sValue
                     } description {
                        set sDescription $sValue
                     } user {
                        lappend lsUser $sValue
                     } setting {
                        regsub \" value \" $sValue \"^\" sValue
                        set lsValue [split $sValue ^]
                        lappend lsSettingName [lindex $lsValue 0]
                        lappend lsSettingValue [lindex $lsValue 1]
                     }
                  }
               }
            }
         }
      }
   }
   set iFile [open $sPath w]
   puts $iFile $sFile
   close $iFile
   if {$bStatus} {puts \"WebForm Field data loaded in file $sPath\"}
}

proc pDumpChannel { } {

   upvar 2 aAdmin aAdmin
    
   global bStatus
   global sDumpSchemaDirBusiness

   if {$bStatus} {puts \"Start Processing Channel ...\"}

#  Set up array for symbolic name mapping
#
   set lsPropertyName \"\"
   catch {set lsPropertyName [split [mql print program eServiceSchemaVariableMapping.tcl select property.name dump |] |]} sMsg
   set sTypeReplace \"channel \"

   foreach sPropertyName $lsPropertyName {
      set sSchemaTest [lindex [split $sPropertyName \"_\"] 0]
      if {$sSchemaTest == \"channel\"} {
         set sPropertyTo [mql print program eServiceSchemaVariableMapping.tcl select property\\[$sPropertyName\\].to dump]
         regsub $sTypeReplace $sPropertyTo \"\" sPropertyTo
         regsub \"_\" $sPropertyName \"|\" sSymbolicName
         set sSymbolicName [lindex [split $sSymbolicName |] 1]
         array set aSymbolic [list $sPropertyTo $sSymbolicName]
      }
   }

   set sPath \"${sDumpSchemaDirBusiness}/SpinnerChannelData.xls\"
   set lsChannel $aAdmin(channel)
   if {[ llength $lsChannel ] == 0} {return 0}
   set sFile \"Name\\tRegistry Name\\tDescription\\tLabel\\tHref\\tAlt\\tSetting Name (use \\\"|\\\" delim)\\tSetting Value (use \\\"|\\\" delim)\\tCommands (use \\\"|\\\" delim)\\tHeight\\tHidden (boolean)\\tIcon File\\n\"

   foreach sChannel $lsChannel {
      set sName [mql print channel $sChannel select name dump]
      set sOrigName \"\"
      catch {set sOrigName $aSymbolic($sChannel)} sMsg
      regsub -all \" \" $sChannel \"\" sOrigNameTest
      if {$sOrigNameTest == $sOrigName} {
         set sOrigName $sChannel
      }
      set sDescription [mql print channel $sChannel select description dump]
      set sLabel [mql print channel $sChannel select label dump]
      set sHref [mql print channel $sChannel select href dump]
      set sAlt [mql print channel $sChannel select alt dump]
      set sHidden [mql print channel $sChannel select hidden dump]
      set slsSettingName [mql print channel $sChannel select setting.name dump \" | \"]
      set slsSettingValue [mql print channel $sChannel select setting.value dump \" | \"]
      set slsCommand [mql print channel $sChannel select command dump \" | \"]
      set sHeight [mql print channel $sChannel select height dump]
      append sFile \"$sName\\t$sOrigName\\t$sDescription\\t$sLabel\\t$sHref\\t$sAlt\\t$slsSettingName\\t$slsSettingValue\\t$slsCommand\\t$sHeight\\t$sHidden\\n\"

      set sCode \"\\n\\n\"
      append sCode \"puts stdout \\\"Add channel ...\\\"\"
      append sCode \"\\n\\nset bRegister 1\\n\\n\"
      append sCode \"set sMql \\\"mql add channel \\\\\\\"$sName\\\\\\\"\\\"\\n\"
      append sCode \"pProcessMqlCmd \\$bRegister \\$sMql\\n\\n\"
      append sCode \"puts stdout \\\"Mod channel ...\\\"\\n\\n\"
      append sCode \"set bRegister 0\\n\\n\"
      append sCode \"set sMql \\\"mql mod channel \\\\\\\"$sName\\\\\\\" \\\\\\n\"
      append sCode \"    description \\\\\\\"$sDescription\\\\\\\" \\\\\\n\"
      append sCode \"    label \\\\\\\"$sLabel\\\\\\\" \\\\\\n\"
      regsub -all -- {\\$} $sHref {\\\\\\\\\\$} sHref
      append sCode \"    href \\\\\\\"$sHref\\\\\\\" \\\\\\n\"
      append sCode \"    alt \\\\\\\"$sAlt\\\\\\\" \\\\\\n\"
      set sSetNa [ split $slsSettingName | ]
      set sSetVa [ split $slsSettingValue | ]
      foreach sSetName $sSetNa sSetValue $sSetVa {
          set sSetName [string trim $sSetName]
          set sSetValue [string trim $sSetValue]
          regsub -all -- {\\$} $sSetValue {\\\\\\\\\\$} sSetValue
          append sCode \"    add setting \\\\\\\"$sSetName\\\\\\\" \\\\\\\"$sSetValue\\\\\\\" \\\\\\n\"
      }
      set lCom [split $slsCommand |]
      foreach sCom $lCom {
          set sCom [string trim $sCom]
          append sCode \"    add command \\\\\\\"$sCom\\\\\\\" \\\\\\n\"
      }
      append sCode \"  \\\"\\n\\n\"
      append sCode \"pProcessMqlCmd \\$bRegister \\$sMql\\n\\n\"
      lappend lMql $sCode
   }
   set iFile [open $sPath w]
   puts $iFile $sFile
   close $iFile
   if {$bStatus} {puts \"Channel data loaded in file $sPath\"}
}

proc pDumpPortal { } {

   upvar 2 aAdmin aAdmin
    
   global bStatus
   global sDumpSchemaDirBusiness

   if {$bStatus} {puts \"Start Processing Portal ...\"}

#  Set up array for symbolic name mapping
#
   set lsPropertyName \"\"
   catch {set lsPropertyName [split [mql print program eServiceSchemaVariableMapping.tcl select property.name dump |] |]} sMsg
   set sTypeReplace \"portal \"

   foreach sPropertyName $lsPropertyName {
      set sSchemaTest [lindex [split $sPropertyName \"_\"] 0]
      if {$sSchemaTest == \"portal\"} {
         set sPropertyTo [mql print program eServiceSchemaVariableMapping.tcl select property\\[$sPropertyName\\].to dump]
         regsub $sTypeReplace $sPropertyTo \"\" sPropertyTo
         regsub \"_\" $sPropertyName \"|\" sSymbolicName
         set sSymbolicName [lindex [split $sSymbolicName |] 1]
         array set aSymbolic [list $sPropertyTo $sSymbolicName]
      }
   }

   set sPath \"${sDumpSchemaDirBusiness}/SpinnerPortalData.xls\"
   set lsPortal $aAdmin(portal)
   if {[ llength $lsPortal ] == 0} {return 0}
   set sFile \"Name\\tRegistry Name\\tDescription\\tLabel\\tHref\\tAlt\\tSetting Name (use \\\"|\\\" delim)\\tSetting Value (use \\\"|\\\" delim)\\tChannels (use \\\",\\\" w/ \\\"|\\\" delims)\\tHidden (boolean)\\tIcon File\\n\"
   foreach sPortal $lsPortal {
      set sName [mql print portal $sPortal select name dump]
      set sOrigName \"\"
      catch {set sOrigName $aSymbolic($sPortal)} sMsg
      regsub -all \" \" $sPortal \"\" sOrigNameTest
      if {$sOrigNameTest == $sOrigName} {
         set sOrigName $sPortal
      }
      set sDescription [mql print portal $sPortal select description dump]
      set sLabel [mql print portal $sPortal select label dump]
      set sHref [mql print portal $sPortal select href dump]
      set sAlt [mql print portal $sPortal select alt dump]
      set sHidden [mql print portal $sPortal select hidden dump]
      set slsSettingName [mql print portal $sPortal select setting.name dump \" | \"]
      set slsSettingValue [mql print portal $sPortal select setting.value dump \" | \"]
      set slsChannel \"\"
      set lsPrint [split [mql print portal $sPortal] \\n]
      set lsChannel \"\"
      foreach sPrint $lsPrint {
         set sPrint [string trim $sPrint]
         if {[string first \"channel\" $sPrint] == 0} {
            regsub \"channel \" $sPrint \"\" sPrint
            lappend lsChannel $sPrint
         }
      }
      set slsChannel [join $lsChannel \" | \"]
      append sFile \"$sName\\t$sOrigName\\t$sDescription\\t$sLabel\\t$sHref\\t$sAlt\\t$slsSettingName\\t$slsSettingValue\\t$slsChannel\\t$sHidden\\n\"

      set sCode \"\\n\\n\"
      append sCode \"puts stdout \\\"Add portal ...\\\"\"
      append sCode \"\\n\\nset bRegister 1\\n\\n\"
      append sCode \"set sMql \\\"mql add portal \\\\\\\"$sName\\\\\\\"\\\"\\n\"
      append sCode \"pProcessMqlCmd \\$bRegister \\$sMql\\n\\n\"
      append sCode \"puts stdout \\\"Mod portal ...\\\"\\n\\n\"
      append sCode \"set bRegister 0\\n\\n\"
      append sCode \"set sMql \\\"mql mod portal \\\\\\\"$sName\\\\\\\" \\\\\\n\"
      append sCode \"    description \\\\\\\"$sDescription\\\\\\\" \\\\\\n\"
      append sCode \"    label \\\\\\\"$sLabel\\\\\\\" \\\\\\n\"
      regsub -all -- {\\$} $sHref {\\\\\\\\\\$} sHref
      append sCode \"    href \\\\\\\"$sHref\\\\\\\" \\\\\\n\"
      append sCode \"    alt \\\\\\\"$sAlt\\\\\\\" \\\\\\n\"
      set sSetNa [ split $slsSettingName | ]
      set sSetVa [ split $slsSettingValue | ]
      foreach sSetName $sSetNa sSetValue $sSetVa {
          set sSetName [string trim $sSetName]
          set sSetValue [string trim $sSetValue]
          regsub -all -- {\\$} $sSetValue {\\\\\\\\\\$} sSetValue
          append sCode \"    add setting \\\\\\\"$sSetName\\\\\\\" \\\\\\\"$sSetValue\\\\\\\" \\\\\\n\"
      }
      set lCha [split $slsChannel |]
      foreach sCha $lCha {
          set sCha [string trim $sCha]
          append sCode \"    add portal \\\\\\\"$sCha\\\\\\\" \\\\\\n\"
      }
      append sCode \"  \\\"\\n\\n\"
      append sCode \"pProcessMqlCmd \\$bRegister \\$sMql\\n\\n\"
      lappend lMql $sCode
    }
    set iFile [open $sPath w]
    puts $iFile $sFile
    close $iFile
    if {$bStatus} {puts \"Portal data loaded in file $sPath\"}
}

proc pDumpRule { } {

   upvar 2 aAdmin aAdmin
    
   global bStatus
   global sDumpSchemaDirBusiness
   global nMxVer

   if {$bStatus} {puts \"Start Processing Rule ...\"}

#  Set up array for symbolic name mapping
#
   set lsPropertyName \"\"
   catch {set lsPropertyName [split [mql print program eServiceSchemaVariableMapping.tcl select property.name dump |] |]} sMsg
   set sTypeReplace \"rule \"
#   set sMxVersion [string range [mql version] 0 2]

   foreach sPropertyName $lsPropertyName {
      set sSchemaTest [lindex [split $sPropertyName \"_\"] 0]
      if {$sSchemaTest == \"rule\"} {
         set sPropertyTo [mql print program eServiceSchemaVariableMapping.tcl select property\\[$sPropertyName\\].to dump]
         regsub $sTypeReplace $sPropertyTo \"\" sPropertyTo
         regsub \"_\" $sPropertyName \"|\" sSymbolicName
         set sSymbolicName [lindex [split $sSymbolicName |] 1]
         array set aSymbolic [list $sPropertyTo $sSymbolicName]
      }
   }

   set sPath \"${sDumpSchemaDirBusiness}/SpinnerRuleData.xls\"
   set lsRule $aAdmin(rule)
   if {[ llength $lsRule ] == 0} {return 0}
   set sFile \"Rule Name\\tRegistry Name\\tDescription\\tPrograms (use \\\"|\\\" delim)\\tAttributes (use \\\"|\\\" delim)\\tRelationships (use \\\"|\\\" delim)\\tForms (use \\\"|\\\" delim)\\tAccess (use \\\"|\\\" delim)\\tHidden (boolean)\\tIcon File\\n\"

   foreach sRule $lsRule {
      set sName [mql print rule $sRule select name dump]
      set sOrigName \"\"
      catch {set sOrigName $aSymbolic($sRule)} sMsg
      regsub -all \" \" $sRule \"\" sOrigNameTest
      if {$sOrigNameTest == $sOrigName} {
         set sOrigName $sRule
      }
      set sDescription [mql print rule $sRule select description dump]
      set bHidden [mql print rule $sRule select hidden dump]
      
      set lsAccess \"\"
      set slsAccess \"\"
      set lsAccessTemp [split [mql print rule $sRule select access] \\n]
      foreach sAccessTemp $lsAccessTemp {
         set sAccessTemp [string trim $sAccessTemp]
         if {[string first \"access\\[\" $sAccessTemp] > -1} {
            set iFirst [expr [string first \"access\\[\" $sAccessTemp] + 7]
            set iSecond [expr [string first \"\\] =\" $sAccessTemp] -1]
            lappend lsAccess [string range $sAccessTemp $iFirst $iSecond]
         }
      }
      set slsAccess [join $lsAccess \" | \"]
      
      set slsProgram \"\"
      set slsAttribute \"\"
      set slsForm \"\" 
      set slsRelationship \"\"
      set lsPrint [split [mql print rule $sRule] \\n]                            
      foreach sPrint $lsPrint {
         set sPrint [string trim $sPrint]
         foreach sReference [list program attribute form \"Relationship Type\"] {
            if {[string first $sReference $sPrint] == 0} {
               regsub \"$sReference\\: \" $sPrint \"\" slsReference
               regsub -all \", \" $slsReference \" | \" slsReference
               switch $sReference {
                  program {
                     set slsProgram $slsReference
                  } attribute {
                     set slsAttribute $slsReference
                  } form {
                     set slsForm $slsReference
                  } \"Relationship Type\" {
                     set slsRelationship $slsReference
                  }
               }
            }
         }
      }
      
      append sFile \"$sName\\t$sOrigName\\t$sDescription\\t$slsProgram\\t$slsAttribute\\t$slsRelationship\\t$slsForm\\t$slsAccess\\t$bHidden\\n\"
   }
   set iFile [open $sPath w]
   puts $iFile $sFile
   close $iFile
   puts \"Rule data loaded in file $sPath\"
}

proc pDumpPage { } {

   upvar 2 aAdmin aAdmin
    
   global bStatus
   global sDumpSchemaDirBusiness
   global sDumpSchemaDirBusinessPage
   global nMxVer

   if {$bStatus} {puts \"Start Processing Spinner Page ...\"}

#  Set up array for symbolic name mapping
#
   set lsPropertyName \"\"
   catch {set lsPropertyName [split [mql print program eServiceSchemaVariableMapping.tcl select property.name dump |] |]} sMsg
   set sTypeReplace \"page \"

   foreach sPropertyName $lsPropertyName {
      set sSchemaTest [lindex [split $sPropertyName \"_\"] 0]
      if {$sSchemaTest == \"page\"} {
         set sPropertyTo [mql print program eServiceSchemaVariableMapping.tcl select property\\[$sPropertyName\\].to dump]
         regsub $sTypeReplace $sPropertyTo \"\" sPropertyTo
         regsub \"_\" $sPropertyName \"|\" sSymbolicName
         set sSymbolicName [lindex [split $sSymbolicName |] 1]
         array set aSymbolic [list $sPropertyTo $sSymbolicName]
      }
   }

   set sPath \"$sDumpSchemaDirBusiness/SpinnerPageData.xls\"
   set sPageFileDir \"$sDumpSchemaDirBusinessPage\"
   set lsPage $aAdmin(page)
   set sFile \"Page Name\\tRegistry Name\\tDescription\\tMime Type\\tHidden (boolean)\\tIcon File\\n\"
   if { [ llength $lsPage ] == 0 } {return 0}

   foreach sPage $lsPage {
      set sName [mql print page $sPage select name dump]
      set sOrigName \"\"
      catch {set sOrigName $aSymbolic($sPage)} sMsg
      regsub -all \" \" $sPage \"\" sOrigNameTest
      if {$sOrigNameTest == $sOrigName} {
         set sOrigName $sPage
      }

      set sDescription [mql print page $sPage select description dump]
      set sMimeType [mql print page $sPage select mime dump]
      set bHidden [mql print page $sPage select hidden dump]

      append sFile \"$sName\\t$sOrigName\\t$sDescription\\t$sMimeType\\t$bHidden\\n\"
      regsub -all \"/\" $sPage \"SLASH\" sPageFile 
      mql print page $sPage select content dump output \"$sPageFileDir/$sPageFile\"
   }
   set iFile [open $sPath w]
   puts $iFile $sFile
   close $iFile
   if {$bStatus} {puts \"Page data loaded in file $sPath\\nPage files loaded in directory $sPageFileDir\"}
}

proc pDumpInterface { } {

   upvar 2 aAdmin aAdmin
    
   global bStatus
   global sDumpSchemaDirBusiness
   global nMxVer

   if {$bStatus} {puts \"Start Processing Spinner Interface ...\"}

#  Set up array for symbolic name mapping
#
   set lsPropertyName \"\"
   catch {set lsPropertyName [split [mql print program eServiceSchemaVariableMapping.tcl select property.name dump |] |]} sMsg
   set sInterfaceReplace \"interface \"

   foreach sPropertyName $lsPropertyName {
      set sSchemaTest [lindex [split $sPropertyName \"_\"] 0]
      if {$sSchemaTest == \"interface\"} {
         set sPropertyTo [mql print program eServiceSchemaVariableMapping.tcl select property\\[$sPropertyName\\].to dump]
         regsub $sInterfaceReplace $sPropertyTo \"\" sPropertyTo
         regsub \"_\" $sPropertyName \"|\" sSymbolicName
         set sSymbolicName [lindex [split $sSymbolicName |] 1]
         array set aSymbolic [list $sPropertyTo $sSymbolicName]
      }
   }

   set sPath \"$sDumpSchemaDirBusiness/SpinnerInterfaceData.xls\"
   set lsInterface $aAdmin(interface)
   if { [ llength $lsInterface ] == 0 } {return 0}
   if {$nMxVer >= 10.8} { 
      set sFile \"Name\\tRegistry Name\\tParents (use \\\"|\\\" delim)\\tAbstract (boolean)\\tDescription\\tAttributes (use \\\"|\\\" delim)\\tTypes (use \\\"|\\\" delim)\\tHidden (boolean)\\tRels (use \\\"|\\\" delim)\\tIcon File\\n\"
   } else {
      set sFile \"Name\\tRegistry Name\\tParents (use \\\"|\\\" delim)\\tAbstract (boolean)\\tDescription\\tAttributes (use \\\"|\\\" delim)\\tTypes (use \\\"|\\\" delim)\\tHidden (boolean)\\tIcon File\\n\"
   }
   
   foreach sInterface $lsInterface {
      set sName [mql print interface $sInterface select name dump]
      set sOrigName \"\"
      catch {set sOrigName $aSymbolic($sInterface)} sMsg
      regsub -all \" \" $sInterface \"\" sOrigNameTest
      if {$sOrigNameTest == $sOrigName} {
         set sOrigName $sInterface
      }
      set sDescription [mql print interface $sInterface select description dump]
      set sHidden [mql print interface $sInterface select hidden dump]
      set slsAttribute [mql print interface $sInterface select attribute dump \" | \"]
      set slsType [mql print interface $sInterface select type dump \" | \"]
      set slsDerived [mql print interface $sInterface select derived dump \" | \"]
      set bAbstract [mql print interface $sInterface select abstract dump]
      if {$nMxVer >= 10.8} {
         set slsRel [mql print interface $sInterface select relationship dump \" | \"]
         append sFile \"$sName\\t$sOrigName\\t$slsDerived\\t$bAbstract\\t$sDescription\\t$slsAttribute\\t$slsType\\t$sHidden\\t$slsRel\\n\"
      } else {
         append sFile \"$sName\\t$sOrigName\\t$slsDerived\\t$bAbstract\\t$sDescription\\t$slsAttribute\\t$slsType\\t\\t$sHidden\\n\"
      }
   }
   set iFile [open $sPath w]
   puts $iFile $sFile
   close $iFile
   if {$bStatus} {puts \"Interface data loaded in file $sPath\"}
}

proc pDumpExpression { } {

   upvar 2 aAdmin aAdmin
    
   global bStatus
   global sDumpSchemaDirBusiness
   global nMxVer

   if {$bStatus} {puts \"Start Processing Spinner Expression ...\"}

#  Set up array for symbolic name mapping
#
   set lsPropertyName \"\"
   catch {set lsPropertyName [split [mql print program eServiceSchemaVariableMapping.tcl select property.name dump |] |]} sMsg
   set sExpressionReplace \"expression \"

   foreach sPropertyName $lsPropertyName {
      set sSchemaTest [lindex [split $sPropertyName \"_\"] 0]
      if {$sSchemaTest == \"expression\"} {
         set sPropertyTo [mql print program eServiceSchemaVariableMapping.tcl select property\\[$sPropertyName\\].to dump]
         regsub $sExpressionReplace $sPropertyTo \"\" sPropertyTo
         regsub \"_\" $sPropertyName \"|\" sSymbolicName
         set sSymbolicName [lindex [split $sSymbolicName |] 1]
         array set aSymbolic [list $sPropertyTo $sSymbolicName]
      }
   }

   set sPath \"$sDumpSchemaDirBusiness/SpinnerExpressionData.xls\"
   set lsExpression $aAdmin(expression)
   if { [ llength $lsExpression ] == 0 } {return 0}
   set sFile \"Name\\tRegistry Name\\tDescription\\tValue\\tHidden (boolean)\\tIcon File\\n\"

   foreach sExpression $lsExpression {
      set sName [mql print expression $sExpression select name dump]
      set sOrigName \"\"
      catch {set sOrigName $aSymbolic($sExpression)} sMsg
      regsub -all \" \" $sExpression \"\" sOrigNameTest
      if {$sOrigNameTest == $sOrigName} {
         set sOrigName $sExpression
      }
      set sDescription [mql print expression $sExpression select description dump]
      set sValue [mql print expression $sExpression select value dump]
      set sHidden [mql print expression $sExpression select hidden dump]
      append sFile \"$sName\\t$sOrigName\\t$sDescription\\t$sValue\\t$sHidden\\n\"
   }
   set iFile [open $sPath w]
   puts $iFile $sFile
   close $iFile
   if {$bStatus} {puts \"Expression data loaded in file $sPath\"}
}

proc pContinue {lsList} {
   set bFirst TRUE
   set slsList \"\"
   set lslsList \"\"
   foreach sList $lsList {
      if {$bFirst} {
         set slsList $sList
         set bFirst FALSE
      } else {
         append slsList \" | $sList\"
         if {[string length $slsList] > 6400} {
            lappend lslsList $slsList
            set slsList \"\"
            set bFirst TRUE
         }
      }
   }
   if {$slsList != \"\"} {
      lappend lslsList $slsList
   }
   return $lslsList
}

proc pDumpSite { } {

   global sDumpSchemaDirSystem
   global bStatus
   global nMxVer
   upvar 2 aAdmin aAdmin

   if {$bStatus} {puts \"Start Processing Spinner Site ...\"}

#  Set up array for symbolic name mapping
#
   set lsPropertyName \"\"
   catch {set lsPropertyName [split [mql print program eServiceSchemaVariableMapping.tcl select property.name dump |] |]} sMsg
   set sTypeReplace \"site \"

   foreach sPropertyName $lsPropertyName {
      set sSchemaTest [lindex [split $sPropertyName \"_\"] 0]
      if {$sSchemaTest == \"site\"} {
         set sPropertyTo [mql print program eServiceSchemaVariableMapping.tcl select property\\[$sPropertyName\\].to dump]
         regsub $sTypeReplace $sPropertyTo \"\" sPropertyTo
         regsub \"_\" $sPropertyName \"|\" sSymbolicName
         set sSymbolicName [lindex [split $sSymbolicName |] 1]
         array set aSymbolic [list $sPropertyTo $sSymbolicName]
      }
   }

   set sPath \"$sDumpSchemaDirSystem/site.xls\"
   set sFile \"name\\tRegistry Name\\tdescription\\tlocation\\thidden\\ticon\\n\"
   set sMxVersion [string range [mql version] 0 2]

   set lsSite [split [mql list site] \\n]
   foreach sSite $lsSite {
      if {[catch {set sName [mql print site $sSite select name dump]} sMsg] != 0} {
         puts \"ERROR: Problem with retrieving info on site '$sSite' - Error Msg:\\n$sMsg\"
         continue
      }
      set sOrigName \"\"
      catch {set sOrigName $aSymbolic($sSite)} sMsg
      regsub -all \" \" $sSite \"\" sOrigNameTest
      if {$sOrigNameTest == $sOrigName} {
         set sOrigName $sSite
      }
               
      set sDescription [mql print site $sSite select description dump]
      set slsLocation [mql print site $sSite select location dump \" | \"]
      set sHidden [mql print site $sSite select hidden dump]
      append sFile \"$sName\\t$sOrigName\\t$sDescription\\t$slsLocation\\t$sHidden\\n\"
   }
   set iFile [open $sPath w]
   puts $iFile $sFile
   close $iFile
   if {$bStatus} {puts \"Site data loaded in file $sPath\"}
}

proc pDumpLocation { } {

   global sDumpSchemaDirSystem
   global bStatus
   global nMxVer
   upvar 2 aAdmin aAdmin

   if {$bStatus} {puts \"Start Processing Spinner Location ...\"}

#  Set up array for symbolic name mapping
#
   set lsPropertyName \"\"
   catch {set lsPropertyName [split [mql print program eServiceSchemaVariableMapping.tcl select property.name dump |] |]} sMsg
   set sTypeReplace \"location \"

   foreach sPropertyName $lsPropertyName {
      set sSchemaTest [lindex [split $sPropertyName \"_\"] 0]
      if {$sSchemaTest == \"location\"} {
         set sPropertyTo [mql print program eServiceSchemaVariableMapping.tcl select property\\[$sPropertyName\\].to dump]
         regsub $sTypeReplace $sPropertyTo \"\" sPropertyTo
         regsub \"_\" $sPropertyName \"|\" sSymbolicName
         set sSymbolicName [lindex [split $sSymbolicName |] 1]
         array set aSymbolic [list $sPropertyTo $sSymbolicName]
      }
   }

   set sPath \"$sDumpSchemaDirSystem/location.xls\"
   set sFile \"name\\tRegistry Name\\tdescription\\tpermission\\tprotocol\\tport\\thost\\tpath\\tuser\\tpassword\\turl\\tfcs\\thidden\\tmultipledirectories\\ticon\\n\"
   set sMxVersion [string range [mql version] 0 2]

   set lsLocation [split [mql list location] \\n]
   foreach sLocation $lsLocation {
      if {[catch {set sName [mql print location $sLocation select name dump]} sMsg] != 0} {
         puts \"ERROR: Problem with retrieving info on location '$sLocation' - Error Msg:\\n$sMsg\"
         continue
      }
      foreach sItem [list sDescription sPermission sProtocol sPort sHost sLocPath sUser sSearchURL sFcsURL sHidden sMultiDir] {
         eval \"set $sItem \\\"\\\"\"
      }
      
      set sOrigName \"\"
      catch {set sOrigName $aSymbolic($sLocation)} sMsg
      regsub -all \" \" $sLocation \"\" sOrigNameTest
      if {$sOrigNameTest == $sOrigName} {
         set sOrigName $sLocation
      }
               
      set lsPrint [split [mql print location $sLocation] \\n]
      foreach sItem [list description protocol host port path user \"fcs url\" \"search url\" multipledirectories hidden] sVar [list sDescription sProtocol sHost sPort sLocPath sUser sFcsURL sSearchURL sMultiDir sHidden] {
         set iList [lsearch -regexp $lsPrint $sItem]
         if {$iList >= 0} {
            set sResult [string trim [lindex $lsPrint $iList]]
            if {$sItem != \"multipledirectories\" && $sItem != \"hidden\"} {
               regsub $sItem $sResult \"\" sResult
               set sResult [string trim $sResult]
            }
            eval {set $sVar $sResult}
         }
      }
      set sPermission [mql print location $sLocation select permission dump]
      append sFile \"$sName\\t$sOrigName\\t$sDescription\\t$sPermission\\t$sProtocol\\t$sPort\\t$sHost\\t$sLocPath\\t$sUser\\t\\t$sSearchURL\\t$sFcsURL\\t$sHidden\\t$sMultiDir\\n\"
   }
   set iFile [open $sPath w]
   puts $iFile $sFile
   close $iFile
   if {$bStatus} {puts \"Location data loaded in file $sPath\"}
}

proc pDumpServer { } {

   global sDumpSchemaDirSystem
   global bStatus
   global nMxVer
   upvar 2 aAdmin aAdmin

   if {$bStatus} {puts \"Start Processing Spinner Server ...\"}

#  Set up array for symbolic name mapping
#
   set lsPropertyName \"\"
   catch {set lsPropertyName [split [mql print program eServiceSchemaVariableMapping.tcl select property.name dump |] |]} sMsg
   set sTypeReplace \"server \"

   foreach sPropertyName $lsPropertyName {
      set sSchemaTest [lindex [split $sPropertyName \"_\"] 0]
      if {$sSchemaTest == \"server\"} {
         set sPropertyTo [mql print program eServiceSchemaVariableMapping.tcl select property\\[$sPropertyName\\].to dump]
         regsub $sTypeReplace $sPropertyTo \"\" sPropertyTo
         regsub \"_\" $sPropertyName \"|\" sSymbolicName
         set sSymbolicName [lindex [split $sSymbolicName |] 1]
         array set aSymbolic [list $sPropertyTo $sSymbolicName]
      }
   }

   set sPath \"$sDumpSchemaDirSystem/server.xls\"
   set sFile \"name\\tRegistry Name\\tdescription\\tuser\\tpassword\\tconnect\\ttimezone\\tforeign\\thidden\\ticon\\n\"
   set sMxVersion [string range [mql version] 0 2]

   set lsServer [split [mql list server] \\n]
   foreach sServer $lsServer {
      if {[catch {set sName [mql print server $sServer select name dump]} sMsg] != 0} {
         puts \"ERROR: Problem with retrieving info on server '$sServer' - Error Msg:\\n$sMsg\"
         continue
      }
      set sOrigName \"\"
      catch {set sOrigName $aSymbolic($sServer)} sMsg
      regsub -all \" \" $sServer \"\" sOrigNameTest
      if {$sOrigNameTest == $sOrigName} {
         set sOrigName $sServer
      }
               
      set sDescription [mql print server $sServer select description dump]
      set sUser [mql print server $sServer select user dump]
      set sConnect [mql print server $sServer select connect dump]
      set sTimeZone [mql print server $sServer select timezone dump]
      set sForeign [mql print server $sServer select foreign dump]
      set sHidden [mql print server $sServer select hidden dump]
      append sFile \"$sName\\t$sOrigName\\t$sDescription\\t$sUser\\t\\t$sConnect\\t$sTimeZone\\t$sForeign\\t$sHidden\\n\"
   }
   set iFile [open $sPath w]
   puts $iFile $sFile
   close $iFile
   if {$bStatus} {puts \"Server data loaded in file $sPath\"}
}

proc pDumpVault { } {

   global sDumpSchemaDirSystem
   global sDumpSchemaDirSystemMap
   global bStatus
   global nMxVer
   upvar 2 aAdmin aAdmin

   if {$bStatus} {puts \"Start Processing Spinner Vault ...\"}

#  Set up array for symbolic name mapping
#
   set lsPropertyName \"\"
   catch {set lsPropertyName [split [mql print program eServiceSchemaVariableMapping.tcl select property.name dump |] |]} sMsg
   set sTypeReplace \"lattice \"

   foreach sPropertyName $lsPropertyName {
      set sSchemaTest [lindex [split $sPropertyName \"_\"] 0]
      if {$sSchemaTest == \"vault\"} {
         set sPropertyTo [mql print program eServiceSchemaVariableMapping.tcl select property\\[$sPropertyName\\].to dump]
         regsub $sTypeReplace $sPropertyTo \"\" sPropertyTo
         regsub \"_\" $sPropertyName \"|\" sSymbolicName
         set sSymbolicName [lindex [split $sSymbolicName |] 1]
         array set aSymbolic [list $sPropertyTo $sSymbolicName]
      }
   }

   set sPath(local) \"$sDumpSchemaDirSystem/vault_local.xls\"
   set sPath(remote) \"$sDumpSchemaDirSystem/vault_remote.xls\"
   set sPath(foreign) \"$sDumpSchemaDirSystem/vault_foreign.xls\"
   set sFile(local) \"name\\tRegistry Name\\tdescription\\ttablespace\\tindexspace\\thidden\\ticon\\n\"
   set sFile(remote) \"name\\tRegistry Name\\tdescription\\tserver\\thidden\\ticon\\n\"
   set sFile(foreign) \"name\\tRegistry Name\\tdescription\\ttablespace\\tindexspace\\tinterface\\tfile\\tmap\\thidden\\ticon\\n\"
   set sMxVersion [string range [mql version] 0 2]

   set lsVault [split [mql list vault] \\n]
   foreach sVault $lsVault {
      if {[catch {set sName [mql print vault $sVault select name dump]} sMsg] != 0} {
         puts \"ERROR: Problem with retrieving info on vault '$sVault' - Error Msg:\\n$sMsg\"
         continue
      }
      foreach sItem [list sDescription sTablespace sIndexspace sInterface sMapFile sHidden sServer] {
         eval \"set $sItem \\\"\\\"\"
      }
      
      set sOrigName \"\"
      catch {set sOrigName $aSymbolic($sVault)} sMsg
      regsub -all \" \" $sVault \"\" sOrigNameTest
      if {$sOrigNameTest == $sOrigName} {
         set sOrigName $sVault
      }

      set sDescription [mql print vault $sVault select description dump]
      set sHidden [mql print vault $sVault select hidden dump]
      set sInterface [mql print vault $sVault select interface dump]
      set sMap [mql print vault $sVault select map dump]
      set sServer [mql print vault $sVault select server dump]
      
      if {$sServer != \"\"} {
         set sType remote
      } elseif {$sInterface != \"\" || $sMap != \"\"} {
         set sType foreign
         if {$sMap != \"\"} {
            set sMapFile \"./System/Map/$sName\\.map\"
            set sFilePath \"$sDumpSchemaDirSystemMap/$sName\\.map\"
            set iMapFile [open $sFilePath w]
            puts $iMapFile $sMap
            close $iMapFile
         }
      } else {
         set sType local
      }
      
      if {$sType != \"remote\"} {
         set lsPrint [split [mql print vault $sVault] \\n]
         foreach sItem [list \"data tablespace\" \"index tablespace\"] sSpace [list sTablespace sIndexspace] {
            set iList [lsearch -regexp $lsPrint $sItem]
            if {$iList >= 0} {
               set sResult [string trim [lindex $lsPrint $iList]]
               regsub $sItem $sResult \"\" sResult
               set sResult [string trim $sResult]
               eval {set $sSpace $sResult}
            }
         }
      }
      switch $sType {
         local {
            append sFile(local) \"$sName\\t$sOrigName\\t$sDescription\\t$sTablespace\\t$sIndexspace\\t$sHidden\\n\"
         } remote {
            append sFile(remote) \"$sName\\t$sOrigName\\t$sDescription\\t$sServer\\t$sHidden\\n\"
         } foreign {
            append sFile(foreign) \"$sName\\t$sOrigName\\t$sDescription\\t$sTablespace\\t$sIndexspace\\t$sInterface\\t$sMapFile\\t\\t$sHidden\\n\"
         }
      }
   }
   foreach sType [list foreign local remote] {
      set iFile [open $sPath($sType) w]
      puts $iFile $sFile($sType)
      close $iFile
   }
   if {$bStatus} {puts \"Vault data loaded in files:\\n   $sPath(foreign)\\n   $sPath(local)\\n   $sPath(remote)\"}
}

proc pDumpStore { } {

   global sDumpSchemaDirSystem
   global bStatus
   global nMxVer
   upvar 2 aAdmin aAdmin

   if {$bStatus} {puts \"Start Processing Spinner Store ...\"}

#  Set up array for symbolic name mapping
#
   set lsPropertyName \"\"
   catch {set lsPropertyName [split [mql print program eServiceSchemaVariableMapping.tcl select property.name dump |] |]} sMsg
   set sTypeReplace \"store \"

   foreach sPropertyName $lsPropertyName {
      set sSchemaTest [lindex [split $sPropertyName \"_\"] 0]
      if {$sSchemaTest == \"store\"} {
         set sPropertyTo [mql print program eServiceSchemaVariableMapping.tcl select property\\[$sPropertyName\\].to dump]
         regsub $sTypeReplace $sPropertyTo \"\" sPropertyTo
         regsub \"_\" $sPropertyName \"|\" sSymbolicName
         set sSymbolicName [lindex [split $sSymbolicName |] 1]
         array set aSymbolic [list $sPropertyTo $sSymbolicName]
      }
   }

   set sPath(captured) \"$sDumpSchemaDirSystem/store_captured.xls\"
   set sPath(ingested) \"$sDumpSchemaDirSystem/store_ingested.xls\"
   set sPath(tracked) \"$sDumpSchemaDirSystem/store_tracked.xls\"
   set sFile(captured) \"name\\tRegistry Name\\tdescription\\ttype\\tfilename\\tpermission\\tprotocol\\tport\\thost\\tpath\\tuser\\tpassword\\tlocation\\tfcs\\thidden\\tmultipledirectories\\tlock\\ticon\\n\"
   set sFile(ingested) \"name\\tRegistry Name\\tdescription\\ttype\\ttablespace\\tindexspace\\thidden\\tlock\\ticon\\n\"
   set sFile(tracked) \"name\\tRegistry Name\\tdescription\\ttype\\thidden\\tlock\\ticon\\n\"
   set lsItem(captured) [list sDescription sFilename sMultiDir sLock sPermission sProtocol sUser sHost sPort sStorePath sSearch sFcs sHidden]
   set lsItem(ingested) [list sDescription sLock sHidden sTablespace sIndexspace]
   set lsItem(tracked) [list sDescription sLock sHidden]
   set lsPrintItem(captured) [list description filename multipledirectories locked permission protocol user host port path \"search url\" \"fcs url\" hidden]
   set lsPrintItem(ingested) [list description locked hidden \"data tablespace\" \"index tablespace\"]
   set lsPrintItem(tracked) [list description locked hidden]
   set sMxVersion [string range [mql version] 0 2]

   set lsStore [split [mql list store] \\n]
   foreach sStore $lsStore {
      foreach sItem [list sDescription sFilename sLock sPermission sProtocol sUser sPassword sHost sPort sStorePath sSearch sFcs sMultiDir sHidden sTablespace sIndexspace] {
         eval \"set $sItem \\\"\\\"\"
      }
      
      set sName [mql print store $sStore select name dump]
      set sOrigName \"\"
      catch {set sOrigName $aSymbolic($sStore)} sMsg
      regsub -all \" \" $sStore \"\" sOrigNameTest
      if {$sOrigNameTest == $sOrigName} {
         set sOrigName $sStore
      }
      set sType [mql print store $sStore select type dump]
      if {$sType == \"captured\"} {set slsLocation [mql print store $sStore select location dump \" | \"]}
      
      set lsPrint [split [mql print store $sStore] \\n]
      foreach sPrintItem $lsPrintItem($sType) sItem $lsItem($sType) {
         set iList [lsearch -regexp $lsPrint $sPrintItem]
         if {$iList >= 0} {
            set sResult [string trim [lindex $lsPrint $iList]]
            if {$sPrintItem != \"hidden\" && $sPrintItem != \"multipledirectories\" && $sPrintItem != \"locked\"} {
               regsub $sPrintItem $sResult \"\" sResult
               set sResult [string trim $sResult]
            }
            eval {set $sItem $sResult}
         }
      }
      switch $sType {
         captured {
            append sFile(captured) \"$sName\\t$sOrigName\\t$sDescription\\t$sType\\t$sFilename\\t$sPermission\\t$sProtocol\\t$sPort\\t$sHost\\t$sStorePath\\t$sUser\\t\\t$slsLocation\\t$sFcs\\t$sHidden\\t$sMultiDir\\t$sLock\\n\"
         } ingested {
            append sFile(ingested) \"$sName\\t$sOrigName\\t$sDescription\\t$sType\\t$sTablespace\\t$sIndexspace\\t$sHidden\\t$sLock\\n\"
         } tracked {
            append sFile(tracked) \"$sName\\t$sOrigName\\t$sDescription\\t$sType\\t$sHidden\\t$sLock\\n\"
         }
      }
   }
   foreach sType [list captured ingested tracked] {
      set iFile [open $sPath($sType) w]
      puts $iFile $sFile($sType)
      close $iFile
   }
   if {$bStatus} {puts \"Store data loaded in files:\\n   $sPath(captured)\\n   $sPath(ingested)\\n   $sPath(tracked)\"}
}

proc pDumpIndex { } {

   global sDumpSchemaDirSystem
   global bStatus
   global nMxVer
   upvar 2 aAdmin aAdmin

   if {$bStatus} {puts \"Start Processing Spinner Index ...\"}

#  Set up array for symbolic name mapping
#
   set lsPropertyName \"\"
   catch {set lsPropertyName [split [mql print program eServiceSchemaVariableMapping.tcl select property.name dump |] |]} sMsg
   set sTypeReplace \"index \"

   foreach sPropertyName $lsPropertyName {
      set sSchemaTest [lindex [split $sPropertyName \"_\"] 0]
      if {$sSchemaTest == \"index\"} {
         set sPropertyTo [mql print program eServiceSchemaVariableMapping.tcl select property\\[$sPropertyName\\].to dump]
         regsub $sTypeReplace $sPropertyTo \"\" sPropertyTo
         regsub \"_\" $sPropertyName \"|\" sSymbolicName
         set sSymbolicName [lindex [split $sSymbolicName |] 1]
         array set aSymbolic [list $sPropertyTo $sSymbolicName]
      }
   }

   set sPath \"$sDumpSchemaDirSystem/index.xls\"
   set sFile \"name\\tRegistry Name\\tdescription\\tattribute\\tenable\\tunique\\thidden\\ticon\\n\"
   set sMxVersion [string range [mql version] 0 2]

   set lsIndex [split [mql list index] \\n]
   foreach sIndex $lsIndex {
      if {[catch {set sName [mql print index $sIndex select name dump]} sMsg] != 0} {
         puts \"ERROR: Problem with retrieving info on index '$sIndex' - Error Msg:\\n$sMsg\"
         continue
      }
      set sOrigName \"\"
      catch {set sOrigName $aSymbolic($sIndex)} sMsg
      regsub -all \" \" $sIndex \"\" sOrigNameTest
      if {$sOrigNameTest == $sOrigName} {
         set sOrigName $sIndex
      }
               
      set sDescription [mql print index $sIndex select description dump]
      set slsAttribute [mql print index $sIndex select attribute dump \" | \"]
      set sEnable [mql print index $sIndex select enabled dump]
      set sUnique [mql print index $sIndex select unique dump]
      set sHidden [mql print index $sIndex select hidden dump]
      append sFile \"$sName\\t$sOrigName\\t$sDescription\\t$slsAttribute\\t$sEnable\\t$sUnique\\t$sHidden\\n\"
   }
   set iFile [open $sPath w]
   puts $iFile $sFile
   close $iFile
   if {$bStatus} {puts \"Index data loaded in file $sPath\"}
}
" 1 0 0 0 0 0 0 0 0 0 0 0 "" 0 0
 0 1
 SpinnerAgent NULL noname "3/27/2017 3:41:27 PM" 0
"12/6/2015 10:41:19 PM" "12/29/2017 7:13:26 PM"
16
 0 1 "12/6/2015 10:41:19 PM" creator "add program emxSchema_Dumper.tcl mql execute immediate !needsbusinessobject !downloadable !pipe !pooled nothidden file ./Business/SourceFiles/emxSchema_Dumper.tcl"
 0 2 "12/6/2015 10:41:19 PM" creator "mod program emxSchema_Dumper.tcl description ''"
 0 2 "12/6/2015 10:41:19 PM" creator "add property SpinnerAgent on program emxSchema_Dumper.tcl value '12/6/2015 10:41:19 PM'"
 0 2 "12/6/2015 11:31:49 PM" creator "mod program emxSchema_Dumper.tcl file ./Business/SourceFiles/emxSchema_Dumper.tcl"
 0 2 "12/6/2015 11:31:49 PM" creator "mod property SpinnerAgent on program emxSchema_Dumper.tcl value '12/6/2015 11:31:49 PM'"
 0 2 "12/6/2015 11:42:57 PM" creator "mod program emxSchema_Dumper.tcl file ./Business/SourceFiles/emxSchema_Dumper.tcl"
 0 2 "12/6/2015 11:42:57 PM" creator "mod property SpinnerAgent on program emxSchema_Dumper.tcl value '12/6/2015 11:42:57 PM'"
 0 2 "2/3/2016 5:21:01 PM" creator "mod program emxSchema_Dumper.tcl file ./Business/SourceFiles/emxSchema_Dumper.tcl"
 0 2 "2/3/2016 5:21:01 PM" creator "mod property SpinnerAgent on program emxSchema_Dumper.tcl value '2/3/2016 5:21:01 PM'"
 0 2 "3/7/2016 10:03:58 AM" creator "mod program emxSchema_Dumper.tcl file ./Business/SourceFiles/emxSchema_Dumper.tcl"
 0 2 "3/7/2016 10:03:58 AM" creator "mod property SpinnerAgent on program emxSchema_Dumper.tcl value '3/7/2016 10:03:58 AM'"
 0 2 "3/27/2017 3:41:27 PM" creator "mod program emxSchema_Dumper.tcl file ./Business/SourceFiles/emxSchema_Dumper.tcl"
 0 2 "3/27/2017 3:41:27 PM" creator "mod property SpinnerAgent on program emxSchema_Dumper.tcl value '3/27/2017 3:41:27 PM'"
 0 2 "12/29/2017 7:12:13 PM" creator "  modify program emxSchema_Dumper.tcl !pipe code \"################################################################################    proc Add_Value_Element_To_Array { array_tab element value } { upvar $array_tab $array_tab set array_name $array_tab  if { [array exists $array_name] != 1 } { set ${array_name}($element) [list $value] } else { if { [lsearch -exact [array names $array_name] $element] != -1 } { lappend ${array_name}($element) $value } else { set ${array_name}($element) [list $value] } } return }   proc Replace_Space { string } { regsub -all -- \" \" $string \"_\" string return $string }    proc pGenTrig { sData } {  set temp_data \"\" set sData [ string trim $sData ] set nLen [ string length $sData ]  for {set x 8} {$x<$nLen} {incr x} {  set i [string index $sData $x]  if { $i == \":\" } { append temp_data $sTag \" \" set sTag \"\" } elseif { $i == \"(\" } { set bInside TRUE append temp_data $sTag \" \" set sTag \"\" } elseif { $i == \")\" } { set bInside FALSE append temp_data $sTag set sTag \"\" } elseif { $i == \",\" && $bInside ==\"FALSE\" } { append temp_data \"<BR>\" set sTag \"\" } else { append sTag $i } } return $temp_data }   proc pCheckHidden { lContent sType } {  upvar aAdmin aAdmin  set lOk [ list ] set lAllowed $aAdmin($sType)  foreach sName $lContent { if { [lsearch $lAllowed $sName] != \"-1\" } { #add to list lappend lOk $sName } } return $lOk }   proc Generate_type {} { upvar  Attribute_Types Attribute_Types upvar aAdmin aAdmin global Out_Directory Out_Directory global Image_Directory Image_Directory global sDumpProperties global bDumpSchema global bDumpSpinner global bSuppressHidden  set lProp [list ]  # Get definition instances set Object \"type\" set Instances $aAdmin($Object)  # Head of HTML page set Page_Content \" <HTML> <HEAD> <TITLE>$Object</TITLE> </HEAD> <BODY> \"  # Body of HTML page foreach instance $Instances { if {[catch {set Content [lrange [split [mql print $Object $instance] \\n] 1 end]} sMsg] != 0} {continue}  # Get type icon set Icon_Filename \"[Replace_Space $instance].gif\" catch { mql icon"
 0 2 "12/29/2017 7:13:04 PM" creator "  modify program emxSchema_Dumper.tcl !pipe code \"################################################################################    proc Add_Value_Element_To_Array { array_tab element value } { upvar $array_tab $array_tab set array_name $array_tab  if { [array exists $array_name] != 1 } { set ${array_name}($element) [list $value] } else { if { [lsearch -exact [array names $array_name] $element] != -1 } { lappend ${array_name}($element) $value } else { set ${array_name}($element) [list $value] } } return }   proc Replace_Space { string } { regsub -all -- \" \" $string \"_\" string return $string }    proc pGenTrig { sData } {  set temp_data \"\" set sData [ string trim $sData ] set nLen [ string length $sData ]  for {set x 8} {$x<$nLen} {incr x} {  set i [string index $sData $x]  if { $i == \":\" } { append temp_data $sTag \" \" set sTag \"\" } elseif { $i == \"(\" } { set bInside TRUE append temp_data $sTag \" \" set sTag \"\" } elseif { $i == \")\" } { set bInside FALSE append temp_data $sTag set sTag \"\" } elseif { $i == \",\" && $bInside ==\"FALSE\" } { append temp_data \"<BR>\" set sTag \"\" } else { append sTag $i } } return $temp_data }   proc pCheckHidden { lContent sType } {  upvar aAdmin aAdmin  set lOk [ list ] set lAllowed $aAdmin($sType)  foreach sName $lContent { if { [lsearch $lAllowed $sName] != \"-1\" } { #add to list lappend lOk $sName } } return $lOk }   proc Generate_type {} { upvar  Attribute_Types Attribute_Types upvar aAdmin aAdmin global Out_Directory Out_Directory global Image_Directory Image_Directory global sDumpProperties global bDumpSchema global bDumpSpinner global bSuppressHidden  set lProp [list ]  # Get definition instances set Object \"type\" set Instances $aAdmin($Object)  # Head of HTML page set Page_Content \" <HTML> <HEAD> <TITLE>$Object</TITLE> </HEAD> <BODY> \"  # Body of HTML page foreach instance $Instances { if {[catch {set Content [lrange [split [mql print $Object $instance] \\n] 1 end]} sMsg] != 0} {continue}  # Get type icon set Icon_Filename \"[Replace_Space $instance].gif\" catch { mql icon"
 0 2 "12/29/2017 7:13:26 PM" creator "  modify program emxSchema_Dumper.tcl !pipe code \"################################################################################    proc Add_Value_Element_To_Array { array_tab element value } { upvar $array_tab $array_tab set array_name $array_tab  if { [array exists $array_name] != 1 } { set ${array_name}($element) [list $value] } else { if { [lsearch -exact [array names $array_name] $element] != -1 } { lappend ${array_name}($element) $value } else { set ${array_name}($element) [list $value] } } return }   proc Replace_Space { string } { regsub -all -- \" \" $string \"_\" string return $string }    proc pGenTrig { sData } {  set temp_data \"\" set sData [ string trim $sData ] set nLen [ string length $sData ]  for {set x 8} {$x<$nLen} {incr x} {  set i [string index $sData $x]  if { $i == \":\" } { append temp_data $sTag \" \" set sTag \"\" } elseif { $i == \"(\" } { set bInside TRUE append temp_data $sTag \" \" set sTag \"\" } elseif { $i == \")\" } { set bInside FALSE append temp_data $sTag set sTag \"\" } elseif { $i == \",\" && $bInside ==\"FALSE\" } { append temp_data \"<BR>\" set sTag \"\" } else { append sTag $i } } return $temp_data }   proc pCheckHidden { lContent sType } {  upvar aAdmin aAdmin  set lOk [ list ] set lAllowed $aAdmin($sType)  foreach sName $lContent { if { [lsearch $lAllowed $sName] != \"-1\" } { #add to list lappend lOk $sName } } return $lOk }   proc Generate_type {} { upvar  Attribute_Types Attribute_Types upvar aAdmin aAdmin global Out_Directory Out_Directory global Image_Directory Image_Directory global sDumpProperties global bDumpSchema global bDumpSpinner global bSuppressHidden  set lProp [list ]  # Get definition instances set Object \"type\" set Instances $aAdmin($Object)  # Head of HTML page set Page_Content \" <HTML> <HEAD> <TITLE>$Object</TITLE> </HEAD> <BODY> \"  # Body of HTML page foreach instance $Instances { if {[catch {set Content [lrange [split [mql print $Object $instance] \\n] 1 end]} sMsg] != 0} {continue}  # Get type icon set Icon_Filename \"[Replace_Space $instance].gif\" catch { mql icon"

!MTRX!END

!MTRX!AD! program emxRegUnRegSchema.tcl "3DEXPERIENCE R2015x(24.0.0.0)"
emxRegUnRegSchema.tcl 0 "" "#************************************************************************10.63
# Procedure:   pRegisterSchema
#
# Description: Procedure to register schema element in AEF
#
# Parameters:  Schema Type, Schema Name, Symbolic Name
#
# Returns:     Nothing
#************************************************************************

#  Registration Procedure
#
   proc pRegisterSchema {sProcSchema_Type sProcType_Name sProcOrigName sProcSymbolic} {
   
      global sFile iErrCtr iRegisterCounter bScan sAction bModFlag bShowModOnly bUpdate bAppend bPercent sLogFileError bOut

      array set aName [list 1 version 2 application 3 \"original name\" 4 installer 5 \"installed date\"]
      
      if {[pQuery \"\" \"list program eServiceSystemInformation.tcl\"] != \"\" && [pQuery \"\" \"print program eServiceSystemInformation.tcl select property\\\\\\[appVersionFramework\\\\\\].name dump\"] == \"\"} {
         if {[file exists \"./Business/SpinnerPropertyData.xls\"] == 1} {
            set iFile [open \"./Business/SpinnerPropertyData.xls\" r]
            set sPropertyFile [read $iFile]
            close $iFile
            set iStart [string first \"appVersionFramework\" $sPropertyFile]
            if {$iStart > -1} {
               set sVersion [string range $sPropertyFile $iStart [expr $iStart + 40]]
               regsub -all \"\\\\\\t\" $sVersion \"|\" slsVersion
               mql add property \"appVersionFramework\" on program \"eServiceSystemInformation.tcl\" value [string trim [lindex [split $slsVersion |] 1]]
            }
         }   
      }
      
      set aValue(1) [pQuery \"\" \"print program eServiceSystemInformation.tcl select property\\\\\\[appVersionFramework\\\\\\].value dump\"]
      set aValue(2) Framework;#<=========================== USER MODIFIABLE VARIABLE ***
      set aValue(3) $sProcOrigName
      set aValue(4) \"MatrixOne Professional Services\";#<=== USER MODIFIABLE VARIABLE ***
      set aValue(5) [clock format [clock seconds] -format \"%m-%d-%y\"]
      
      set sSystem \"\"
      if {$sProcSchema_Type == \"table\"} {
         set sSystem \"system\"
      }
      set bUpdate FALSE
      set sAction \"Registration of $sProcSchema_Type $sProcType_Name\"
      set bAppend TRUE
      if {$bScan != \"TRUE\"} {mql start transaction update}
   
      if { [ catch {
         if {$sProcSchema_Type == \"association\"} {
            array set aNameActual [list 1 \"\" 2 \"\" 3 \"\" 4 \"\" 5 \"\"]
            array set aValueActual [list 1 \"\" 2 \"\" 3 \"\" 4 \"\" 5 \"\"]
            set lsPrintAssoc [split [pQuery \"\" \"print association \\\"$sProcType_Name\\\"\"] \\n]
            foreach sPrintAssoc $lsPrintAssoc {
               for {set i 1} {$i < 6} {incr i} {
                  if {[string first $aName($i) $sPrintAssoc] > -1} {
                     set aNameActual($i) $aName($i)
                     regsub \"value\" $sPrintAssoc \"|\" sPrintAssoc
                     set aValueActual($i) [string trim [lindex [split $sPrintAssoc |] 1] ]
                  }
               }
            }
         } else {
            for {set i 1} {$i < 6} {incr i} {
               set aNameActual($i) [pQuery \"\" \"print $sProcSchema_Type \\\"$sProcType_Name\\\" $sSystem select property\\\\\\[$aName($i)\\\\\\].name dump\"]
               set aValueActual($i) [pQuery \"\" \"print $sProcSchema_Type \\\"$sProcType_Name\\\" $sSystem select property\\\\\\[$aName($i)\\\\\\].value dump\"]
            }
         }
         
         if {$aNameActual(3) == \"\" || $aValueActual(3) == \"\"} {
            for {set i 1} {$i < 6} {incr i} {
               set sAddMod \"\"
               if {$aNameActual($i) == \"\"} {
                  set sAddMod add
               } elseif {$aValueActual($i) != $aValue($i)} {
                  set sAddMod mod
               }
               if {$sAddMod != \"\"} {
                  pMqlCmd \"$sAddMod property \\\"$aName($i)\\\" on $sProcSchema_Type \\\"$sProcType_Name\\\" $sSystem value \\\"$aValue($i)\\\"\"
               }
            }
         }

         set lsTo [split [pQuery \"\" \"print program \\\"eServiceSchemaVariableMapping.tcl\\\" select property\\\\\\[$sProcSymbolic\\\\\\].to dump |\"] |]
         if {$lsTo == \"\"} {
            pMqlCmd \"add property \\\"$sProcSymbolic\\\" on program \\\"eServiceSchemaVariableMapping.tcl\\\" to $sProcSchema_Type \\\"$sProcType_Name\\\" $sSystem\"
         } else {
            set sProcSchema_Test $sProcSchema_Type
            if {$sProcSchema_Type == \"attribute\"} {
               set sProcSchema_Test att
            }
            set sProcTest \"$sProcSchema_Test $sProcType_Name\"
            set bPass FALSE
            foreach sTo $lsTo {
               if {$sTo == $sProcTest} {
                  set bPass TRUE
                  break
               }
            }
            if {$bPass != \"TRUE\"} {
               pMqlCmd \"add property \\\"$sProcSymbolic\\\" on program \\\"eServiceSchemaVariableMapping.tcl\\\" to $sProcSchema_Type \\\"$sProcType_Name\\\" $sSystem\"
            }
         }
      } result ] != 0 } {
          if {$bScan != \"TRUE\"} {mql abort transaction}
          if {$sProcSchema_Type == \"page\" || $sProcSchema_Type == \"pageobject\"} {
             pAppend \"REGISTRATION NOT SUCCESSFUL!  $result\\n\" FALSE
             set bOut FALSE
             pWriteWarningMsg \"WARNING: Page registration is not currently supported by MQL! (Page '$sProcType_Name' symbolic name '$sProcSymbolic')\\n\"
             set bOut TRUE
          } else {
             set iLogFileErr [open $sLogFileError a+]
             puts $iLogFileErr \"$sAction\\n$result\\n\"
             close $iLogFileErr
             pAppend \"REGISTRATION NOT SUCCESSFUL!  $result\\n\" FALSE
             incr iErrCtr
          }
          if {$bPercent != \"TRUE\"} {puts -nonewline \"!\"}
      } elseif {$bUpdate} {
         if {$bScan != \"TRUE\"} {pAppend \"# Registration successful.\" FALSE}
         append sFile \"\\n\"
         set bModFlag TRUE
         if {$bScan != \"TRUE\"} {mql commit transaction}
         incr iRegisterCounter
#         if {$bPercent != \"TRUE\"} {puts -nonewline \"r\"}
      } else {
         if {$bScan != \"TRUE\" && $bShowModOnly != \"TRUE\"} {pAppend \" - not required.\" TRUE}
         if {$bScan != \"TRUE\"} {mql commit transaction}
      }
   }

#End pRegisterSchema

#************************************************************************
# Procedure:   pUnRegisterSchema
#
# Description: Procedure to unregister schema element from AEF
#
# Parameters:  Schema Type, Schema Name, Symbolic Name
#
# Returns:     Nothing
#************************************************************************

   proc pUnRegisterSchema {sProcSchema_Type sProcType_Name sProcSymbolic} {
   
      global sFile iErrCtr iRegisterCounter bScan sAction bModFlag bShowModOnly bUpdate bAppend bPercent sLogFileError

      set bUpdate FALSE
      if {$bScan != \"TRUE\"} {mql start transaction update}
      set sAction \"Unregister $sProcSchema_Type $sProcType_Name\"
      set bAppend TRUE
   
      set sSystem \"\"
      if {$sProcSchema_Type == \"table\"} {
         set sSystem \"system\"
      }

      if { [ catch {
          if {$bScan != \"TRUE\"} {
             if {[pQuery \"\" \"print program \\\"eServiceSchemaVariableMapping.tcl\\\" select property\\\\\\[$sProcSymbolic\\\\\\] dump\"] != \"\"} {
                set sProcSchema_Test \"$sProcSchema_Type\"
                if {$sProcSchema_Type == \"attribute\"} {
                   set sProcSchema_Test \"att\"
                }
                
                set sProcTest \"$sProcSchema_Test $sProcType_Name\"
                set lsTo [split [pQuery \"\" \"print program \\\"eServiceSchemaVariableMapping.tcl\\\" select property\\\\\\[$sProcSymbolic\\\\\\].to dump |\"] |]
                foreach sTo $lsTo {
                   if {$sTo == $sProcTest} {
                      pMqlCmd \"delete property \\\"$sProcSymbolic\\\" on program \\\"eServiceSchemaVariableMapping.tcl\\\" to $sProcSchema_Type \\\"$sProcType_Name\\\" $sSystem\"
                      break
                   }
                }
             }
          }
      } result ] != 0 } {
          set iLogFileErr [open $sLogFileError a+]
          puts $iLogFileErr \"$sAction\\n$result\\n\"
          close $iLogFileErr
          pAppend \"UNREGISTRATION NOT SUCCESSFUL!  $result\\n\" FALSE
          if {$bScan != \"TRUE\"} {mql abort transaction}
          incr iErrCtr
          if {$bPercent != \"TRUE\"} {puts -nonewline \"!\"}
      } elseif {$bUpdate} {
         if {$bScan != \"TRUE\"} {pAppend \"# Unregistration successful.\" FALSE}
         append sFile \"\\n\"
         set bModFlag TRUE
         if {$bScan != \"TRUE\"} {mql commit transaction}
         incr iRegisterCounter -1
#         if {$bPercent != \"TRUE\"} {puts -nonewline \"u\"}
      } else {
         if {$bScan != \"TRUE\" && $bShowModOnly != \"TRUE\"} {pAppend \" - not required.\" TRUE}
         if {$bScan != \"TRUE\"} {mql commit transaction}
      }
   }

#End pUnRegisterSchema
" 1 0 0 0 0 0 0 0 0 0 0 0 "" 0 0
 0 1
 SpinnerAgent NULL noname "3/27/2017 3:41:27 PM" 0
"12/6/2015 10:41:19 PM" "3/14/2018 3:57:25 PM"
9
 0 1 "12/6/2015 10:41:19 PM" creator "add program emxRegUnRegSchema.tcl mql execute immediate !needsbusinessobject !downloadable !pipe !pooled nothidden file ./Business/SourceFiles/emxRegUnRegSchema.tcl"
 0 2 "12/6/2015 10:41:19 PM" creator "mod program emxRegUnRegSchema.tcl description ''"
 0 2 "12/6/2015 10:41:19 PM" creator "add property SpinnerAgent on program emxRegUnRegSchema.tcl value '12/6/2015 10:41:19 PM'"
 0 2 "12/6/2015 11:31:49 PM" creator "mod program emxRegUnRegSchema.tcl file ./Business/SourceFiles/emxRegUnRegSchema.tcl"
 0 2 "12/6/2015 11:31:49 PM" creator "mod property SpinnerAgent on program emxRegUnRegSchema.tcl value '12/6/2015 11:31:49 PM'"
 0 2 "2/3/2016 5:21:01 PM" creator "mod program emxRegUnRegSchema.tcl file ./Business/SourceFiles/emxRegUnRegSchema.tcl"
 0 2 "2/3/2016 5:21:01 PM" creator "mod property SpinnerAgent on program emxRegUnRegSchema.tcl value '2/3/2016 5:21:01 PM'"
 0 2 "3/27/2017 3:41:27 PM" creator "mod program emxRegUnRegSchema.tcl file ./Business/SourceFiles/emxRegUnRegSchema.tcl"
 0 2 "3/27/2017 3:41:27 PM" creator "mod property SpinnerAgent on program emxRegUnRegSchema.tcl value '3/27/2017 3:41:27 PM'"

!MTRX!END

